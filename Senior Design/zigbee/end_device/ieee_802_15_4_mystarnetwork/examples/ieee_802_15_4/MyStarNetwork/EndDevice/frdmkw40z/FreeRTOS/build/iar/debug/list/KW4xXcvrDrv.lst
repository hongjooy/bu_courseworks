###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       06/Apr/2016  15:58:40
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\XCVR\MKW40Z4\KW4xXcvrDrv.c
#    Command line =  
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\XCVR\MKW40Z4\KW4xXcvrDrv.c
#        -D DEBUG -D IAR -D CPU_MKW40Z160VHT4 -lcN "C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork\examples\ieee_802_15_4\MyStarNetwork\EndDevice\frdmkw40z\FreeRTOS\build\iar\debug\list"
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        "C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork\examples\ieee_802_15_4\MyStarNetwork\EndDevice\frdmkw40z\FreeRTOS\build\iar\debug\obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" --preinclude "C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork/examples/ieee_802_15_4/MyStarNetwork/EndDevice/frdmkw40z/FreeRTOS/app_preinclude.h"
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/CMSIS/Include\
#        -I "C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork/boards/frdmkw40z\"
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/devices\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/devices/MKW40Z4/include\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/devices/MKW40Z4/startup\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/system/src/clock/MKW40Z4\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/ieee_802_15_4/Source/App\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/ieee_802_15_4/Source/Mac/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/GPIOIrq\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/Keyboard/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/LED/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/SerialManager/Source/SPI_Adapter\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/Common\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/MemManager/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/Messaging/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/OSAbstraction/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/osa/inc\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/Panic/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/RNG/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/SerialManager/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/TimersManager/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/TimersManager/Source\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/FunctionLib\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/Lists\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/SecLib\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/ModuleInfo\
#        -I "C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork/examples/ieee_802_15_4/MyStarNetwork/EndDevice/common\"
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/devices\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/devices/MKW40Z4/startup\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/rtos/FreeRTOS/include\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/rtos/FreeRTOS/port/iar\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/rtos/FreeRTOS/config/KW40Z4/iar\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/ieee_802_15_4/Source/Phy/Source/MKW40Z\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/ieee_802_15_4/Source/Phy/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/XCVR/MKW40Z4\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/DCDC/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/Flash/Internal\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/drivers/src/flash/C90TFS/drvsrc/include\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/drivers/inc\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/system/inc\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/hal/inc\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/utilities/inc\
#        -On
#    List file    =  
#        C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork\examples\ieee_802_15_4\MyStarNetwork\EndDevice\frdmkw40z\FreeRTOS\build\iar\debug\list\KW4xXcvrDrv.lst
#    Object file  =  
#        C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork\examples\ieee_802_15_4\MyStarNetwork\EndDevice\frdmkw40z\FreeRTOS\build\iar\debug\obj\KW4xXcvrDrv.o
#
###############################################################################

C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\XCVR\MKW40Z4\KW4xXcvrDrv.c
      1          /*!
      2          * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3          * All rights reserved.
      4          *
      5          * \file KW4xXcvrDrv.c
      6          * This is a source file for the transceiver driver.
      7          *
      8          * Redistribution and use in source and binary forms, with or without modification,
      9          * are permitted provided that the following conditions are met:
     10          *
     11          * o Redistributions of source code must retain the above copyright notice, this list
     12          *   of conditions and the following disclaimer.
     13          *
     14          * o Redistributions in binary form must reproduce the above copyright notice, this
     15          *   list of conditions and the following disclaimer in the documentation and/or
     16          *   other materials provided with the distribution.
     17          *
     18          * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     19          *   contributors may be used to endorse or promote products derived from this
     20          *   software without specific prior written permission.
     21          *
     22          * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     23          * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     24          * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     25          * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     26          * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     27          * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     28          * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     29          * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     30          * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     31          * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     32          */
     33          
     34          /*! *********************************************************************************
     35          *************************************************************************************
     36          * Include
     37          *************************************************************************************
     38          ********************************************************************************** */
     39          #include "BLEDefaults.h"
     40          #include "ZigbeeDefaults.h"
     41          #include "KW4xXcvrDrv.h"
     42          #include "fsl_os_abstraction.h"
     43          #include "fsl_device_registers.h"
     44          #include "fsl_sim_hal.h"
     45          #include "fsl_gpio_hal.h"
     46          #include "fsl_port_hal.h"
     47          
     48          #include "tsm_ll_timing.h"
     49          #include "ifr_mkw40z4_radio.h"
     50          
     51          #if !USE_DCOC_MAGIC_NUMBERS
     52          #include <math.h>
     53          #endif
     54          
     55          #ifdef gXcvrXtalTrimEnabled_d
     56          #include "Flash_Adapter.h"
     57          #endif
     58          
     59          #define INCLUDE_OLD_DRV_CODE            (0)
     60          #define wait(param) while(param)
     61          #define ASSERT(condition) if(condition) while(1);
     62          
     63          /*! *********************************************************************************
     64          *************************************************************************************
     65          * Private type definitions
     66          *************************************************************************************
     67          ********************************************************************************** */
     68          typedef enum
     69          {
     70              FIRST_INIT = 0,
     71              MODE_CHANGE = 1
     72          } MODE_CHG_SEL_T;
     73          
     74          /*! *********************************************************************************
     75          *************************************************************************************
     76          * Private memory declarations
     77          *************************************************************************************
     78          ********************************************************************************** */
     79          /* Channel Filter coeff for BLE */
     80          const uint8_t gBLERxChfCoeff[8] = {
     81              RX_CHF_COEF0_def_c,
     82              RX_CHF_COEF1_def_c,
     83              RX_CHF_COEF2_def_c,
     84              RX_CHF_COEF3_def_c,
     85              RX_CHF_COEF4_def_c,
     86              RX_CHF_COEF5_def_c,
     87              RX_CHF_COEF6_def_c,
     88              RX_CHF_COEF7_def_c
     89          };
     90          
     91          /* Channel Filter coeff for Zigbee */
     92          const uint8_t gZigbeeRxChfCoeff[8] = {
     93              RX_CHF_COEF0_Zigbee_def_c,
     94              RX_CHF_COEF1_Zigbee_def_c,
     95              RX_CHF_COEF2_Zigbee_def_c,
     96              RX_CHF_COEF3_Zigbee_def_c,
     97              RX_CHF_COEF4_Zigbee_def_c,
     98              RX_CHF_COEF5_Zigbee_def_c,
     99              RX_CHF_COEF6_Zigbee_def_c,
    100              RX_CHF_COEF7_Zigbee_def_c,
    101          };
    102          
    103          const uint8_t gPABiasTbl[8] = PA_BIAS_ENTRIES; /* See tsm_timing_ble.h for PA_BIAS_ENTRIES */
    104          panic_fptr panic_function_ptr = NULL;
    105          uint8_t panic_fptr_is_valid = 0; /* Flag to store validity of the panic function pointer */
    106          static uint8_t gen1_dcgain_trims_enabled = 0;
    107          static uint8_t HWDCoffsetCal = 0;
    108          static uint32_t trim_status = 0xFFFF; /* Status of trims from IFR, default to all failed */
    109          static uint16_t ifr_version = 0xFFFF; /* IFR data format version number, default to maxint. */
    110          
    111          /*! *********************************************************************************
    112          *************************************************************************************
    113          * Public memory declarations
    114          *************************************************************************************
    115          ********************************************************************************** */
    116          const pllChannel_t mapTable [channelMapTableSize] =
    117          {
    118              {0x00000025, 0x07C00000},  /* 0 */
    119              {0x00000025, 0x07C80000},  /* 1 */
    120              {0x00000025, 0x07D00000},  /* 2 */
    121              {0x00000025, 0x07D80000},  /* 3 */
    122              {0x00000025, 0x07E00000},  /* 4 */
    123              {0x00000025, 0x07E80000},  /* 5 */
    124              {0x00000025, 0x07F00000},  /* 6 */
    125              {0x00000025, 0x07F80000},  /* 7 */
    126              {0x00000025, 0x00000000},  /* 8 */
    127              {0x00000025, 0x00080000},  /* 9 */
    128              {0x00000025, 0x00100000},  /* 10 */
    129              {0x00000025, 0x00180000},  /* 11 */
    130              {0x00000025, 0x00200000},  /* 12 */
    131              {0x00000025, 0x00280000},  /* 13 */
    132              {0x00000025, 0x00300000},  /* 14 */
    133              {0x00000025, 0x00380000},  /* 15 */
    134              {0x00000025, 0x00400000},  /* 16 */
    135              {0x00000025, 0x00480000},  /* 17 */
    136              {0x00000025, 0x00500000},  /* 18 */
    137              {0x00000025, 0x00580000},  /* 19 */
    138              {0x00000025, 0x00600000},  /* 20 */
    139              {0x00000025, 0x00680000},  /* 21 */
    140              {0x00000025, 0x00700000},  /* 22 */
    141              {0x00000025, 0x00780000},  /* 23 */
    142              {0x00000025, 0x00800000},  /* 24 */
    143              {0x00000025, 0x00880000},  /* 25 */
    144              {0x00000025, 0x00900000},  /* 26 */
    145              {0x00000025, 0x00980000},  /* 27 */
    146              {0x00000025, 0x00A00000},  /* 28 */
    147              {0x00000025, 0x00A80000},  /* 29 */
    148              {0x00000025, 0x00B00000},  /* 30 */
    149              {0x00000025, 0x00B80000},  /* 31 */
    150              {0x00000025, 0x00C00000},  /* 32 */
    151              {0x00000025, 0x00C80000},  /* 33 */
    152              {0x00000025, 0x00D00000},  /* 34 */
    153              {0x00000025, 0x00D80000},  /* 35 */
    154              {0x00000025, 0x00E00000},  /* 36 */
    155              {0x00000025, 0x00E80000},  /* 37 */
    156              {0x00000025, 0x00F00000},  /* 38 */
    157              {0x00000025, 0x00F80000},  /* 39 */
    158              {0x00000025, 0x01000000},  /* 40 */
    159              {0x00000026, 0x07080000},  /* 41 */
    160              {0x00000026, 0x07100000},  /* 42 */
    161              {0x00000026, 0x07180000},  /* 43 */
    162              {0x00000026, 0x07200000},  /* 44 */
    163              {0x00000026, 0x07280000},  /* 45 */
    164              {0x00000026, 0x07300000},  /* 46 */
    165              {0x00000026, 0x07380000},  /* 47 */
    166              {0x00000026, 0x07400000},  /* 48 */
    167              {0x00000026, 0x07480000},  /* 49 */
    168              {0x00000026, 0x07500000},  /* 50 */
    169              {0x00000026, 0x07580000},  /* 51 */
    170              {0x00000026, 0x07600000},  /* 52 */
    171              {0x00000026, 0x07680000},  /* 53 */
    172              {0x00000026, 0x07700000},  /* 54 */
    173              {0x00000026, 0x07780000},  /* 55 */
    174              {0x00000026, 0x07800000},  /* 56 */
    175              {0x00000026, 0x07880000},  /* 57 */
    176              {0x00000026, 0x07900000},  /* 58 */
    177              {0x00000026, 0x07980000},  /* 59 */
    178              {0x00000026, 0x07A00000},  /* 60 */
    179              {0x00000026, 0x07A80000},  /* 61 */
    180              {0x00000026, 0x07B00000},  /* 62 */
    181              {0x00000026, 0x07B80000},  /* 63 */
    182              {0x00000026, 0x07C00000},  /* 64 */
    183              {0x00000026, 0x07C80000},  /* 65 */
    184              {0x00000026, 0x07D00000},  /* 66 */
    185              {0x00000026, 0x07D80000},  /* 67 */
    186              {0x00000026, 0x07E00000},  /* 68 */
    187              {0x00000026, 0x07E80000},  /* 69 */
    188              {0x00000026, 0x07F00000},  /* 70 */
    189              {0x00000026, 0x07F80000},  /* 71 */
    190              {0x00000026, 0x00000000},  /* 72 */
    191              {0x00000026, 0x00080000},  /* 73 */
    192              {0x00000026, 0x00100000},  /* 74 */
    193              {0x00000026, 0x00180000},  /* 75 */
    194              {0x00000026, 0x00200000},  /* 76 */
    195              {0x00000026, 0x00280000},  /* 77 */
    196              {0x00000026, 0x00300000},  /* 78 */
    197              {0x00000026, 0x00380000},  /* 79 */
    198              {0x00000026, 0x00400000},  /* 80 */
    199              {0x00000026, 0x00480000},  /* 81 */
    200              {0x00000026, 0x00500000},  /* 82 */
    201              {0x00000026, 0x00580000},  /* 83 */
    202              {0x00000026, 0x00600000},  /* 84 */
    203              {0x00000026, 0x00680000},  /* 85 */
    204              {0x00000026, 0x00700000},  /* 86 */
    205              {0x00000026, 0x00780000},  /* 87 */
    206              {0x00000026, 0x00800000},  /* 88 */
    207              {0x00000026, 0x00880000},  /* 89 */
    208              {0x00000026, 0x00900000},  /* 90 */
    209              {0x00000026, 0x00980000},  /* 91 */
    210              {0x00000026, 0x00A00000},  /* 92 */
    211              {0x00000026, 0x00A80000},  /* 93 */
    212              {0x00000026, 0x00B00000},  /* 94 */
    213              {0x00000026, 0x00B80000},  /* 95 */
    214              {0x00000026, 0x00C00000},  /* 96 */
    215              {0x00000026, 0x00C80000},  /* 97 */
    216              {0x00000026, 0x00D00000},  /* 98 */
    217              {0x00000026, 0x00D80000},  /* 99 */
    218              {0x00000026, 0x00E00000},  /* 100 */
    219              {0x00000026, 0x00E80000},  /* 101 */
    220              {0x00000026, 0x00F00000},  /* 102 */
    221              {0x00000026, 0x00F80000},  /* 103 */
    222              {0x00000026, 0x01000000},  /* 104 */
    223              {0x00000027, 0x07080000},  /* 105 */
    224              {0x00000027, 0x07100000},  /* 106 */
    225              {0x00000027, 0x07180000},  /* 107 */
    226              {0x00000027, 0x07200000},  /* 108 */
    227              {0x00000027, 0x07280000},  /* 109 */
    228              {0x00000027, 0x07300000},  /* 110 */
    229              {0x00000027, 0x07380000},  /* 111 */
    230              {0x00000027, 0x07400000},  /* 112 */
    231              {0x00000027, 0x07480000},  /* 113 */
    232              {0x00000027, 0x07500000},  /* 114 */
    233              {0x00000027, 0x07580000},  /* 115 */
    234              {0x00000027, 0x07600000},  /* 116 */
    235              {0x00000027, 0x07680000},  /* 117 */
    236              {0x00000027, 0x07700000},  /* 118 */
    237              {0x00000027, 0x07780000},  /* 119 */
    238              {0x00000027, 0x07800000},  /* 120 */
    239              {0x00000027, 0x07880000},  /* 121 */
    240              {0x00000027, 0x07900000},  /* 122 */
    241              {0x00000027, 0x07980000},  /* 123 */
    242              {0x00000027, 0x07A00000},  /* 124 */
    243              {0x00000027, 0x07A80000},  /* 125 */
    244              {0x00000027, 0x07B00000},  /* 126 */
    245              {0x00000027, 0x07B80000}   /* 127 */
    246          };
    247          
    248          /* Following are software trimmed values. They are initialized to potential
    249           * blind trim values with the intent that IFR trims overwrite these blind
    250           * trim values 
    251           */
    252          float adc_gain_trimmed = ADC_SCALE_FACTOR;
    253          uint8_t zb_tza_cap_tune = ZGBE_TZA_CAP_TUNE_def_c; 
    254          uint8_t zb_bbf_cap_tune = ZGBE_BBF_CAP_TUNE_def_c; 
    255          uint8_t zb_bbf_res_tune2 = ZGBE_BBF_RES_TUNE2_def_c;
    256          uint8_t ble_tza_cap_tune = BLE_TZA_CAP_TUNE_def_c;
    257          uint8_t ble_bbf_cap_tune = BLE_BBF_CAP_TUNE_def_c; 
    258          uint8_t ble_bbf_res_tune2 = BLE_BBF_RES_TUNE2_def_c; 
    259          
    260          /*! *********************************************************************************
    261          *************************************************************************************
    262          * Private prototypes
    263          *************************************************************************************
    264          ********************************************************************************** */
    265          /* Common initialization and mode change routine, called by XcvrInit() and XcvRModeChange() */
    266          void XcvrInit_ModeChg_Common ( radio_mode_t radioMode, MODE_CHG_SEL_T mode_change );
    267          
    268          xcvrStatus_t XcvrCalcSetupDcoc ( void );
    269          void XcvrManualDCOCCal (uint8_t chnum);
    270          
    271          void XcvrSetTsmDefaults ( radio_mode_t radioMode );
    272          void XcvrSetRxDigDefaults (  const uint8_t * filt_coeff_ptr, uint8_t iir3a_idx, uint8_t iir2a_idx, uint8_t iir1a_idx, uint8_t rssi_hold_src );
    273          void XcvrSetTxDigPLLDefaults( radio_mode_t radioMode );
    274          void XcvrSetAnalogDefaults ( radio_mode_t radioMode );
    275          
    276          /* Separate out Mode Switch portion of init routines
    277           * call these routines with the target mode during a mode switch 
    278           */
    279          void XcvrSetTsmDef_ModeSwitch ( radio_mode_t radioMode );
    280          void XcvrSetRxDigDef_ModeSwitch (  const uint8_t * filt_coeff_ptr, uint8_t iir3a_idx, uint8_t iir2a_idx, uint8_t iir1a_idx, uint8_t rssi_hold_src );
    281          void XcvrSetTxDigPLLDef_ModeSwitch( radio_mode_t radioMode );
    282          void XcvrSetAnalogDef_ModeSwitch ( radio_mode_t radioMode );
    283          
    284          void XcvrPanic (uint32_t panic_id, uint32_t location);
    285          void XcvrDelay(uint32_t time);
    286          
    287          /*! *********************************************************************************
    288          *************************************************************************************
    289          * Public functions
    290          *************************************************************************************
    291          ********************************************************************************** */
    292          
    293          /*! *********************************************************************************
    294          * \brief  This function initializes the transceiver for operation in a particular
    295          *  radioMode (BLE or Zigbee)
    296          *
    297          * \param[in] radioMode - the operating mode to which the radio should be initialized.
    298          *
    299          * \ingroup PublicAPIs
    300          *
    301          * \details
    302          *
    303          ***********************************************************************************/
    304          void XcvrInit ( radio_mode_t radioMode )
    305          {
    306              XcvrInit_ModeChg_Common(radioMode,FIRST_INIT);
    307          #ifdef gXcvrXtalTrimEnabled_d
    308            if( 0xFFFFFFFF != gHardwareParameters.xtalTrim )
    309            {
    310                XcvrSetXtalTrim( (uint8_t)gHardwareParameters.xtalTrim );
    311            }
    312          #endif
    313          }
    314          
    315          /*! *********************************************************************************
    316          * \brief  This function changes the radio operating mode between BLE and Zigbee 
    317          *
    318          * \param[in] radioMode - the new operating mode for the radio
    319          *
    320          * \ingroup PublicAPIs
    321          *
    322          * \details
    323          *
    324          ***********************************************************************************/
    325          xcvrStatus_t XcvrChangeMode ( radio_mode_t radioMode )
    326          {
    327              XcvrInit_ModeChg_Common(radioMode, MODE_CHANGE);
    328              return gXcvrSuccess_c;
    329          }
    330          
    331          /*! *********************************************************************************
    332          * \brief  This function allows a callback function to be registered allowing the
    333          *  transceiver software to call a PANIC function in case of software error
    334          *
    335          * \param[in] fptr - a pointer to a function which implements system PANIC
    336          *
    337          * \ingroup PublicAPIs
    338          *
    339          * \details
    340          *
    341          ***********************************************************************************/
    342          void XcvrRegisterPanicCb ( panic_fptr fptr )
    343          {
    344              panic_function_ptr = fptr;
    345              panic_fptr_is_valid = 1;
    346          }
    347          
    348          /*! *********************************************************************************
    349          * \brief  This function allows a upper layer software to poll the health of the
    350          *  transceiver to detect problems in the radio operation.
    351          *
    352          * \return radio_status - current status of the radio, 0 = no failures. Any other
    353          *       value indicates a failure, see ::healthStatus_t for the possible values
    354          *       which may all be OR'd together as needed.        
    355          *
    356          * \ingroup PublicAPIs
    357          *
    358          * \details
    359          *
    360          ***********************************************************************************/
    361          healthStatus_t XcvrHealthCheck ( void )
    362          {
    363              healthStatus_t retval = NO_ERRORS;
    364              /* Read PLL status bits and set return values */
    365              if (XCVR_BRD_PLL_LOCK_DETECT_CTFF(XCVR) == 1)
    366              {
    367                  retval |= PLL_CTUNE_FAIL;
    368              }
    369              if (XCVR_BRD_PLL_LOCK_DETECT_CSFF(XCVR) == 1)
    370              {
    371                  retval |= PLL_CYCLE_SLIP_FAIL;
    372              }
    373              if (XCVR_BRD_PLL_LOCK_DETECT_FTFF(XCVR) == 1)
    374              {
    375                  retval |= PLL_FREQ_TARG_FAIL;
    376              }
    377              if (XCVR_BRD_PLL_LOCK_DETECT_TAFF(XCVR) == 1)
    378              {
    379                  retval |= PLL_TSM_ABORT_FAIL;
    380              }
    381              /* Once errors have been captured, clear the sticky flags.
    382               * Sticky bits are W1C so this clears them. 
    383               */
    384              XCVR_PLL_LOCK_DETECT = (uint32_t)(XCVR_PLL_LOCK_DETECT);
    385              return retval;
    386          }
    387          
    388          /*! *********************************************************************************
    389          * \brief  This function allows a upper layer software to control the state of the
    390          * Fast Antenna Diversity (FAD) and Low Power Preamble Search (LPPS) features for
    391          * the Zigbee radio.
    392          *
    393          * \param control - desired setting for combined FAD/LPPS feature.        
    394          *
    395          * \ingroup PublicAPIs
    396          *
    397          * \details
    398          *       FAD and LPPS are mutually exclusive features, they cannot be enabled at 
    399          *       the same time so this API enforces that restriction.
    400          *       This API only controls the transceiver functionality related to FAD and 
    401          *       LPPS, it does not affect any link layer functionality that may be required.
    402          * \note
    403          *       This code does NOT set the pin muxing for the GPIO pins required for this
    404          *       feature. TSM_GPIO2 and TSM_GPIO3 pins are used for TX and RX respectively.
    405          ***********************************************************************************/
    406          void XcvrFadLppsControl(FAD_LPPS_CTRL_T control)
    407          {
    408              switch (control)
    409              {
    410              case NONE:
    411                  /* Disable FAD */
    412                  XCVR_TSM_TIMING42 = (uint32_t)(TSM_REG_VALUE(0xFF, 0xFF, 0xFF, 0xFF)); /* Disabled TSM signal */
    413                  XCVR_TSM_TIMING43 = (uint32_t)(TSM_REG_VALUE(0xFF, 0xFF, 0xFF, 0xFF)); /* Disabled TSM signal */
    414                  /* Disable LPPS */
    415                  XCVR_BWR_LPPS_CTRL_LPPS_ENABLE(XCVR, 0);
    416                  break;
    417              case FAD_ENABLED:
    418                  /* Enable FAD */
    419                  XCVR_TSM_TIMING42 = (uint32_t)(TSM_REG_VALUE(0xFF, 0xFF, 0xFF, END_OF_TX_WU_BLE));
    420                  XCVR_TSM_TIMING43 = (uint32_t)(TSM_REG_VALUE(0xFF, END_OF_RX_WU_BLE, 0xFF, 0xFF));
    421                  /* Disable LPPS */
    422                  XCVR_BWR_LPPS_CTRL_LPPS_ENABLE(XCVR, 0);
    423                  break;
    424              case LPPS_ENABLED:
    425                  /* Disable FAD */
    426                  XCVR_TSM_TIMING42 = (uint32_t)(TSM_REG_VALUE(0xFF, 0xFF, 0xFF, 0xFF)); /* Disabled TSM signal */
    427                  XCVR_TSM_TIMING43 = (uint32_t)(TSM_REG_VALUE(0xFF, 0xFF, 0xFF, 0xFF)); /* Disabled TSM signal */
    428                  /* Enable LPPS */
    429                  XCVR_LPPS_CTRL = (uint32_t)(XCVR_LPPS_CTRL_LPPS_QGEN25_ALLOW_MASK |
    430                                              XCVR_LPPS_CTRL_LPPS_ADC_ALLOW_MASK |
    431                                                  XCVR_LPPS_CTRL_LPPS_ADC_CLK_ALLOW_MASK |
    432                                                      XCVR_LPPS_CTRL_LPPS_ADC_I_Q_ALLOW_MASK |
    433                                                          XCVR_LPPS_CTRL_LPPS_ADC_DAC_ALLOW_MASK |
    434                                                              XCVR_LPPS_CTRL_LPPS_BBF_ALLOW_MASK |
    435                                                                  XCVR_LPPS_CTRL_LPPS_TCA_ALLOW_MASK
    436                                                                      );
    437                  XCVR_BWR_LPPS_CTRL_LPPS_ENABLE(XCVR, 1);
    438                  break;
    439              default:
    440                  /* PANIC? */
    441                  break;
    442              }
    443          }
    444          
    445          /*! *********************************************************************************
    446          * \brief  This function calls the system panic function for radio errors.
    447          *
    448          * \param[in] panic_id The identifier for the radio error.
    449          * \param[in] location The location (address) in the code where the error happened.
    450          *
    451          *
    452          * \ingroup PrivateAPIs
    453          *
    454          * \details This function is a common flow for both first init of the radio as well as 
    455          * mode change of the radio. 
    456          *
    457          ***********************************************************************************/
    458          void XcvrPanic (uint32_t panic_id, uint32_t location)
    459          {
    460              if (panic_fptr_is_valid)
    461              {
    462                  (*panic_function_ptr)(panic_id, location, (uint32_t)0, (uint32_t)0);
    463              }
    464              else
    465              {
    466                  while(1); /* No panic function registered. */
    467              }
    468          }
    469          
    470          /*! *********************************************************************************
    471          * \brief  This function initializes or changes the mode of the transceiver.
    472          *
    473          * \param[in] radioMode The target operating mode of the radio.
    474          * \param[in] mode_change Whether this is an initialization or a mode change (FIRST_INIT == Init, MODE_CHANGE==mode change).
    475          *
    476          *
    477          * \ingroup PrivateAPIs
    478          *
    479          * \details This function is a common flow for both first init of the radio as well as 
    480          * mode change of the radio. 
    481          *
    482          ***********************************************************************************/
    483          void XcvrInit_ModeChg_Common ( radio_mode_t radioMode, MODE_CHG_SEL_T mode_change )
    484          {
    485              static radio_mode_t last_mode = INVALID_MODE;
    486              
    487              uint8_t osr;
    488              uint8_t norm_en;
    489              uint8_t chf_bypass;
    490              IFR_SW_TRIM_TBL_ENTRY_T sw_trim_tbl[] =
    491              {
    492                  {ADC_GAIN, 0, FALSE},      /* Fetch the ADC GAIN parameter if available. */
    493                  {ZB_FILT_TRIM, 0, FALSE},  /* Fetch the Zigbee BBW filter trim if available. */
    494                  {BLE_FILT_TRIM, 0, FALSE}, /* Fetch the BLE BBW filter trim if available. */
    495                  {TRIM_STATUS, 0, FALSE},   /* Fetch the trim status word if available. */
    496                  {TRIM_VERSION, 0, FALSE}   /* Fetch the trim version number if available. */
    497              };
    498              
    499          #define NUM_TRIM_TBL_ENTRIES    sizeof(sw_trim_tbl)/sizeof(IFR_SW_TRIM_TBL_ENTRY_T)  
    500              
    501              if( radioMode == last_mode )
    502              {
    503                  return;
    504              }
    505              else
    506              {
    507                  last_mode = radioMode;
    508              }
    509              
    510              /* Check that this is the proper chip version */
    511              if ((RSIM_ANA_TEST >> 24) & 0xF != 0x2)
    512              {
    513                  XcvrPanic(WRONG_RADIO_ID_DETECTED,(uint32_t)&XcvrInit_ModeChg_Common);
    514              }
    515              
    516              
    517              /* Enable XCVR_DIG, LTC and DCDC clock always, independent of radio mode.
    518              * Only enable one of BTLL or Zigbee.
    519              */    
    520              switch (radioMode) 
    521              {
    522              case BLE:
    523                  SIM_SCGC5 |=  SIM_SCGC5_BTLL_MASK | SIM_SCGC5_PHYDIG_MASK;
    524                  break;
    525              case ZIGBEE:
    526                  SIM_SCGC5 |=  SIM_SCGC5_ZigBee_MASK | SIM_SCGC5_PHYDIG_MASK;
    527                  break;
    528              default:
    529                  break;
    530              }   
    531              
    532              HWDCoffsetCal = 0;  /* Default to using SW DCOC calibration */
    533              
    534              gen1_dcgain_trims_enabled = 0;
    535              handle_ifr(&sw_trim_tbl[0], NUM_TRIM_TBL_ENTRIES);
    536              
    537              /* Transfer values from sw_trim_tbl[] to static variables used in radio operation */
    538              {
    539                  uint16_t i;
    540                  for (i=0;i<NUM_TRIM_TBL_ENTRIES;i++)
    541                  {
    542                      if (sw_trim_tbl[i].valid == TRUE)
    543                      {
    544                          switch (sw_trim_tbl[i].trim_id)
    545                          {
    546                              /* ADC_GAIN */
    547                          case ADC_GAIN:
    548                              adc_gain_trimmed = (float)sw_trim_tbl[i].trim_value/(float)(0x400);
    549                              gen1_dcgain_trims_enabled = 1; /* Only enable code that handles these trims if the ADC_GAIN is present. */
    550                              break;
    551                              /* ZB_FILT_TRIM */
    552                          case ZB_FILT_TRIM:
    553                              zb_tza_cap_tune = ((sw_trim_tbl[i].trim_value & IFR_TZA_CAP_TUNE_MASK)>>IFR_TZA_CAP_TUNE_SHIFT);
    554                              zb_bbf_cap_tune = ((sw_trim_tbl[i].trim_value & IFR_BBF_CAP_TUNE_MASK)>>IFR_BBF_CAP_TUNE_SHIFT);
    555                              zb_bbf_res_tune2 = ((sw_trim_tbl[i].trim_value & IFR_RES_TUNE2_MASK)>>IFR_RES_TUNE2_SHIFT); 
    556                              break;
    557                              /* BLE_FILT_TRIM */
    558                          case BLE_FILT_TRIM:
    559                              ble_tza_cap_tune = ((sw_trim_tbl[i].trim_value & IFR_TZA_CAP_TUNE_MASK)>>IFR_TZA_CAP_TUNE_SHIFT);
    560                              ble_bbf_cap_tune = ((sw_trim_tbl[i].trim_value & IFR_BBF_CAP_TUNE_MASK)>>IFR_BBF_CAP_TUNE_SHIFT);
    561                              ble_bbf_res_tune2 = ((sw_trim_tbl[i].trim_value & IFR_RES_TUNE2_MASK)>>IFR_RES_TUNE2_SHIFT); 
    562                              break;
    563                          case TRIM_STATUS:
    564                              trim_status = sw_trim_tbl[i].trim_value;
    565                              break;
    566                          case TRIM_VERSION:
    567                              ifr_version = sw_trim_tbl[i].trim_value & 0xFFFF; 
    568                              break;
    569                          default:
    570                              break;
    571                          }
    572                      }
    573                  }
    574              }
    575              
    576              {
    577                  static uint32_t tempstatus = 0;
    578                  tempstatus = (trim_status & (BGAP_VOLTAGE_TRIM_FAILED | IQMC_GAIN_ADJ_FAILED | IQMC_GAIN_ADJ_FAILED | IQMC_DC_GAIN_ADJ_FAILED));
    579                  /* Determine whether this IC can support HW DC Offset Calibration.
    580                  * Must be v3 or greater trim version and != 0xFFFF
    581                  * Must have BGAP, IQMC and IQ DC GAIN calibration SUCCESS 
    582                  * OR - may be over-ridden by a compile time flag to force HW DCOC cal
    583                  */
    584                  if (((ifr_version >= 3) && 
    585                       (ifr_version != 0xFFFF) &&
    586                           (ifr_version != 0xFFFE) && /* Special version number indicating fallback IFR table used due to untrimmed part. */
    587                               (tempstatus == 0)) ||
    588                      (ENGINEERING_TRIM_BYPASS))
    589                  {
    590                      HWDCoffsetCal = 1;
    591                  }
    592              }
    593              
    594              XCVR_BWR_BGAP_CTRL_BGAP_ATST_ON(XCVR, 0);    
    595              
    596              if (mode_change == MODE_CHANGE)
    597              {
    598                  /* Change only mode dependent analog & TSM settings */
    599                  XcvrSetAnalogDef_ModeSwitch(radioMode);
    600                  XcvrSetTsmDef_ModeSwitch(radioMode);
    601              }
    602              else
    603              {
    604                  /* Setup initial analog & TSM settings */
    605                  XcvrSetAnalogDefaults(radioMode);    
    606                  XcvrSetTsmDefaults(radioMode);    
    607              }
    608              
    609              /* RX Channel filter coeffs and TSM settings are specific to modes */
    610              switch (radioMode) 
    611              {
    612              case BLE:
    613                  if (mode_change == MODE_CHANGE)
    614                  {
    615                      XcvrSetRxDigDef_ModeSwitch(&gBLERxChfCoeff[0], DCOC_CAL_IIR3A_IDX_def_c, DCOC_CAL_IIR2A_IDX_def_c, DCOC_CAL_IIR1A_IDX_def_c, RSSI_HOLD_SRC_def_c);
    616                  }
    617                  else
    618                  {
    619                      XcvrSetRxDigDefaults(&gBLERxChfCoeff[0], DCOC_CAL_IIR3A_IDX_def_c, DCOC_CAL_IIR2A_IDX_def_c, DCOC_CAL_IIR1A_IDX_def_c, RSSI_HOLD_SRC_def_c);
    620                  }
    621                  XCVR_BWR_CTRL_PROTOCOL(XCVR, BLE_PROTOCOL_def_c);              /* BLE protocol selection */
    622                  XCVR_BWR_CTRL_TGT_PWR_SRC(XCVR, BLE_TGT_PWR_SRC_def_c);
    623                  XCVR_BWR_AGC_CTRL_0_FREEZE_AGC_SRC(XCVR, FREEZE_AGC_SRC_def_c); /* Freeze AGC */
    624                  osr = RX_DEC_FILT_OSR_BLE_def_c;      /* OSR 4 */
    625                  norm_en = RX_NORM_EN_BLE_def_c;       /* Normalizer OFF */
    626                  chf_bypass = RX_CH_FILT_BYPASS_def_c; /* BLE Channel filter setting */
    627                  
    628                  /* DCOC_CTRL_0 & RX_DIG_CTRL settings done separately from other RX_DIG*/
    629                  /* DCOC_CTRL_0 */ 
    630                  XCVR_DCOC_CTRL_0 = (uint32_t)(
    631                                                (ALPHAC_SCALE_IDX_def_c << XCVR_DCOC_CTRL_0_DCOC_ALPHAC_SCALE_IDX_SHIFT) |
    632                                                (ALPHA_RADIUS_IDX_def_c << XCVR_DCOC_CTRL_0_DCOC_ALPHA_RADIUS_IDX_SHIFT) |
    633                                                (SIGN_SCALE_IDX_def_c << XCVR_DCOC_CTRL_0_DCOC_SIGN_SCALE_IDX_SHIFT) |
    634                                                (DCOC_CAL_DURATION_def_c << XCVR_DCOC_CTRL_0_DCOC_CAL_DURATION_SHIFT) |
    635                                                (DCOC_CORR_DLY_def_c << XCVR_DCOC_CTRL_0_DCOC_CORR_DLY_SHIFT) |
    636                                                (DCOC_CORR_HOLD_TIME_def_c << XCVR_DCOC_CTRL_0_DCOC_CORR_HOLD_TIME_SHIFT) |
    637                                                (DCOC_MAN_def_c << XCVR_DCOC_CTRL_0_DCOC_MAN_SHIFT) |
    638                                                (DCOC_TRACK_EN_def_c << XCVR_DCOC_CTRL_0_DCOC_TRACK_EN_SHIFT) |
    639                                                (DCOC_CORRECT_EN_def_c << XCVR_DCOC_CTRL_0_DCOC_CORRECT_EN_SHIFT) 
    640                                               );  
    641                  break;
    642              case ZIGBEE:
    643                  if (mode_change == MODE_CHANGE)
    644                  {
    645                      XcvrSetRxDigDef_ModeSwitch(&gZigbeeRxChfCoeff[0], IIR3A_IDX_Zigbee_def_c, IIR2A_IDX_Zigbee_def_c, IIR1A_IDX_Zigbee_def_c, RSSI_HOLD_SRC_Zigbee_def_c);
    646                  }
    647                  else
    648                  {
    649                      XcvrSetRxDigDefaults(&gZigbeeRxChfCoeff[0], IIR3A_IDX_Zigbee_def_c, IIR2A_IDX_Zigbee_def_c, IIR1A_IDX_Zigbee_def_c, RSSI_HOLD_SRC_Zigbee_def_c);
    650                  }
    651                  XCVR_BWR_CTRL_PROTOCOL(XCVR, Zigbee_PROTOCOL_def_c); /* Zigbee protocol selection */
    652                  XCVR_BWR_CTRL_TGT_PWR_SRC(XCVR, Zigbee_TGT_PWR_SRC_def_c);
    653                  XCVR_BWR_AGC_CTRL_0_FREEZE_AGC_SRC(XCVR, FREEZE_AGC_SRC_Zigbee_def_c);  /* Freeze AGC */
    654                  /* Correlation zero count for Zigbee preamble detection */
    655                  XCVR_BWR_CORR_CTRL_CORR_NVAL(XCVR, CORR_NVAL_Zigbee_def_c);
    656                  /* Correlation threshold */
    657                  XCVR_BWR_CORR_CTRL_CORR_VT(XCVR, CORR_VT_Zigbee_def_c);
    658                  osr = RX_DEC_FILT_OSR_Zigbee_def_c;          /* OSR 8 */
    659                  norm_en = RX_NORM_EN_Zigbee_def_c;           /* Normalizer On */
    660                  chf_bypass = RX_CH_FILT_BYPASS_Zigbee_def_c; /* Zigbee Channel filter setting */
    661                  
    662                  /* DCOC_CTRL_0 & RX_DIG_CTRL settings done separately from other RX_DIG*/
    663                  /* DCOC_CTRL_0 */
    664                  XCVR_DCOC_CTRL_0 = (uint32_t)(
    665                                                (ALPHAC_SCALE_IDX_Zigbee_def_c << XCVR_DCOC_CTRL_0_DCOC_ALPHAC_SCALE_IDX_SHIFT) |
    666                                                (ALPHA_RADIUS_IDX_Zigbee_def_c << XCVR_DCOC_CTRL_0_DCOC_ALPHA_RADIUS_IDX_SHIFT) |
    667                                                (SIGN_SCALE_IDX_Zigbee_def_c << XCVR_DCOC_CTRL_0_DCOC_SIGN_SCALE_IDX_SHIFT) |
    668                                                (DCOC_CAL_DURATION_Zigbee_def_c << XCVR_DCOC_CTRL_0_DCOC_CAL_DURATION_SHIFT) |
    669                                                (DCOC_CORR_DLY_Zigbee_def_c << XCVR_DCOC_CTRL_0_DCOC_CORR_DLY_SHIFT) |
    670                                                (DCOC_CORR_HOLD_TIME_Zigbee_def_c << XCVR_DCOC_CTRL_0_DCOC_CORR_HOLD_TIME_SHIFT) |
    671                                                (DCOC_MAN_Zigbee_def_c << XCVR_DCOC_CTRL_0_DCOC_MAN_SHIFT) |
    672                                                (DCOC_TRACK_EN_Zigbee_def_c << XCVR_DCOC_CTRL_0_DCOC_TRACK_EN_SHIFT) |
    673                                                (DCOC_CORRECT_EN_Zigbee_def_c << XCVR_DCOC_CTRL_0_DCOC_CORRECT_EN_SHIFT) 
    674                                               );
    675                  break;
    676              default:
    677                  break;
    678              }
    679              
    680              if (mode_change == MODE_CHANGE)
    681              {
    682                  XcvrSetTxDigPLLDef_ModeSwitch(radioMode);
    683              }
    684              else
    685              {
    686                  XcvrSetTxDigPLLDefaults(radioMode);
    687              }
    688              
    689              XCVR_DCOC_CTRL_0 = (uint32_t)((XCVR_DCOC_CTRL_0 & (uint32_t)~(uint32_t)(
    690                                     XCVR_DCOC_CTRL_0_DCOC_MAN_MASK |
    691                                     XCVR_DCOC_CTRL_0_DCOC_TRACK_EN_MASK |
    692                                     XCVR_DCOC_CTRL_0_DCOC_CORRECT_EN_MASK 
    693                                    )) | (uint32_t)(
    694                                     (DCOC_MAN_def_c << XCVR_DCOC_CTRL_0_DCOC_MAN_SHIFT) |
    695                                     (DCOC_TRACK_EN_def_c << XCVR_DCOC_CTRL_0_DCOC_TRACK_EN_SHIFT) |
    696                                     (DCOC_CORRECT_EN_def_c << XCVR_DCOC_CTRL_0_DCOC_CORRECT_EN_SHIFT) 
    697                                    ));    
    698            
    699              /* DCOC_CTRL_0 & RX_DIG_CTRL settings done separately from other RX_DIG*/
    700              /* RX_DIG_CTRL */
    701              XCVR_RX_DIG_CTRL = (uint32_t)((XCVR_RX_DIG_CTRL & (uint32_t)~(uint32_t)(
    702                                     XCVR_RX_DIG_CTRL_RX_RSSI_EN_MASK |
    703                                     XCVR_RX_DIG_CTRL_RX_AGC_EN_MASK |
    704                                     XCVR_RX_DIG_CTRL_RX_DCOC_EN_MASK |
    705                                     XCVR_RX_DIG_CTRL_RX_DEC_FILT_OSR_MASK |
    706                                     XCVR_RX_DIG_CTRL_RX_NORM_EN_MASK |
    707                                     XCVR_RX_DIG_CTRL_RX_INTERP_EN_MASK |
    708                                     XCVR_RX_DIG_CTRL_RX_CH_FILT_BYPASS_MASK |
    709                                     XCVR_RX_DIG_CTRL_RX_DCOC_CAL_EN_MASK 
    710                                    )) | (uint32_t)(
    711                                     (RX_RSSI_EN_def_c << XCVR_RX_DIG_CTRL_RX_RSSI_EN_SHIFT) |
    712                                     (RX_AGC_EN_def_c << XCVR_RX_DIG_CTRL_RX_AGC_EN_SHIFT) |
    713                                     (RX_DCOC_EN_def_c << XCVR_RX_DIG_CTRL_RX_DCOC_EN_SHIFT) |
    714                                     (osr << XCVR_RX_DIG_CTRL_RX_DEC_FILT_OSR_SHIFT) |
    715                                     (norm_en << XCVR_RX_DIG_CTRL_RX_NORM_EN_SHIFT) |
    716                                     (RX_INTERP_EN_def_c << XCVR_RX_DIG_CTRL_RX_INTERP_EN_SHIFT) |
    717                                     (chf_bypass << XCVR_RX_DIG_CTRL_RX_CH_FILT_BYPASS_SHIFT) |
    718                                     (0 << XCVR_RX_DIG_CTRL_RX_DCOC_CAL_EN_SHIFT)  /* DCOC_CAL_EN set to zero here, changed below if appropriate */
    719                                    ));    
    720              
    721              if (HWDCoffsetCal)
    722              {
    723                  XCVR_BWR_RX_DIG_CTRL_RX_DCOC_CAL_EN(XCVR, 1); /* DCOC_CAL 1=Enabled */
    724              }
    725              else
    726              {
    727                  /* DCOC Calibration issue workaround. Performs a manual DCOC calibration and disables RX_DCOC_CAL_EN
    728                  * Manipulates AGC settings during the calibration and then reverts them
    729                  */
    730                  if (mode_change == FIRST_INIT)
    731                  {
    732                      switch (radioMode) 
    733                      {
    734                      case BLE:
    735                          XcvrManualDCOCCal(20);  /* Use channel 20 for BLE calibration @ ~mid-band */
    736                          break;
    737                      case ZIGBEE:        
    738                          XcvrManualDCOCCal(18);  /* Use channel 18 for Zigbee calibration @ ~mid-band */
    739                          break;
    740                      default:
    741                          break;
    742                      } 
    743                  }
    744              }
    745          }
    746          
    747          /*! *********************************************************************************
    748          * \brief  This function sets the default vaues of the TSM registers.
    749          *
    750          * \param[in] radioMode Radio mode is used to enable mode specific settings.
    751          *
    752          * \ingroup PrivateAPIs
    753          *
    754          * \details This function also sets link layer registers to account for TX and
    755          *       delays.
    756          *
    757          ***********************************************************************************/
    758          void XcvrSetTsmDefaults ( radio_mode_t radioMode )
    759          { 
    760              /*TSM_CTRL*/
    761              XCVR_TSM_CTRL = (uint32_t)((XCVR_TSM_CTRL & (uint32_t)~(uint32_t)(    
    762                                  XCVR_TSM_CTRL_BKPT_MASK | 
    763                                  XCVR_TSM_CTRL_ABORT_ON_FREQ_TARG_MASK |
    764                                  XCVR_TSM_CTRL_ABORT_ON_CYCLE_SLIP_MASK |
    765                                  XCVR_TSM_CTRL_ABORT_ON_CTUNE_MASK |
    766                                  XCVR_TSM_CTRL_RX_ABORT_DIS_MASK |
    767                                  XCVR_TSM_CTRL_TX_ABORT_DIS_MASK |
    768                                  XCVR_TSM_CTRL_DATA_PADDING_EN_MASK |
    769                                  XCVR_TSM_CTRL_PA_RAMP_SEL_MASK |
    770                                  XCVR_TSM_CTRL_FORCE_RX_EN_MASK |
    771                                  XCVR_TSM_CTRL_FORCE_TX_EN_MASK 
    772                                 )) | (uint32_t)(
    773                                  (BKPT_def_c << XCVR_TSM_CTRL_BKPT_SHIFT) |
    774                                  (ABORT_ON_FREQ_TARG_def_c << XCVR_TSM_CTRL_ABORT_ON_FREQ_TARG_SHIFT) |
    775                                  (ABORT_ON_CYCLE_SLIP_def_c << XCVR_TSM_CTRL_ABORT_ON_CYCLE_SLIP_SHIFT) |
    776                                  (ABORT_ON_CTUNE_def_c << XCVR_TSM_CTRL_ABORT_ON_CTUNE_SHIFT) |
    777                                  (RX_ABORT_DIS_def_c << XCVR_TSM_CTRL_RX_ABORT_DIS_SHIFT) |
    778                                  (TX_ABORT_DIS_def_c << XCVR_TSM_CTRL_TX_ABORT_DIS_SHIFT) |
    779                                  (DATA_PADDING_EN_def_c << XCVR_TSM_CTRL_DATA_PADDING_EN_SHIFT) |
    780                                  (PA_RAMP_SEL_def_c << XCVR_TSM_CTRL_PA_RAMP_SEL_SHIFT) |
    781                                  (FORCE_RX_EN_def_c  << XCVR_TSM_CTRL_FORCE_RX_EN_SHIFT) |
    782                                  (FORCE_TX_EN_def_c  << XCVR_TSM_CTRL_FORCE_TX_EN_SHIFT)
    783                                 ));                       
    784              
    785              /* Perform mode specific portion of TSM setup using mode switch routine */
    786              XcvrSetTsmDef_ModeSwitch(radioMode);
    787              
    788              /* Only init OVRD registers if a non-default setting is needed */  
    789              /*PA_POWER*/
    790              XCVR_BWR_PA_POWER_PA_POWER(XCVR, PA_POWER_def_c);  
    791              
    792              /*PA_BIAS_TBL0*/
    793              XCVR_PA_BIAS_TBL0 = (uint32_t)((XCVR_PA_BIAS_TBL0 & (uint32_t)~(uint32_t)(    
    794                                  XCVR_PA_BIAS_TBL0_PA_BIAS3_MASK | 
    795                                  XCVR_PA_BIAS_TBL0_PA_BIAS2_MASK |
    796                                  XCVR_PA_BIAS_TBL0_PA_BIAS1_MASK |
    797                                  XCVR_PA_BIAS_TBL0_PA_BIAS0_MASK
    798                                 )) | (uint32_t)(
    799                                  (gPABiasTbl[3] << XCVR_PA_BIAS_TBL0_PA_BIAS3_SHIFT) |
    800                                  (gPABiasTbl[2] << XCVR_PA_BIAS_TBL0_PA_BIAS2_SHIFT) |
    801                                  (gPABiasTbl[1] << XCVR_PA_BIAS_TBL0_PA_BIAS1_SHIFT) |
    802                                  (gPABiasTbl[0] << XCVR_PA_BIAS_TBL0_PA_BIAS0_SHIFT)
    803                                 ));    
    804          
    805              /*PA_BIAS_TBL1*/
    806              XCVR_PA_BIAS_TBL1 = (uint32_t)((XCVR_PA_BIAS_TBL1 & (uint32_t)~(uint32_t)(    
    807                                  XCVR_PA_BIAS_TBL1_PA_BIAS7_MASK | 
    808                                  XCVR_PA_BIAS_TBL1_PA_BIAS6_MASK |
    809                                  XCVR_PA_BIAS_TBL1_PA_BIAS5_MASK |
    810                                  XCVR_PA_BIAS_TBL1_PA_BIAS4_MASK
    811                                 )) | (uint32_t)(
    812                                  (gPABiasTbl[7] << XCVR_PA_BIAS_TBL1_PA_BIAS7_SHIFT) |
    813                                  (gPABiasTbl[6] << XCVR_PA_BIAS_TBL1_PA_BIAS6_SHIFT) |
    814                                  (gPABiasTbl[5] << XCVR_PA_BIAS_TBL1_PA_BIAS5_SHIFT) |
    815                                  (gPABiasTbl[4] << XCVR_PA_BIAS_TBL1_PA_BIAS4_SHIFT)
    816                                 ));  
    817          }
    818          
    819          /*! *********************************************************************************
    820          * \brief  This function sets the radio mode specific default vaues of the TSM registers.
    821          *
    822          * \param[in] radioMode Radio mode is used to enable mode specific settings.
    823          *
    824          * \ingroup PrivateAPIs
    825          *
    826          * \details This function also sets link layer registers to account for TX and
    827          *       delays. 
    828          *
    829          ***********************************************************************************/
    830          void XcvrSetTsmDef_ModeSwitch ( radio_mode_t radioMode )
    831          {
    832              /* Setup TSM timing registers and LL timing registers at the same time */
    833              switch (radioMode)
    834              {
    835              case BLE:
    836                  tsm_ll_timing_init(BLE_RADIO);
    837                  break;
    838              case ZIGBEE:
    839                  tsm_ll_timing_init(ZIGBEE_RADIO);
    840                  break;
    841              default:
    842                  break;
    843              }
    844          }
    845          
    846          /*! *********************************************************************************
    847          * \brief  This function sets the default vaues of the RX DIG registers.
    848          *
    849          * \param[in] filt_coeff_ptr pointer to an array of 8 UINT8_T receive filter coefficients.
    850          * \param[in] iir3a_idx value of the 3rd IIR index
    851          * \param[in] iir2a_idx value of the 2nd IIR index
    852          * \param[in] iir1a_idx value of the 1st IIR index
    853          *
    854          * \ingroup PrivateAPIs
    855          *
    856          * \details Sets up RX digital registers with command and mode specific settings.
    857          *
    858          * \note Only uses read-modify-write when only part of the register is being written.
    859          *
    860          ***********************************************************************************/
    861          void XcvrSetRxDigDefaults (  const uint8_t * filt_coeff_ptr, uint8_t iir3a_idx, uint8_t iir2a_idx, uint8_t iir1a_idx, uint8_t rssi_hold_src )
    862          {
    863              /* Program RSSI registers */
    864              /* RSSI_CTRL_0 */
    865              XCVR_RSSI_CTRL_0 = (uint32_t)((XCVR_RSSI_CTRL_0 & (uint32_t)~(uint32_t)(
    866                                     XCVR_RSSI_CTRL_0_RSSI_USE_VALS_MASK |
    867                                     XCVR_RSSI_CTRL_0_RSSI_HOLD_EN_MASK |
    868                                     XCVR_RSSI_CTRL_0_RSSI_DEC_EN_MASK |
    869                                     XCVR_RSSI_CTRL_0_RSSI_IIR_WEIGHT_MASK |
    870                                     XCVR_RSSI_CTRL_0_RSSI_IIR_CW_WEIGHT_MASK |
    871                                     XCVR_RSSI_CTRL_0_RSSI_ADJ_MASK
    872                                    )) | (uint32_t)(
    873                                     (RSSI_USE_VALS_def_c << XCVR_RSSI_CTRL_0_RSSI_USE_VALS_SHIFT) |
    874                                     (RSSI_HOLD_EN_def_c << XCVR_RSSI_CTRL_0_RSSI_HOLD_EN_SHIFT) |
    875                                     (RSSI_DEC_EN_def_c << XCVR_RSSI_CTRL_0_RSSI_DEC_EN_SHIFT) |
    876                                     (RSSI_IIR_WEIGHT_def_c << XCVR_RSSI_CTRL_0_RSSI_IIR_WEIGHT_SHIFT) |
    877                                     (RSSI_IIR_CW_WEIGHT_BYPASSEDdef_c << XCVR_RSSI_CTRL_0_RSSI_IIR_CW_WEIGHT_SHIFT) |
    878                                     (RSSI_ADJ_def_c << XCVR_RSSI_CTRL_0_RSSI_ADJ_SHIFT)
    879                                    ));
    880              
    881              /* RSSI_CTRL_1 */
    882              XCVR_RSSI_CTRL_1 = (uint32_t)((XCVR_RSSI_CTRL_1 & (uint32_t)~(uint32_t)(
    883                                     XCVR_RSSI_CTRL_1_RSSI_ED_THRESH1_H_MASK |
    884                                     XCVR_RSSI_CTRL_1_RSSI_ED_THRESH0_H_MASK |
    885                                     XCVR_RSSI_CTRL_1_RSSI_ED_THRESH1_MASK |
    886                                     XCVR_RSSI_CTRL_1_RSSI_ED_THRESH0_MASK 
    887                                    )) | (uint32_t)(
    888                                     (RSSI_ED_THRESH1_H_def_c << XCVR_RSSI_CTRL_1_RSSI_ED_THRESH1_H_SHIFT) |
    889                                     (RSSI_ED_THRESH0_H_def_c << XCVR_RSSI_CTRL_1_RSSI_ED_THRESH0_H_SHIFT) |
    890                                     (RSSI_ED_THRESH1_def_c << XCVR_RSSI_CTRL_1_RSSI_ED_THRESH1_SHIFT) |
    891                                     (RSSI_ED_THRESH0_def_c << XCVR_RSSI_CTRL_1_RSSI_ED_THRESH0_SHIFT) 
    892                                    ));
    893                  
    894              /* Program AGC registers */
    895              /* AGC_CTRL_0 */
    896              XCVR_AGC_CTRL_0 = (uint32_t)((XCVR_AGC_CTRL_0 & (uint32_t)~(uint32_t)(
    897                                     XCVR_AGC_CTRL_0_AGC_DOWN_RSSI_THRESH_MASK |
    898                                     XCVR_AGC_CTRL_0_AGC_UP_RSSI_THRESH_MASK |
    899                                     XCVR_AGC_CTRL_0_AGC_DOWN_BBF_STEP_SZ_MASK |
    900                                     XCVR_AGC_CTRL_0_AGC_DOWN_TZA_STEP_SZ_MASK |
    901                                     XCVR_AGC_CTRL_0_AGC_UP_SRC_MASK |
    902                                     XCVR_AGC_CTRL_0_AGC_UP_EN_MASK |
    903                                     XCVR_AGC_CTRL_0_FREEZE_AGC_SRC_MASK |
    904                                     XCVR_AGC_CTRL_0_AGC_FREEZE_EN_MASK |
    905                                     XCVR_AGC_CTRL_0_SLOW_AGC_SRC_MASK |
    906                                     XCVR_AGC_CTRL_0_SLOW_AGC_EN_MASK 
    907                                    )) | (uint32_t)(
    908                                     (AGC_DOWN_RSSI_THRESH_def_c << XCVR_AGC_CTRL_0_AGC_DOWN_RSSI_THRESH_SHIFT) |
    909                                     (AGC_UP_RSSI_THRESH_def_c << XCVR_AGC_CTRL_0_AGC_UP_RSSI_THRESH_SHIFT) |
    910                                     (AGC_DOWN_BBF_STEP_SZ_def_c << XCVR_AGC_CTRL_0_AGC_DOWN_BBF_STEP_SZ_SHIFT) |
    911                                     (AGC_DOWN_TZA_STEP_SZ_def_c << XCVR_AGC_CTRL_0_AGC_DOWN_TZA_STEP_SZ_SHIFT) |
    912                                     (AGC_UP_SRC_def_c << XCVR_AGC_CTRL_0_AGC_UP_SRC_SHIFT) |
    913                                     (AGC_UP_EN_def_c << XCVR_AGC_CTRL_0_AGC_UP_EN_SHIFT) |
    914                                     (FREEZE_AGC_SRC_def_c << XCVR_AGC_CTRL_0_FREEZE_AGC_SRC_SHIFT) |
    915                                     (AGC_FREEZE_EN_def_c << XCVR_AGC_CTRL_0_AGC_FREEZE_EN_SHIFT) |
    916                                     (SLOW_AGC_SRC_def_c << XCVR_AGC_CTRL_0_SLOW_AGC_SRC_SHIFT) |
    917                                     (SLOW_AGC_EN_def_c << XCVR_AGC_CTRL_0_SLOW_AGC_EN_SHIFT)
    918                                    ));
    919              
    920              /* AGC_CTRL_1 */
    921              XCVR_AGC_CTRL_1 = (uint32_t)((XCVR_AGC_CTRL_1 & (uint32_t)~(uint32_t)(
    922                                     XCVR_AGC_CTRL_1_TZA_GAIN_SETTLE_TIME_MASK |
    923                                     XCVR_AGC_CTRL_1_PRESLOW_EN_MASK |
    924                                     XCVR_AGC_CTRL_1_USER_BBF_GAIN_EN_MASK |                             
    925                                     XCVR_AGC_CTRL_1_USER_LNM_GAIN_EN_MASK |                             
    926                                     XCVR_AGC_CTRL_1_BBF_USER_GAIN_MASK |                             
    927                                     XCVR_AGC_CTRL_1_LNM_USER_GAIN_MASK |                             
    928                                     XCVR_AGC_CTRL_1_LNM_ALT_CODE_MASK |
    929                                     XCVR_AGC_CTRL_1_BBF_ALT_CODE_MASK                                                           
    930                                    )) | (uint32_t)(
    931                                     (TZA_GAIN_SETTLE_TIME_def_c << XCVR_AGC_CTRL_1_TZA_GAIN_SETTLE_TIME_SHIFT) |
    932                                     (PRESLOW_EN_def_c << XCVR_AGC_CTRL_1_PRESLOW_EN_SHIFT) |
    933                                     (USER_BBF_GAIN_EN_def_c << XCVR_AGC_CTRL_1_USER_BBF_GAIN_EN_SHIFT) |
    934                                     (USER_LNM_GAIN_EN_def_c << XCVR_AGC_CTRL_1_USER_LNM_GAIN_EN_SHIFT) |
    935                                     (BBF_USER_GAIN_def_c << XCVR_AGC_CTRL_1_BBF_USER_GAIN_SHIFT) |
    936                                     (LNM_USER_GAIN_def_c << XCVR_AGC_CTRL_1_LNM_USER_GAIN_SHIFT) |
    937                                     (LNM_ALT_CODE_def_c << XCVR_AGC_CTRL_1_LNM_ALT_CODE_SHIFT) |
    938                                     (BBF_ALT_CODE_def_c << XCVR_AGC_CTRL_1_BBF_ALT_CODE_SHIFT)
    939                                    ));
    940              
    941              /* AGC_CTRL_2 */
    942              XCVR_AGC_CTRL_2 = (uint32_t)((XCVR_AGC_CTRL_2 & (uint32_t)~(uint32_t)(
    943                                     XCVR_AGC_CTRL_2_AGC_FAST_EXPIRE_MASK |
    944                                     XCVR_AGC_CTRL_2_TZA_PDET_THRESH_HI_MASK |
    945                                     XCVR_AGC_CTRL_2_TZA_PDET_THRESH_LO_MASK |
    946                                     XCVR_AGC_CTRL_2_BBF_PDET_THRESH_HI_MASK |
    947                                     XCVR_AGC_CTRL_2_BBF_PDET_THRESH_LO_MASK |
    948                                     XCVR_AGC_CTRL_2_BBF_GAIN_SETTLE_TIME_MASK
    949                                    )) | (uint32_t)(
    950                                     (AGC_FAST_EXPIRE_def_c << XCVR_AGC_CTRL_2_AGC_FAST_EXPIRE_SHIFT) |
    951                                     (TZA_PDET_THRESH_HI_def_c << XCVR_AGC_CTRL_2_TZA_PDET_THRESH_HI_SHIFT) |
    952                                     (TZA_PDET_THRESH_LO_def_c << XCVR_AGC_CTRL_2_TZA_PDET_THRESH_LO_SHIFT) |
    953                                     (BBF_PDET_THRESH_HI_def_c << XCVR_AGC_CTRL_2_BBF_PDET_THRESH_HI_SHIFT) |
    954                                     (BBF_PDET_THRESH_LO_def_c << XCVR_AGC_CTRL_2_BBF_PDET_THRESH_LO_SHIFT) |
    955                                     (BBF_GAIN_SETTLE_TIME_def_c << XCVR_AGC_CTRL_2_BBF_GAIN_SETTLE_TIME_SHIFT)
    956                                    ));
    957              
    958              /* AGC_CTRL_3 */
    959              XCVR_AGC_CTRL_3 = (uint32_t)((XCVR_AGC_CTRL_3 & (uint32_t)~(uint32_t)(
    960                                     XCVR_AGC_CTRL_3_AGC_UP_STEP_SZ_MASK |
    961                                     XCVR_AGC_CTRL_3_AGC_H2S_STEP_SZ_MASK |
    962                                     XCVR_AGC_CTRL_3_AGC_RSSI_DELT_H2S_MASK |
    963                                     XCVR_AGC_CTRL_3_AGC_PDET_LO_DLY_MASK |
    964                                     XCVR_AGC_CTRL_3_AGC_UNFREEZE_TIME_MASK
    965                                    )) | (uint32_t)(
    966                                     (AGC_UP_STEP_SZ_def_c << XCVR_AGC_CTRL_3_AGC_UP_STEP_SZ_SHIFT) |
    967                                     (AGC_H2S_STEP_SZ_def_c << XCVR_AGC_CTRL_3_AGC_H2S_STEP_SZ_SHIFT) |
    968                                     (AGC_RSSI_DELT_H2S_def_c << XCVR_AGC_CTRL_3_AGC_RSSI_DELT_H2S_SHIFT) |
    969                                     (AGC_PDET_LO_DLY_def_c << XCVR_AGC_CTRL_3_AGC_PDET_LO_DLY_SHIFT) |
    970                                     (AGC_UNFREEZE_TIME_def_c << XCVR_AGC_CTRL_3_AGC_UNFREEZE_TIME_SHIFT)
    971                                    ));
    972              
    973              /* AGC_GAIN_TBL*** registers */
    974              XCVR_AGC_GAIN_TBL_03_00 = (uint32_t)(
    975                                     (BBF_GAIN_00_def_c << XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_00_SHIFT) |
    976                                     (LNM_GAIN_00_def_c << XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_00_SHIFT) |
    977                                     (BBF_GAIN_01_def_c << XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_01_SHIFT) |
    978                                     (LNM_GAIN_01_def_c << XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_01_SHIFT) |
    979                                     (BBF_GAIN_02_def_c << XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_02_SHIFT) |
    980                                     (LNM_GAIN_02_def_c << XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_02_SHIFT) |
    981                                     (BBF_GAIN_03_def_c << XCVR_AGC_GAIN_TBL_03_00_BBF_GAIN_03_SHIFT) |
    982                                     (LNM_GAIN_03_def_c << XCVR_AGC_GAIN_TBL_03_00_LNM_GAIN_03_SHIFT) 
    983                                    );
    984              
    985              XCVR_AGC_GAIN_TBL_07_04 = (uint32_t)(
    986                                     (BBF_GAIN_04_def_c << XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_04_SHIFT) |
    987                                     (LNM_GAIN_04_def_c << XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_04_SHIFT) |
    988                                     (BBF_GAIN_05_def_c << XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_05_SHIFT) |
    989                                     (LNM_GAIN_05_def_c << XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_05_SHIFT) |
    990                                     (BBF_GAIN_06_def_c << XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_06_SHIFT) |
    991                                     (LNM_GAIN_06_def_c << XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_06_SHIFT) |
    992                                     (BBF_GAIN_07_def_c << XCVR_AGC_GAIN_TBL_07_04_BBF_GAIN_07_SHIFT) |
    993                                     (LNM_GAIN_07_def_c << XCVR_AGC_GAIN_TBL_07_04_LNM_GAIN_07_SHIFT) 
    994                                    );
    995              
    996              XCVR_AGC_GAIN_TBL_11_08 = (uint32_t)(
    997                                     (BBF_GAIN_08_def_c << XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_08_SHIFT) |
    998                                     (LNM_GAIN_08_def_c << XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_08_SHIFT) |
    999                                     (BBF_GAIN_09_def_c << XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_09_SHIFT) |
   1000                                     (LNM_GAIN_09_def_c << XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_09_SHIFT) |
   1001                                     (BBF_GAIN_10_def_c << XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_10_SHIFT) |
   1002                                     (LNM_GAIN_10_def_c << XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_10_SHIFT) |
   1003                                     (BBF_GAIN_11_def_c << XCVR_AGC_GAIN_TBL_11_08_BBF_GAIN_11_SHIFT) |
   1004                                     (LNM_GAIN_11_def_c << XCVR_AGC_GAIN_TBL_11_08_LNM_GAIN_11_SHIFT) 
   1005                                    );
   1006              
   1007              XCVR_AGC_GAIN_TBL_15_12 =  (uint32_t)(
   1008                                     (BBF_GAIN_12_def_c << XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_12_SHIFT) |
   1009                                     (LNM_GAIN_12_def_c << XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_12_SHIFT) |
   1010                                     (BBF_GAIN_13_def_c << XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_13_SHIFT) |
   1011                                     (LNM_GAIN_13_def_c << XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_13_SHIFT) |
   1012                                     (BBF_GAIN_14_def_c << XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_14_SHIFT) |
   1013                                     (LNM_GAIN_14_def_c << XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_14_SHIFT) |
   1014                                     (BBF_GAIN_15_def_c << XCVR_AGC_GAIN_TBL_15_12_BBF_GAIN_15_SHIFT) |
   1015                                     (LNM_GAIN_15_def_c << XCVR_AGC_GAIN_TBL_15_12_LNM_GAIN_15_SHIFT) 
   1016                                    );
   1017              
   1018              XCVR_AGC_GAIN_TBL_19_16 = (uint32_t)(
   1019                                     (BBF_GAIN_16_def_c << XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_16_SHIFT) |
   1020                                     (LNM_GAIN_16_def_c << XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_16_SHIFT) |
   1021                                     (BBF_GAIN_17_def_c << XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_17_SHIFT) |
   1022                                     (LNM_GAIN_17_def_c << XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_17_SHIFT) |
   1023                                     (BBF_GAIN_18_def_c << XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_18_SHIFT) |
   1024                                     (LNM_GAIN_18_def_c << XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_18_SHIFT) |
   1025                                     (BBF_GAIN_19_def_c << XCVR_AGC_GAIN_TBL_19_16_BBF_GAIN_19_SHIFT) |
   1026                                     (LNM_GAIN_19_def_c << XCVR_AGC_GAIN_TBL_19_16_LNM_GAIN_19_SHIFT) 
   1027                                    );
   1028              
   1029              XCVR_AGC_GAIN_TBL_23_20 = (uint32_t)(
   1030                                     (BBF_GAIN_20_def_c << XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_20_SHIFT) |
   1031                                     (LNM_GAIN_20_def_c << XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_20_SHIFT) |
   1032                                     (BBF_GAIN_21_def_c << XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_21_SHIFT) |
   1033                                     (LNM_GAIN_21_def_c << XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_21_SHIFT) |
   1034                                     (BBF_GAIN_22_def_c << XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_22_SHIFT) |
   1035                                     (LNM_GAIN_22_def_c << XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_22_SHIFT) |
   1036                                     (BBF_GAIN_23_def_c << XCVR_AGC_GAIN_TBL_23_20_BBF_GAIN_23_SHIFT) |
   1037                                     (LNM_GAIN_23_def_c << XCVR_AGC_GAIN_TBL_23_20_LNM_GAIN_23_SHIFT) 
   1038                                    );
   1039              
   1040              XCVR_AGC_GAIN_TBL_26_24 = (uint32_t)(
   1041                                     (BBF_GAIN_24_def_c << XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_24_SHIFT) |
   1042                                     (LNM_GAIN_24_def_c << XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_24_SHIFT) |
   1043                                     (BBF_GAIN_25_def_c << XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_25_SHIFT) |
   1044                                     (LNM_GAIN_25_def_c << XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_25_SHIFT) |
   1045                                     (BBF_GAIN_26_def_c << XCVR_AGC_GAIN_TBL_26_24_BBF_GAIN_26_SHIFT) |
   1046                                     (LNM_GAIN_26_def_c << XCVR_AGC_GAIN_TBL_26_24_LNM_GAIN_26_SHIFT) 
   1047                                    );
   1048              
   1049              XCVR_TCA_AGC_VAL_3_0 = (uint32_t)(
   1050                                     (TCA_AGC_VAL_3_def_c<< XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_3_SHIFT) |
   1051                                     (TCA_AGC_VAL_2_def_c<< XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_2_SHIFT) |
   1052                                     (TCA_AGC_VAL_1_def_c<< XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_1_SHIFT) |
   1053                                     (TCA_AGC_VAL_0_def_c<< XCVR_TCA_AGC_VAL_3_0_TCA_AGC_VAL_0_SHIFT) 
   1054                                    );
   1055              
   1056              XCVR_TCA_AGC_VAL_7_4 = (uint32_t)(
   1057                                     (TCA_AGC_VAL_7_def_c<< XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_7_SHIFT) |
   1058                                     (TCA_AGC_VAL_6_def_c<< XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_6_SHIFT) |
   1059                                     (TCA_AGC_VAL_5_def_c<< XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_5_SHIFT) |
   1060                                     (TCA_AGC_VAL_4_def_c<< XCVR_TCA_AGC_VAL_7_4_TCA_AGC_VAL_4_SHIFT) 
   1061                                    );
   1062              
   1063              XCVR_TCA_AGC_VAL_8 = (uint32_t)(
   1064                                     (TCA_AGC_VAL_8_def_c<< XCVR_TCA_AGC_VAL_8_TCA_AGC_VAL_8_SHIFT) 
   1065                                    );
   1066              
   1067              XCVR_BBF_RES_TUNE_VAL_7_0 = (uint32_t)(
   1068                                     (BBF_RES_TUNE_VAL_7_def_c<< XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_7_SHIFT) |
   1069                                     (BBF_RES_TUNE_VAL_6_def_c<< XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_6_SHIFT) |
   1070                                     (BBF_RES_TUNE_VAL_5_def_c<< XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_5_SHIFT) |
   1071                                     (BBF_RES_TUNE_VAL_4_def_c<< XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_4_SHIFT) |
   1072                                     (BBF_RES_TUNE_VAL_3_def_c<< XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_3_SHIFT) |
   1073                                     (BBF_RES_TUNE_VAL_2_def_c<< XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_2_SHIFT) |
   1074                                     (BBF_RES_TUNE_VAL_1_def_c<< XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_1_SHIFT) |
   1075                                     (BBF_RES_TUNE_VAL_0_def_c<< XCVR_BBF_RES_TUNE_VAL_7_0_BBF_RES_TUNE_VAL_0_SHIFT) 
   1076                                    );
   1077            
   1078              XCVR_BBF_RES_TUNE_VAL_10_8 = (uint32_t)(
   1079                                     (BBF_RES_TUNE_VAL_10_def_c<< XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_10_SHIFT) |
   1080                                     (BBF_RES_TUNE_VAL_9_def_c<< XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_9_SHIFT) |
   1081                                     (BBF_RES_TUNE_VAL_8_def_c<< XCVR_BBF_RES_TUNE_VAL_10_8_BBF_RES_TUNE_VAL_8_SHIFT) 
   1082                                    );
   1083              
   1084              /* Program DCOC registers */
   1085              XcvrCalcSetupDcoc();
   1086              
   1087              /* Use mode switch routine to setup the defaults that depend on radio mode */
   1088              XcvrSetRxDigDef_ModeSwitch(filt_coeff_ptr, iir3a_idx, iir2a_idx, iir1a_idx, rssi_hold_src);
   1089          }
   1090          
   1091          /*! *********************************************************************************
   1092          * \brief  This function sets the radio mode dependent default values of the RX DIG registers.
   1093          *
   1094          * \param[in] in_filt_coeff_ptr pointer to an array of 8 UINT8_T receive filter coefficients.
   1095          * \param[in] iir3a_idx value of the 3rd IIR index
   1096          * \param[in] iir2a_idx value of the 2nd IIR index
   1097          * \param[in] iir1a_idx value of the 1st IIR index
   1098          *
   1099          * \ingroup PrivateAPIs
   1100          *
   1101          * \details Sets up RX digital registers with command and mode specific settings.
   1102          *
   1103          * \note Only uses read-modify-write when only part of the register is being written.
   1104          *
   1105          **********************************************************************************/
   1106          void XcvrSetRxDigDef_ModeSwitch (  const uint8_t * in_filt_coeff_ptr, uint8_t iir3a_idx, uint8_t iir2a_idx, uint8_t iir1a_idx, uint8_t rssi_hold_src )
   1107          {
   1108              uint8_t * filt_coeff_ptr = (uint8_t *)in_filt_coeff_ptr;
   1109              
   1110              /*RX_CHF_COEFn*/
   1111              XCVR_RX_CHF_COEF0 = *filt_coeff_ptr++;
   1112              XCVR_RX_CHF_COEF1 = *filt_coeff_ptr++;
   1113              XCVR_RX_CHF_COEF2 = *filt_coeff_ptr++;
   1114              XCVR_RX_CHF_COEF3 = *filt_coeff_ptr++;
   1115              XCVR_RX_CHF_COEF4 = *filt_coeff_ptr++;
   1116              XCVR_RX_CHF_COEF5 = *filt_coeff_ptr++;
   1117              XCVR_RX_CHF_COEF6 = *filt_coeff_ptr++;
   1118              XCVR_RX_CHF_COEF7 = *filt_coeff_ptr;    
   1119              
   1120              /* DCOC_CAL_IIR */
   1121              XCVR_DCOC_CAL_IIR = (uint32_t)((XCVR_DCOC_CAL_IIR & (uint32_t)~(uint32_t)(
   1122                                   XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR1A_IDX_MASK |
   1123                                   XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR2A_IDX_MASK |
   1124                                   XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR3A_IDX_MASK 
   1125                                  )) | (uint32_t)(
   1126                                   (iir1a_idx << XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR1A_IDX_SHIFT) |
   1127                                   (iir2a_idx << XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR2A_IDX_SHIFT) |
   1128                                   (iir3a_idx << XCVR_DCOC_CAL_IIR_DCOC_CAL_IIR3A_IDX_SHIFT) 
   1129                                  ));    
   1130            
   1131              XCVR_BWR_RSSI_CTRL_0_RSSI_HOLD_SRC(XCVR, rssi_hold_src);
   1132          }
   1133          
   1134          /*! *********************************************************************************
   1135          * \brief  This function programs a set of DCOC registers either from raw values
   1136          *    or from calculated (equations) values.
   1137          *
   1138          * \return Status of the operation.
   1139          *
   1140          * \ingroup PrivateAPIs
   1141          *
   1142          * \details
   1143          *
   1144          ***********************************************************************************/
   1145          xcvrStatus_t XcvrCalcSetupDcoc ( void )
   1146          {
   1147          #if !USE_DCOC_MAGIC_NUMBERS 
   1148              
   1149              /* Define variables to replace all of the #defined constants which are used
   1150               * below and which are defined in BLEDefaults.h for the case where
   1151               * USE_DCOC_MAGIC_NUMBERS == 1 
   1152               */
   1153              
   1154              /* DCOC_CAL_RCP */
   1155          #define ALPHA_CALC_RECIP_def_c 0x00
   1156          #define TMP_CALC_RECIP_def_c   0x00
   1157              
   1158              /* TCA_AGC_LIN_VAL_2_0 */
   1159              uint16_t TCA_AGC_LIN_VAL_0_def_c;
   1160              uint16_t TCA_AGC_LIN_VAL_1_def_c;
   1161              uint16_t TCA_AGC_LIN_VAL_2_def_c;
   1162              
   1163              /* TCA_AGC_LIN_VAL_5_3 */
   1164              uint16_t TCA_AGC_LIN_VAL_3_def_c;
   1165              uint16_t TCA_AGC_LIN_VAL_4_def_c;
   1166              uint16_t TCA_AGC_LIN_VAL_5_def_c;
   1167              
   1168              /* TCA_AGC_LIN_VAL_8_6 */
   1169              uint16_t TCA_AGC_LIN_VAL_6_def_c;
   1170              uint16_t TCA_AGC_LIN_VAL_7_def_c;
   1171              uint16_t TCA_AGC_LIN_VAL_8_def_c;
   1172              
   1173              /* BBF_RES_TUNE_LIN_VAL_3_0 */
   1174              uint8_t BBF_RES_TUNE_LIN_VAL_0_def_c;
   1175              uint8_t BBF_RES_TUNE_LIN_VAL_1_def_c;
   1176              uint8_t BBF_RES_TUNE_LIN_VAL_2_def_c;
   1177              uint8_t BBF_RES_TUNE_LIN_VAL_3_def_c;
   1178              
   1179              /* BBF_RES_TUNE_LIN_VAL_7_4 */
   1180              uint8_t BBF_RES_TUNE_LIN_VAL_4_def_c;
   1181              uint8_t BBF_RES_TUNE_LIN_VAL_5_def_c;
   1182              uint8_t BBF_RES_TUNE_LIN_VAL_6_def_c;
   1183              uint8_t BBF_RES_TUNE_LIN_VAL_7_def_c;
   1184              
   1185              /* BBF_RES_TUNE_LIN_VAL_10_8 */
   1186              uint8_t BBF_RES_TUNE_LIN_VAL_8_def_c;
   1187              uint8_t BBF_RES_TUNE_LIN_VAL_9_def_c;
   1188              uint8_t BBF_RES_TUNE_LIN_VAL_10_def_c;
   1189              
   1190              /* DCOC_TZA_STEP */
   1191              uint16_t DCOC_TZA_STEP_GAIN_00_def_c;
   1192              uint16_t DCOC_TZA_STEP_RCP_00_def_c;
   1193              uint16_t DCOC_TZA_STEP_GAIN_01_def_c;
   1194              uint16_t DCOC_TZA_STEP_RCP_01_def_c;
   1195              uint16_t DCOC_TZA_STEP_GAIN_02_def_c;
   1196              uint16_t DCOC_TZA_STEP_RCP_02_def_c;
   1197              uint16_t DCOC_TZA_STEP_GAIN_03_def_c;
   1198              uint16_t DCOC_TZA_STEP_RCP_03_def_c;
   1199              uint16_t DCOC_TZA_STEP_GAIN_04_def_c;
   1200              uint16_t DCOC_TZA_STEP_RCP_04_def_c;
   1201              uint16_t DCOC_TZA_STEP_GAIN_05_def_c;
   1202              uint16_t DCOC_TZA_STEP_RCP_05_def_c;
   1203              uint16_t DCOC_TZA_STEP_GAIN_06_def_c;
   1204              uint16_t DCOC_TZA_STEP_RCP_06_def_c;
   1205              uint16_t DCOC_TZA_STEP_GAIN_07_def_c;
   1206              uint16_t DCOC_TZA_STEP_RCP_07_def_c;
   1207              uint16_t DCOC_TZA_STEP_GAIN_08_def_c;
   1208              uint16_t DCOC_TZA_STEP_RCP_08_def_c;
   1209              uint16_t DCOC_TZA_STEP_GAIN_09_def_c;
   1210              uint16_t DCOC_TZA_STEP_RCP_09_def_c;
   1211              uint16_t DCOC_TZA_STEP_GAIN_10_def_c;
   1212              uint16_t DCOC_TZA_STEP_RCP_10_def_c;
   1213              
   1214              /* DCOC_CTRL_1 DCOC_CTRL_2 */
   1215              uint16_t BBF_STEP_def_c;
   1216              uint16_t BBF_STEP_RECIP_def_c;
   1217              
   1218              /* DCOC_CAL_RCP */
   1219              uint16_t RCP_GLHmGLLxGBL_def_c;
   1220              uint16_t RCP_GBHmGBL_def_c;
   1221              
   1222              /* Equations to calculate these values */
   1223              TCA_AGC_LIN_VAL_0_def_c = (uint16_t)round(0x4*DB_TO_LINEAR(TCA_GAIN_DB_0_def_c));
   1224              TCA_AGC_LIN_VAL_1_def_c = (uint16_t)round(0x4*DB_TO_LINEAR(TCA_GAIN_DB_1_def_c));
   1225              TCA_AGC_LIN_VAL_2_def_c = (uint16_t)round(0x4*DB_TO_LINEAR(TCA_GAIN_DB_2_def_c));
   1226              
   1227              TCA_AGC_LIN_VAL_3_def_c = (uint16_t)round(0x4*DB_TO_LINEAR(TCA_GAIN_DB_3_def_c));
   1228              TCA_AGC_LIN_VAL_4_def_c = (uint16_t)round(0x4*DB_TO_LINEAR(TCA_GAIN_DB_4_def_c));
   1229              TCA_AGC_LIN_VAL_5_def_c = (uint16_t)round(0x4*DB_TO_LINEAR(TCA_GAIN_DB_5_def_c));
   1230              
   1231              TCA_AGC_LIN_VAL_6_def_c = (uint16_t)round(0x4*DB_TO_LINEAR(TCA_GAIN_DB_6_def_c));
   1232              TCA_AGC_LIN_VAL_7_def_c = (uint16_t)round(0x4*DB_TO_LINEAR(TCA_GAIN_DB_7_def_c));
   1233              TCA_AGC_LIN_VAL_8_def_c = (uint16_t)round(0x4*DB_TO_LINEAR(TCA_GAIN_DB_8_def_c));
   1234              
   1235              BBF_RES_TUNE_LIN_VAL_0_def_c = (uint8_t)round(0x8*DB_TO_LINEAR(BBF_GAIN_DB_0_def_c));
   1236              BBF_RES_TUNE_LIN_VAL_1_def_c = (uint8_t)round(0x8*DB_TO_LINEAR(BBF_GAIN_DB_1_def_c));
   1237              BBF_RES_TUNE_LIN_VAL_2_def_c = (uint8_t)round(0x8*DB_TO_LINEAR(BBF_GAIN_DB_2_def_c));
   1238              BBF_RES_TUNE_LIN_VAL_3_def_c = (uint8_t)round(0x8*DB_TO_LINEAR(BBF_GAIN_DB_3_def_c));
   1239              
   1240              BBF_RES_TUNE_LIN_VAL_4_def_c = (uint8_t)round(0x8*DB_TO_LINEAR(BBF_GAIN_DB_4_def_c));
   1241              BBF_RES_TUNE_LIN_VAL_5_def_c = (uint8_t)round(0x8*DB_TO_LINEAR(BBF_GAIN_DB_5_def_c));
   1242              BBF_RES_TUNE_LIN_VAL_6_def_c = (uint8_t)round(0x8*DB_TO_LINEAR(BBF_GAIN_DB_6_def_c));
   1243              BBF_RES_TUNE_LIN_VAL_7_def_c = (uint8_t)round(0x8*DB_TO_LINEAR(BBF_GAIN_DB_7_def_c));
   1244              
   1245              BBF_RES_TUNE_LIN_VAL_8_def_c = (uint8_t)round(0x8*DB_TO_LINEAR(BBF_GAIN_DB_8_def_c));
   1246              BBF_RES_TUNE_LIN_VAL_9_def_c = (uint8_t)round(0x8*DB_TO_LINEAR(BBF_GAIN_DB_9_def_c));
   1247              
   1248              if ((0x8*DB_TO_LINEAR(BBF_GAIN_DB_10_def_c)) > 255)
   1249              {
   1250                  BBF_RES_TUNE_LIN_VAL_10_def_c = (uint8_t)(0xFF);
   1251              }
   1252              else
   1253              {
   1254                  BBF_RES_TUNE_LIN_VAL_10_def_c = (uint8_t)round(0x8*DB_TO_LINEAR(BBF_GAIN_DB_10_def_c));
   1255              }
   1256              
   1257              if (gen1_dcgain_trims_enabled)
   1258              {
   1259                  double temp_prd = TZA_DCOC_STEP_RAW * adc_gain_trimmed;
   1260                  DCOC_TZA_STEP_GAIN_00_def_c = (uint16_t)round(temp_prd * DB_TO_LINEAR(BBF_GAIN_DB_0_def_c) * 0x8);
   1261                  DCOC_TZA_STEP_RCP_00_def_c = (uint16_t)round((((double)(1.0))*(0x8000))/(temp_prd * DB_TO_LINEAR(BBF_GAIN_DB_0_def_c)));
   1262                  DCOC_TZA_STEP_GAIN_01_def_c = (uint16_t)round(temp_prd * DB_TO_LINEAR(BBF_GAIN_DB_1_def_c) * 0x8);
   1263                  DCOC_TZA_STEP_RCP_01_def_c = (uint16_t)round((((double)(1.0))*(0x8000))/(temp_prd * DB_TO_LINEAR(BBF_GAIN_DB_1_def_c)));
   1264                  DCOC_TZA_STEP_GAIN_02_def_c = (uint16_t)round(temp_prd * DB_TO_LINEAR(BBF_GAIN_DB_2_def_c) * 0x8);
   1265                  DCOC_TZA_STEP_RCP_02_def_c = (uint16_t)round((((double)(1.0))*(0x8000))/(temp_prd * DB_TO_LINEAR(BBF_GAIN_DB_2_def_c)));
   1266                  DCOC_TZA_STEP_GAIN_03_def_c = (uint16_t)round(temp_prd * DB_TO_LINEAR(BBF_GAIN_DB_3_def_c) * 0x8);
   1267                  DCOC_TZA_STEP_RCP_03_def_c = (uint16_t)round((((double)(1.0))*(0x8000))/(temp_prd * DB_TO_LINEAR(BBF_GAIN_DB_3_def_c)));
   1268                  DCOC_TZA_STEP_GAIN_04_def_c = (uint16_t)round(temp_prd * DB_TO_LINEAR(BBF_GAIN_DB_4_def_c) * 0x8);
   1269                  DCOC_TZA_STEP_RCP_04_def_c = (uint16_t)round((((double)(1.0))*(0x8000))/(temp_prd * DB_TO_LINEAR(BBF_GAIN_DB_4_def_c)));
   1270                  DCOC_TZA_STEP_GAIN_05_def_c = (uint16_t)round(temp_prd * DB_TO_LINEAR(BBF_GAIN_DB_5_def_c) * 0x8);
   1271                  DCOC_TZA_STEP_RCP_05_def_c = (uint16_t)round((((double)(1.0))*(0x8000))/(temp_prd * DB_TO_LINEAR(BBF_GAIN_DB_5_def_c)));
   1272                  DCOC_TZA_STEP_GAIN_06_def_c = (uint16_t)round(temp_prd * DB_TO_LINEAR(BBF_GAIN_DB_6_def_c) * 0x8);
   1273                  DCOC_TZA_STEP_RCP_06_def_c = (uint16_t)round((((double)(1.0))*(0x8000))/(temp_prd * DB_TO_LINEAR(BBF_GAIN_DB_6_def_c)));
   1274                  DCOC_TZA_STEP_GAIN_07_def_c = (uint16_t)round(temp_prd * DB_TO_LINEAR(BBF_GAIN_DB_7_def_c) * 0x8);
   1275                  DCOC_TZA_STEP_RCP_07_def_c = (uint16_t)round((((double)(1.0))*(0x8000))/(temp_prd * DB_TO_LINEAR(BBF_GAIN_DB_7_def_c)));
   1276                  DCOC_TZA_STEP_GAIN_08_def_c = (uint16_t)round(temp_prd * DB_TO_LINEAR(BBF_GAIN_DB_8_def_c) * 0x8);
   1277                  DCOC_TZA_STEP_RCP_08_def_c = (uint16_t)round((((double)(1.0))*(0x8000))/(temp_prd * DB_TO_LINEAR(BBF_GAIN_DB_8_def_c)));
   1278                  DCOC_TZA_STEP_GAIN_09_def_c = (uint16_t)round(temp_prd * DB_TO_LINEAR(BBF_GAIN_DB_9_def_c) * 0x8);
   1279                  DCOC_TZA_STEP_RCP_09_def_c = (uint16_t)round((((double)(1.0))*(0x8000))/(temp_prd * DB_TO_LINEAR(BBF_GAIN_DB_9_def_c)));
   1280                  DCOC_TZA_STEP_GAIN_10_def_c = (uint16_t)round(temp_prd * DB_TO_LINEAR(BBF_GAIN_DB_10_def_c) * 0x8);
   1281                  DCOC_TZA_STEP_RCP_10_def_c = (uint16_t)round((((double)(1.0))*(0x8000))/(temp_prd * DB_TO_LINEAR(BBF_GAIN_DB_10_def_c)));
   1282                  
   1283                  BBF_STEP_def_c = (uint16_t)round(BBF_DCOC_STEP_RAW * adc_gain_trimmed *0x8);
   1284                  BBF_STEP_RECIP_def_c = (uint16_t)round((((double)(1.0))*(0x8000))/(BBF_DCOC_STEP_RAW * adc_gain_trimmed));
   1285              }
   1286              
   1287              RCP_GLHmGLLxGBL_def_c = (uint16_t)(round(((double)(2048*1.0))/((DB_TO_LINEAR(TCA_GAIN_DB_8_def_c)-DB_TO_LINEAR(TCA_GAIN_DB_4_def_c))*DB_TO_LINEAR(BBF_GAIN_DB_4_def_c))));
   1288              RCP_GBHmGBL_def_c = (uint16_t)(round(((double)(1024*1.0))/((DB_TO_LINEAR(BBF_GAIN_DB_8_def_c)-DB_TO_LINEAR(BBF_GAIN_DB_4_def_c)))));
   1289              
   1290          #endif /* !USE_DCOC_MAGIC_NUMBERS */
   1291              
   1292              /* Write the registers with either the raw or calculated values.
   1293              * NOTE: Values will be either #define constants or local variables.
   1294              */
   1295              
   1296              /* Miscellaneous DCOC Tracking & GearShift Control Settings (Misc Registers) */
   1297              XCVR_ADC_TEST_CTRL = (uint32_t)((XCVR_ADC_TEST_CTRL & (uint32_t)~(uint32_t)(
   1298                                    XCVR_ADC_TEST_CTRL_DCOC_ALPHA_RADIUS_GS_IDX_MASK
   1299                                   )) | (uint32_t)(
   1300                                    (DCOC_ALPHA_RADIUS_GS_IDX_def_c << XCVR_ADC_TEST_CTRL_DCOC_ALPHA_RADIUS_GS_IDX_SHIFT)
   1301                                   ));
   1302              
   1303              XCVR_RX_ANA_CTRL = (uint32_t)((XCVR_RX_ANA_CTRL & (uint32_t)~(uint32_t)(
   1304                                    XCVR_RX_ANA_CTRL_IQMC_DC_GAIN_ADJ_EN_MASK
   1305                                   )) | (uint32_t)(
   1306                                    (IQMC_DC_GAIN_ADJ_EN_def_c << XCVR_RX_ANA_CTRL_IQMC_DC_GAIN_ADJ_EN_SHIFT)
   1307                                   ));
   1308              
   1309              XCVR_ANA_SPARE = (uint32_t)((XCVR_ANA_SPARE & (uint32_t)~(uint32_t)(
   1310                                    XCVR_ANA_SPARE_DCOC_TRK_EST_GS_CNT_MASK |
   1311                                    XCVR_ANA_SPARE_HPM_LSB_INVERT_MASK
   1312                                   )) | (uint32_t)(
   1313                                    (DCOC_TRK_EST_GS_CNT_def_c << XCVR_ANA_SPARE_DCOC_TRK_EST_GS_CNT_SHIFT) |
   1314                                    (HPM_LSB_INVERT_def_c << XCVR_ANA_SPARE_HPM_LSB_INVERT_SHIFT)
   1315                                   ));
   1316                
   1317              /* DCOC_CAL_GAIN */
   1318              XCVR_DCOC_CAL_GAIN = (uint32_t)((XCVR_DCOC_CAL_GAIN & (uint32_t)~(uint32_t)(
   1319                                    XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN1_MASK |
   1320                                    XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN1_MASK |
   1321                                    XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN2_MASK |
   1322                                    XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN2_MASK |
   1323                                    XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN3_MASK |
   1324                                    XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN3_MASK 
   1325                                   )) | (uint32_t)(
   1326                                    (DCOC_BBF_CAL_GAIN1_def_c << XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN1_SHIFT) |
   1327                                    (DCOC_TZA_CAL_GAIN1_def_c << XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN1_SHIFT) |
   1328                                    (DCOC_BBF_CAL_GAIN2_def_c << XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN2_SHIFT) |
   1329                                    (DCOC_TZA_CAL_GAIN2_def_c << XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN2_SHIFT) |
   1330                                    (DCOC_BBF_CAL_GAIN3_def_c << XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN3_SHIFT) |
   1331                                    (DCOC_TZA_CAL_GAIN3_def_c << XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN3_SHIFT) 
   1332                                   ));    
   1333            
   1334              /* DCOC_CALC_RCP */
   1335              XCVR_DCOC_CAL_RCP = (uint32_t)((XCVR_DCOC_CAL_RCP & (uint32_t)~(uint32_t)(
   1336                                    XCVR_DCOC_CAL_RCP_DCOC_TMP_CALC_RECIP_MASK |
   1337                                    XCVR_DCOC_CAL_RCP_ALPHA_CALC_RECIP_MASK 
   1338                                   )) | (uint32_t)(
   1339                                    (TMP_CALC_RECIP_def_c << XCVR_DCOC_CAL_RCP_DCOC_TMP_CALC_RECIP_SHIFT) |
   1340                                    (ALPHA_CALC_RECIP_def_c << XCVR_DCOC_CAL_RCP_ALPHA_CALC_RECIP_SHIFT) 
   1341                                   ));    
   1342          
   1343              /* TCA_AGC_LIN_VAL_2_0 */
   1344              XCVR_TCA_AGC_LIN_VAL_2_0 = (uint32_t)((XCVR_TCA_AGC_LIN_VAL_2_0 & (uint32_t)~(uint32_t)(
   1345                                    XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_0_MASK |
   1346                                    XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_1_MASK |
   1347                                    XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_2_MASK 
   1348                                   )) | (uint32_t)(
   1349                                    (TCA_AGC_LIN_VAL_0_def_c << XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_0_SHIFT) |
   1350                                    (TCA_AGC_LIN_VAL_1_def_c << XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_1_SHIFT) |
   1351                                    (TCA_AGC_LIN_VAL_2_def_c << XCVR_TCA_AGC_LIN_VAL_2_0_TCA_AGC_LIN_VAL_2_SHIFT)
   1352                                   ));    
   1353          
   1354              /* TCA_AGC_LIN_VAL_5_3 */    
   1355              XCVR_TCA_AGC_LIN_VAL_5_3 = (uint32_t)((XCVR_TCA_AGC_LIN_VAL_5_3 & (uint32_t)~(uint32_t)(
   1356                                    XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_3_MASK |
   1357                                    XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_4_MASK |
   1358                                    XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_5_MASK 
   1359                                   )) | (uint32_t)(
   1360                                    (TCA_AGC_LIN_VAL_3_def_c << XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_3_SHIFT) |
   1361                                    (TCA_AGC_LIN_VAL_4_def_c << XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_4_SHIFT) |
   1362                                    (TCA_AGC_LIN_VAL_5_def_c << XCVR_TCA_AGC_LIN_VAL_5_3_TCA_AGC_LIN_VAL_5_SHIFT)
   1363                                   ));    
   1364          
   1365              /* TCA_AGC_LIN_VAL_8_6 */        
   1366              XCVR_TCA_AGC_LIN_VAL_8_6 = (uint32_t)((XCVR_TCA_AGC_LIN_VAL_8_6 & (uint32_t)~(uint32_t)(
   1367                                    XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_6_MASK |
   1368                                    XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_7_MASK |
   1369                                    XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_8_MASK 
   1370                                   )) | (uint32_t)(
   1371                                    (TCA_AGC_LIN_VAL_6_def_c << XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_6_SHIFT) |
   1372                                    (TCA_AGC_LIN_VAL_7_def_c << XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_7_SHIFT) |
   1373                                    (TCA_AGC_LIN_VAL_8_def_c << XCVR_TCA_AGC_LIN_VAL_8_6_TCA_AGC_LIN_VAL_8_SHIFT)
   1374                                   ));    
   1375          
   1376              /* BBF_RES_TUNE_LIN_VAL_3_0 */
   1377              XCVR_BBF_RES_TUNE_LIN_VAL_3_0 = (uint32_t)((XCVR_BBF_RES_TUNE_LIN_VAL_3_0 & (uint32_t)~(uint32_t)(
   1378                                    XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_0_MASK  |
   1379                                    XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_1_MASK  |
   1380                                    XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_2_MASK  |
   1381                                    XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_3_MASK 
   1382                                   )) | (uint32_t)(
   1383                                    (BBF_RES_TUNE_LIN_VAL_0_def_c << XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_0_SHIFT) |
   1384                                    (BBF_RES_TUNE_LIN_VAL_1_def_c << XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_1_SHIFT) |
   1385                                    (BBF_RES_TUNE_LIN_VAL_2_def_c << XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_2_SHIFT) |
   1386                                    (BBF_RES_TUNE_LIN_VAL_3_def_c << XCVR_BBF_RES_TUNE_LIN_VAL_3_0_BBF_RES_TUNE_LIN_VAL_3_SHIFT)
   1387                                   ));    
   1388                
   1389              /* BBF_RES_TUNE_LIN_VAL_7_4 */  
   1390              XCVR_BBF_RES_TUNE_LIN_VAL_7_4 = (uint32_t)((XCVR_BBF_RES_TUNE_LIN_VAL_7_4 & (uint32_t)~(uint32_t)(
   1391                                    XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_4_MASK |
   1392                                    XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_5_MASK |
   1393                                    XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_6_MASK |
   1394                                    XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_7_MASK
   1395                                   )) | (uint32_t)(
   1396                                    (BBF_RES_TUNE_LIN_VAL_4_def_c << XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_4_SHIFT) |
   1397                                    (BBF_RES_TUNE_LIN_VAL_5_def_c << XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_5_SHIFT) |
   1398                                    (BBF_RES_TUNE_LIN_VAL_6_def_c << XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_6_SHIFT) |
   1399                                    (BBF_RES_TUNE_LIN_VAL_7_def_c << XCVR_BBF_RES_TUNE_LIN_VAL_7_4_BBF_RES_TUNE_LIN_VAL_7_SHIFT)
   1400                                   ));    
   1401          
   1402              /* BBF_RES_TUNE_LIN_VAL_10_8 */
   1403              XCVR_BBF_RES_TUNE_LIN_VAL_10_8 = (uint32_t)((XCVR_BBF_RES_TUNE_LIN_VAL_10_8 & (uint32_t)~(uint32_t)(
   1404                                    XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_8_MASK |
   1405                                    XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_9_MASK |
   1406                                    XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_10_MASK
   1407                                   )) | (uint32_t)(
   1408                                    (BBF_RES_TUNE_LIN_VAL_8_def_c << XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_8_SHIFT) |
   1409                                    (BBF_RES_TUNE_LIN_VAL_9_def_c << XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_9_SHIFT) |
   1410                                    (BBF_RES_TUNE_LIN_VAL_10_def_c << XCVR_BBF_RES_TUNE_LIN_VAL_10_8_BBF_RES_TUNE_LIN_VAL_10_SHIFT)
   1411                                   ));    
   1412          
   1413              if (gen1_dcgain_trims_enabled) /* Only run this code when Gen 1 DC GAIN trims are being used. */
   1414              {
   1415                  /* DCOC_TZA_STEP_GAIN & RCP 00-10 */
   1416                  XCVR_DCOC_TZA_STEP_00 = (uint32_t)((XCVR_DCOC_TZA_STEP_00 & (uint32_t)~(uint32_t)(
   1417                                    XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP_MASK |
   1418                                    XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN_MASK 
   1419                                   )) | (uint32_t)(
   1420                                    (DCOC_TZA_STEP_RCP_00_def_c << XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP_SHIFT) |
   1421                                    (DCOC_TZA_STEP_GAIN_00_def_c << XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN_SHIFT) 
   1422                                   ));    
   1423          
   1424                  XCVR_DCOC_TZA_STEP_01 = (uint32_t)((XCVR_DCOC_TZA_STEP_01 & (uint32_t)~(uint32_t)(
   1425                                    XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP_MASK |
   1426                                    XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN_MASK 
   1427                                   )) | (uint32_t)(
   1428                                    (DCOC_TZA_STEP_RCP_01_def_c << XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP_SHIFT) |
   1429                                    (DCOC_TZA_STEP_GAIN_01_def_c << XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN_SHIFT) 
   1430                                   ));    
   1431          
   1432                  XCVR_DCOC_TZA_STEP_02 = (uint32_t)((XCVR_DCOC_TZA_STEP_02 & (uint32_t)~(uint32_t)(
   1433                                    XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP_MASK |
   1434                                    XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN_MASK 
   1435                                   )) | (uint32_t)(
   1436                                    (DCOC_TZA_STEP_RCP_02_def_c << XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP_SHIFT) |
   1437                                    (DCOC_TZA_STEP_GAIN_02_def_c << XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN_SHIFT) 
   1438                                   ));    
   1439          
   1440                  XCVR_DCOC_TZA_STEP_03 = (uint32_t)((XCVR_DCOC_TZA_STEP_03 & (uint32_t)~(uint32_t)(
   1441                                    XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP_MASK |
   1442                                    XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN_MASK 
   1443                                   )) | (uint32_t)(
   1444                                    (DCOC_TZA_STEP_RCP_03_def_c << XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP_SHIFT) |
   1445                                    (DCOC_TZA_STEP_GAIN_03_def_c << XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN_SHIFT) 
   1446                                   ));    
   1447          
   1448                  XCVR_DCOC_TZA_STEP_04 = (uint32_t)((XCVR_DCOC_TZA_STEP_04 & (uint32_t)~(uint32_t)(
   1449                                    XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP_MASK |
   1450                                    XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN_MASK 
   1451                                   )) | (uint32_t)(
   1452                                    (DCOC_TZA_STEP_RCP_04_def_c << XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP_SHIFT) |
   1453                                    (DCOC_TZA_STEP_GAIN_04_def_c << XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN_SHIFT) 
   1454                                   ));    
   1455          
   1456                  XCVR_DCOC_TZA_STEP_05 = (uint32_t)((XCVR_DCOC_TZA_STEP_05 & (uint32_t)~(uint32_t)(
   1457                                    XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP_MASK |
   1458                                    XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN_MASK 
   1459                                   )) | (uint32_t)(
   1460                                    (DCOC_TZA_STEP_RCP_05_def_c << XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP_SHIFT) |
   1461                                    (DCOC_TZA_STEP_GAIN_05_def_c << XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN_SHIFT) 
   1462                                   ));    
   1463          
   1464                  XCVR_DCOC_TZA_STEP_06 = (uint32_t)((XCVR_DCOC_TZA_STEP_06 & (uint32_t)~(uint32_t)(
   1465                                    XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP_MASK |
   1466                                    XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN_MASK 
   1467                                   )) | (uint32_t)(
   1468                                    (DCOC_TZA_STEP_RCP_06_def_c << XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP_SHIFT) |
   1469                                    (DCOC_TZA_STEP_GAIN_06_def_c << XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN_SHIFT) 
   1470                                   ));    
   1471          
   1472                  XCVR_DCOC_TZA_STEP_07 = (uint32_t)((XCVR_DCOC_TZA_STEP_07 & (uint32_t)~(uint32_t)(
   1473                                    XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP_MASK |
   1474                                    XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN_MASK 
   1475                                   )) | (uint32_t)(
   1476                                    (DCOC_TZA_STEP_RCP_07_def_c << XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP_SHIFT) |
   1477                                    (DCOC_TZA_STEP_GAIN_07_def_c << XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN_SHIFT) 
   1478                                   ));    
   1479          
   1480                  XCVR_DCOC_TZA_STEP_08 = (uint32_t)((XCVR_DCOC_TZA_STEP_08 & (uint32_t)~(uint32_t)(
   1481                                    XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP_MASK |
   1482                                    XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN_MASK 
   1483                                   )) | (uint32_t)(
   1484                                    (DCOC_TZA_STEP_RCP_08_def_c << XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP_SHIFT) |
   1485                                    (DCOC_TZA_STEP_GAIN_08_def_c << XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN_SHIFT) 
   1486                                   ));    
   1487          
   1488                  XCVR_DCOC_TZA_STEP_09 = (uint32_t)((XCVR_DCOC_TZA_STEP_09 & (uint32_t)~(uint32_t)(
   1489                                    XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP_MASK |
   1490                                    XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN_MASK 
   1491                                   )) | (uint32_t)(
   1492                                    (DCOC_TZA_STEP_RCP_09_def_c << XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP_SHIFT) |
   1493                                    (DCOC_TZA_STEP_GAIN_09_def_c << XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN_SHIFT) 
   1494                                   ));    
   1495          
   1496                  XCVR_DCOC_TZA_STEP_10 = (uint32_t)((XCVR_DCOC_TZA_STEP_10 & (uint32_t)~(uint32_t)(
   1497                                    XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP_MASK |
   1498                                    XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN_MASK 
   1499                                   )) | (uint32_t)(
   1500                                    (DCOC_TZA_STEP_RCP_10_def_c << XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_RCP_SHIFT) |
   1501                                    (DCOC_TZA_STEP_GAIN_10_def_c << XCVR_DCOC_TZA_STEP__DCOC_TZA_STEP_GAIN_SHIFT) 
   1502                                   ));    
   1503              }
   1504             
   1505              /* DCOC_CTRL_1 */
   1506              XCVR_DCOC_CTRL_1 = (uint32_t)((XCVR_DCOC_CTRL_1 & (uint32_t)~(uint32_t)(
   1507                                    XCVR_DCOC_CTRL_1_TRACK_FROM_ZERO_MASK |
   1508                                    XCVR_DCOC_CTRL_1_BBA_CORR_POL_MASK |
   1509                                    XCVR_DCOC_CTRL_1_TZA_CORR_POL_MASK 
   1510                                   )) | (uint32_t)(
   1511                                    (TRACK_FROM_ZERO_def_c << XCVR_DCOC_CTRL_1_TRACK_FROM_ZERO_SHIFT) |
   1512                                    (BBF_CORR_POL_def_c << XCVR_DCOC_CTRL_1_BBA_CORR_POL_SHIFT) |
   1513                                    (TZA_CORR_POL_def_c << XCVR_DCOC_CTRL_1_TZA_CORR_POL_SHIFT)
   1514                                   ));
   1515          
   1516              if (gen1_dcgain_trims_enabled)
   1517              {
   1518                  XCVR_BWR_DCOC_CTRL_1_BBF_DCOC_STEP(XCVR, BBF_STEP_def_c); /* Only write this field if Gen1 DC GAIN trims being used. */
   1519              }
   1520              
   1521              /* DCOC_CTRL_2 */
   1522              if (gen1_dcgain_trims_enabled)
   1523              {
   1524                  XCVR_BWR_DCOC_CTRL_2_BBF_DCOC_STEP_RECIP(XCVR, BBF_STEP_RECIP_def_c);
   1525              }
   1526              
   1527              /* DCOC_CAL_RCP */      
   1528              XCVR_DCOC_CAL_RCP = (uint32_t)((XCVR_DCOC_CAL_RCP & (uint32_t)~(uint32_t)(
   1529                                    XCVR_DCOC_CAL_RCP_DCOC_TMP_CALC_RECIP_MASK |
   1530                                    XCVR_DCOC_CAL_RCP_ALPHA_CALC_RECIP_MASK 
   1531                                   )) | (uint32_t)(
   1532                                    (RCP_GBHmGBL_def_c << XCVR_DCOC_CAL_RCP_DCOC_TMP_CALC_RECIP_SHIFT) |
   1533                                    (RCP_GLHmGLLxGBL_def_c << XCVR_DCOC_CAL_RCP_ALPHA_CALC_RECIP_SHIFT) 
   1534                                   ));    
   1535              
   1536              return gXcvrSuccess_c;
   1537          }
   1538          
   1539          /*! *********************************************************************************
   1540          * \brief  This function sets up the TX_DIG and PLL settings 
   1541          *
   1542          * \param[in] radioMode - the operating mode for the radio to be configured
   1543          *
   1544          * \return status of the operation.
   1545          *
   1546          * \ingroup PrivateAPIs
   1547          *
   1548          * \details
   1549          *
   1550          ***********************************************************************************/
   1551          void XcvrSetTxDigPLLDefaults( radio_mode_t radioMode )
   1552          {
   1553              /* Configure the High Port Sigma Delta */
   1554              XCVR_BWR_ANA_SPARE_HPM_LSB_INVERT(XCVR, HPM_LSB_INVERT_def_c);
   1555              XCVR_BWR_PLL_HPM_SDM_FRACTION_HPM_DENOM(XCVR, HPM_DENOM_def_c);
   1556              
   1557              /* Configure the PLL Modulation Delays */
   1558              XCVR_BWR_PLL_DELAY_MATCH_HPM_BANK_DELAY(XCVR, HPM_BANK_DELAY_def_c);
   1559              XCVR_BWR_PLL_DELAY_MATCH_HPM_SDM_DELAY(XCVR, HPM_SDM_DELAY_def_c);
   1560              XCVR_BWR_PLL_DELAY_MATCH_LP_SDM_DELAY(XCVR, LP_SDM_DELAY_def_c);
   1561              
   1562              /* Configure PLL Loop Filter Configuration from Default value */
   1563              XCVR_BWR_PLL_CTRL_PLL_LFILT_CNTL(XCVR, PLL_LFILT_CNTL_def_c);                       
   1564              
   1565              /* Change FSK_MODULATION_SCALE_1 from it Default value */
   1566              XCVR_BWR_TX_FSK_MOD_SCALE_FSK_MODULATION_SCALE_1(XCVR, FSK_MODULATION_SCALE_1_def_c);     
   1567              
   1568              /* PLL Dithering */
   1569              XCVR_BWR_PLL_LP_MOD_CTRL_LPM_D_OVRD(XCVR, 1); /* Enable over-riding dither control */
   1570              XCVR_BWR_PLL_LP_MOD_CTRL_LPM_DTH_SCL(XCVR, 0x8); /* Set dither range */
   1571              XCVR_BWR_PLL_LP_MOD_CTRL_LPM_D_CTRL(XCVR, 1); /* Turn on dither all the time */
   1572          
   1573              /* Use mode switch routine to setup the defaults that depend on radio mode (none at this time) */
   1574              XcvrSetTxDigPLLDef_ModeSwitch(radioMode);
   1575          }
   1576          
   1577          /*! *********************************************************************************
   1578          * \brief  This function sets up the TX_DIG and PLL radio mode specific settings 
   1579          *
   1580          * \param[in] radioMode - the operating mode for the radio to be configured
   1581          *
   1582          * \ingroup PrivateAPIs
   1583          *
   1584          * \details
   1585          *
   1586          ***********************************************************************************/
   1587          void XcvrSetTxDigPLLDef_ModeSwitch( radio_mode_t radioMode )
   1588          {
   1589              
   1590          }
   1591          
   1592          /*! *********************************************************************************
   1593          * \brief  This function sets up the analog settings 
   1594          *
   1595          * \param[in] radioMode - the operating mode for the radio to be configured
   1596          *
   1597          * \ingroup PrivateAPIs
   1598          *
   1599          * \details
   1600          *
   1601          ***********************************************************************************/
   1602          void XcvrSetAnalogDefaults ( radio_mode_t radioMode )
   1603          {
   1604              /* Use mode switch routine to setup the defaults that depend on radio mode */
   1605              XcvrSetAnalogDef_ModeSwitch(radioMode);
   1606              
   1607              /* Regulator trim and ADC trims */
   1608              XCVR_BWR_PLL_CTRL2_PLL_VCO_REG_SUPPLY(XCVR, 1);
   1609              XCVR_BWR_ADC_TUNE_ADC_R1_TUNE(XCVR, 5);
   1610              XCVR_BWR_ADC_TUNE_ADC_R2_TUNE(XCVR, 5);
   1611              XCVR_BWR_ADC_TUNE_ADC_C1_TUNE(XCVR, 8);
   1612              XCVR_BWR_ADC_TUNE_ADC_C2_TUNE(XCVR, 8);
   1613              
   1614              XCVR_BWR_ADC_ADJ_ADC_IB_OPAMP1_ADJ(XCVR, 5);
   1615              XCVR_BWR_ADC_ADJ_ADC_IB_OPAMP2_ADJ(XCVR, 7);
   1616              XCVR_BWR_ADC_ADJ_ADC_IB_DAC1_ADJ(XCVR, 2);
   1617              XCVR_BWR_ADC_ADJ_ADC_IB_DAC2_ADJ(XCVR, 2);
   1618              XCVR_BWR_ADC_ADJ_ADC_IB_FLSH_ADJ(XCVR, 6);
   1619              XCVR_BWR_ADC_ADJ_ADC_FLSH_RES_ADJ(XCVR, 0);    
   1620            
   1621              XCVR_BWR_ADC_TRIMS_ADC_IREF_OPAMPS_RES_TRIM(XCVR, 2);
   1622              XCVR_BWR_ADC_TRIMS_ADC_IREF_FLSH_RES_TRIM(XCVR, 4);
   1623              XCVR_BWR_ADC_TRIMS_ADC_VCM_TRIM(XCVR, 4);
   1624            
   1625              /* Raise QGEN and ADC_ANA and ADC_DIG supplies */
   1626              XCVR_BWR_ADC_REGS_ADC_ANA_REG_SUPPLY(XCVR, 9);
   1627              XCVR_BWR_ADC_REGS_ADC_REG_DIG_SUPPLY(XCVR, 9);
   1628              XCVR_BWR_QGEN_CTRL_QGEN_REG_SUPPLY(XCVR, 9);
   1629          }
   1630          
   1631          /*! *********************************************************************************
   1632          * \brief  This function sets up the radio mode specific analog settings 
   1633          *
   1634          * \param[in] radioMode - the operating mode for the radio to be configured
   1635          *
   1636          * \ingroup PrivateAPIs
   1637          *
   1638          * \details
   1639          *
   1640          ***********************************************************************************/
   1641          void XcvrSetAnalogDef_ModeSwitch ( radio_mode_t radioMode )
   1642          {
   1643              switch (radioMode)
   1644              {
   1645              case BLE:
   1646                  /* TZA_CTRL for BLE */
   1647                  XCVR_BWR_TZA_CTRL_TZA_CAP_TUNE(XCVR, ble_tza_cap_tune);
   1648                  
   1649                  /* BBF_CTRL for BLE */
   1650                  XCVR_BBF_CTRL = (uint32_t)((XCVR_BBF_CTRL & (uint32_t)~(uint32_t)(
   1651                                XCVR_BBF_CTRL_BBF_CAP_TUNE_MASK |
   1652                                XCVR_BBF_CTRL_BBF_RES_TUNE2_MASK |
   1653                                XCVR_BBF_CTRL_DCOC_ALPHAC_SCALE_GS_IDX_MASK
   1654                               )) | (uint32_t)(
   1655                                (ble_bbf_cap_tune << XCVR_BBF_CTRL_BBF_CAP_TUNE_SHIFT) |
   1656                                (ble_bbf_res_tune2 << XCVR_BBF_CTRL_BBF_RES_TUNE2_SHIFT) |
   1657                                (DCOC_ALPHAC_SCALE_GS_IDX_def_c << XCVR_BBF_CTRL_DCOC_ALPHAC_SCALE_GS_IDX_SHIFT)
   1658                               )); 
   1659                  break;
   1660              case ZIGBEE:
   1661                  /* TZA_CTRL for Zigbee */
   1662                  XCVR_BWR_TZA_CTRL_TZA_CAP_TUNE(XCVR, zb_tza_cap_tune);
   1663                  
   1664                  /* BBF_CTRL for Zigbee */
   1665                  XCVR_BBF_CTRL = (uint32_t)((XCVR_BBF_CTRL & (uint32_t)~(uint32_t)(
   1666                                XCVR_BBF_CTRL_BBF_CAP_TUNE_MASK |
   1667                                XCVR_BBF_CTRL_BBF_RES_TUNE2_MASK |
   1668                                XCVR_BBF_CTRL_DCOC_ALPHAC_SCALE_GS_IDX_MASK
   1669                               )) | (uint32_t)(
   1670                                (zb_bbf_cap_tune << XCVR_BBF_CTRL_BBF_CAP_TUNE_SHIFT) |
   1671                                (zb_bbf_res_tune2 << XCVR_BBF_CTRL_BBF_RES_TUNE2_SHIFT) |
   1672                                (DCOC_ALPHAC_SCALE_GS_IDX_def_c << XCVR_BBF_CTRL_DCOC_ALPHAC_SCALE_GS_IDX_SHIFT)
   1673                               ));
   1674                  break;
   1675              default:
   1676                  break;
   1677              }
   1678          }
   1679          
   1680          /*! *********************************************************************************
   1681          * \brief  This function controls the enable/disable of RSSI IIR narrowband filter
   1682          *  used in Zigbee CCA tests for narrowband RSSI measurement.
   1683          *
   1684          * \param[in] IIRnbEnable - enable or disable the narrowband IIR filter
   1685          *
   1686          * \ingroup PublicAPIs
   1687          *
   1688          * \details
   1689          *
   1690          ***********************************************************************************/
   1691          void XcvrEnaNBRSSIMeas( bool_t IIRnbEnable )
   1692          {
   1693              if (IIRnbEnable)
   1694              {
   1695                  /* enable narrowband IIR filter for RSSI */
   1696                  XCVR_BWR_RSSI_CTRL_0_RSSI_IIR_CW_WEIGHT(XCVR, RSSI_IIR_CW_WEIGHT_ENABLEDdef_c);
   1697              }
   1698              else
   1699              {
   1700                  /* Disable narrowband IIR filter for RSSI */
   1701                  XCVR_BWR_RSSI_CTRL_0_RSSI_IIR_CW_WEIGHT(XCVR, RSSI_IIR_CW_WEIGHT_BYPASSEDdef_c);    
   1702              }
   1703          }
   1704          
   1705          /* Customer level trim functions */
   1706          /*! *********************************************************************************
   1707          * \brief  This function sets the XTAL trim field to control crystal osc frequency.
   1708          *
   1709          * \param[in] xtalTrim - value to control the trim of the crystal osc.
   1710          *
   1711          * \return status of the operation.
   1712          *
   1713          * \ingroup PublicAPIs
   1714          *
   1715          * \details
   1716          *
   1717          ***********************************************************************************/
   1718          xcvrStatus_t XcvrSetXtalTrim(int8_t xtalTrim)
   1719          {
   1720              XCVR_BWR_XTAL_CTRL_XTAL_TRIM(XCVR, xtalTrim);
   1721              return gXcvrSuccess_c;
   1722          }
   1723          
   1724          /*! *********************************************************************************
   1725          * \brief  This function reads the XTAL trim field
   1726          *
   1727          * \return the current value of the crystal osc trim.
   1728          *
   1729          * \ingroup PublicAPIs
   1730          *
   1731          * \details
   1732          *
   1733          ***********************************************************************************/
   1734          int8_t  XcvrGetXtalTrim(void)
   1735          {
   1736              return (int8_t)XCVR_BRD_XTAL_CTRL_XTAL_TRIM(XCVR);
   1737          }
   1738          
   1739          /*! *********************************************************************************
   1740          * \brief  This function sets the AGC gain setting table entry and the DCOC table 
   1741          *         entry to be used.
   1742          *
   1743          * \param[in] entry: Entry number from AGC table to use.
   1744          *
   1745          * \return status of the operation.
   1746          *
   1747          * \ingroup PrivateAPIs
   1748          *
   1749          * \details
   1750          *
   1751          ***********************************************************************************/
   1752          xcvrStatus_t XcvrSetGain ( uint8_t entry )
   1753          {
   1754          #if INCLUDE_OLD_DRV_CODE
   1755              if (entry > 26)
   1756              {
   1757                  return gXcvrInvalidParameters_c;
   1758              }
   1759              
   1760              XCVR_AGC_CTRL_1_WR((uint32_t)((XCVR_AGC_CTRL_1_RD & (uint32_t)~(uint32_t)(    
   1761                                    XCVR_AGC_CTRL_1_AGC_IDLE_GAIN_MASK
   1762                                   )) | (uint32_t)(
   1763                                    (entry << XCVR_AGC_CTRL_1_AGC_IDLE_GAIN_SHIFT)     
   1764                                   )));  
   1765          #endif  
   1766              return gXcvrSuccess_c;
   1767          }
   1768          
   1769          /*! *********************************************************************************
   1770          * \brief  This function sets the channel for test mode and overrides the BLE and Zigbee channel. 
   1771          *
   1772          * \param[in] channel: Channel number.
   1773          * \param[in] useMappedChannel: Selects to use the channel map table (TRUE) or to use the manual frequency setting based on a SW table of numerator and denominator values for the PLL.
   1774          *
   1775          * \return status of the operation.
   1776          *
   1777          * \ingroup PrivateAPIs
   1778          *
   1779          * \details This function overrides both the BLE and Zigbee channel values from the respective LLs. 
   1780          *
   1781          ***********************************************************************************/
   1782          xcvrStatus_t XcvrOverrideChannel ( uint8_t channel, uint8_t useMappedChannel )
   1783          {
   1784              if(channel == 0xFF)
   1785              {
   1786                  /* Clear all of the overrides and restore to LL channel control */
   1787                  
   1788                  XCVR_PLL_CHAN_MAP = (uint32_t)((XCVR_PLL_CHAN_MAP & (uint32_t)~(uint32_t)(    
   1789                                    XCVR_PLL_CHAN_MAP_CHANNEL_NUM_MASK | 
   1790                                    XCVR_PLL_CHAN_MAP_ZOC_MASK | 
   1791                                    XCVR_PLL_CHAN_MAP_BOC_MASK
   1792                                   )));
   1793                  
   1794                  /* Stop using the manual frequency setting */
   1795                  XCVR_BWR_PLL_LP_SDM_CTRL1_SDM_MAP_DIS(XCVR, 0);
   1796                  
   1797                  return gXcvrSuccess_c;
   1798              }
   1799              
   1800              if(channel >= 128)
   1801              {
   1802                  return gXcvrInvalidParameters_c;
   1803              }
   1804              
   1805              if(useMappedChannel == TRUE)
   1806              {
   1807                  XCVR_PLL_CHAN_MAP = (uint32_t)((XCVR_PLL_CHAN_MAP & (uint32_t)~(uint32_t)(    
   1808                                    XCVR_PLL_CHAN_MAP_CHANNEL_NUM_MASK | 
   1809                                    XCVR_PLL_CHAN_MAP_BOC_MASK |
   1810                                    XCVR_PLL_CHAN_MAP_ZOC_MASK
   1811                                   )) | (uint32_t)(
   1812                                    (channel << XCVR_PLL_CHAN_MAP_CHANNEL_NUM_SHIFT) |
   1813                                    (0x01 << XCVR_PLL_CHAN_MAP_BOC_SHIFT) |
   1814                                    (0x01 << XCVR_PLL_CHAN_MAP_ZOC_SHIFT)
   1815                                   ));         
   1816              }
   1817              else
   1818              {
   1819                  XCVR_PLL_CHAN_MAP =  (uint32_t)((XCVR_PLL_CHAN_MAP & (uint32_t)~(uint32_t)(                                
   1820                                    XCVR_PLL_CHAN_MAP_BOC_MASK |
   1821                                    XCVR_PLL_CHAN_MAP_ZOC_MASK
   1822                                   )) | (uint32_t)(
   1823                                    (0x01 << XCVR_PLL_CHAN_MAP_BOC_SHIFT) |
   1824                                    (0x01 << XCVR_PLL_CHAN_MAP_ZOC_SHIFT)
   1825                                   ));  
   1826                  
   1827                  XCVR_BWR_PLL_LP_SDM_CTRL3_LPM_DENOM(XCVR, gPllDenom_c);
   1828                  XCVR_BWR_PLL_LP_SDM_CTRL2_LPM_NUM(XCVR, mapTable[channel].numerator);   
   1829                  XCVR_BWR_PLL_LP_SDM_CTRL1_LPM_INTG(XCVR, mapTable[channel].integer);
   1830                  
   1831                  /* Stop using the LL channel map and use the manual frequency setting */
   1832                  XCVR_BWR_PLL_LP_SDM_CTRL1_SDM_MAP_DIS(XCVR, 1);
   1833              }
   1834              
   1835              return gXcvrSuccess_c;
   1836          }
   1837          
   1838          /*! *********************************************************************************
   1839          * \brief  This function sets the frequency at the PLL for test mode and overrides the BLE/ZB channel
   1840          *
   1841          * \param[in] freq: Frequency in KHz.
   1842          * \param[in] refOsc: Osc in MHz.
   1843          *
   1844          * \return status of the operation.
   1845          *
   1846          * \ingroup PrivateAPIs
   1847          *
   1848          * \details
   1849          
   1850          The Manual carrier frequency selected can be calculated using the formula below:
   1851          Radio Carrier Frequency = ((Reference Clock Frequency x 2) x (LPM_INTG +
   1852          (LPM_NUM / LPM_DENOM))
   1853          WARNING : The fraction (LPM_NUM / LPM_DENOM) must be in the range of -0.55
   1854          to +0.55 for valid Sigma Delta Modulator operation.
   1855          
   1856          *
   1857          ***********************************************************************************/
   1858          xcvrStatus_t XcvrOverrideFrequency ( uint32_t freq , uint32_t refOsc) 
   1859          { 
   1860              int32_t intg;
   1861              int32_t num;
   1862              int32_t denom = 0x04000000;
   1863              uint32_t sdRate = 64000000;
   1864              double fract_check;
   1865              
   1866              intg = (uint32_t) freq / sdRate;
   1867              
   1868              /* CTUNE Target must be loaded manually +/- 6MHz should be ok for PLL Lock. */
   1869              XCVR_BWR_PLL_CTUNE_CTRL_CTUNE_TARGET_MANUAL(XCVR, freq/1000000);
   1870              XCVR_BWR_PLL_CTUNE_CTRL_CTUNE_TD(XCVR,1);  /*CTUNE Target Disable */
   1871              
   1872              XCVR_PLL_CHAN_MAP |=  XCVR_PLL_CHAN_MAP_BOC_MASK | XCVR_PLL_CHAN_MAP_ZOC_MASK;
   1873              
   1874              XCVR_BWR_PLL_LP_SDM_CTRL1_SDM_MAP_DIS(XCVR, 1);
   1875              
   1876              fract_check = (freq % sdRate);
   1877              fract_check /= sdRate;
   1878              
   1879              if (fract_check >= 0.55) 
   1880              {
   1881                  fract_check--;
   1882                  intg++;
   1883              }
   1884              
   1885              num = refOsc;
   1886              num = (int32_t) (fract_check * denom);
   1887              
   1888              if (num < 0)
   1889                  num = (((1 << 28) - 1) & ((1 << 28) - 1) - ABS(num)) + 1;
   1890              
   1891              XCVR_BWR_PLL_LP_SDM_CTRL1_LPM_INTG(XCVR, intg);
   1892              XCVR_BWR_PLL_LP_SDM_CTRL2_LPM_NUM(XCVR, num);
   1893              XCVR_BWR_PLL_LP_SDM_CTRL3_LPM_DENOM(XCVR, denom);
   1894              
   1895              return gXcvrSuccess_c;
   1896          }
   1897          
   1898          /*! *********************************************************************************
   1899          * \brief  This function reads the RF PLL values and returns the programmed frequency  
   1900          *
   1901          * \return Frequency generated by the PLL.
   1902          *
   1903          * \ingroup PrivateAPIs
   1904          *
   1905          * \details
   1906          *
   1907          ***********************************************************************************/
   1908          uint32_t XcvrGetFreq ( void )
   1909          {
   1910              uint32_t pll_int, pll_denom;
   1911              int64_t pll_num;
   1912              
   1913              pll_int = XCVR_BRD_PLL_LP_SDM_CTRL1_LPM_INTG(XCVR);                 
   1914              pll_num = XCVR_BRD_PLL_LP_SDM_CTRL2_LPM_NUM(XCVR);
   1915              
   1916              if ( (pll_num & 0x0000000004000000) == 0x0000000004000000)
   1917                  pll_num = 0xFFFFFFFFF8000000 + pll_num; /* Sign extend the numerator */  
   1918              
   1919              pll_denom = XCVR_BRD_PLL_LP_SDM_CTRL3_LPM_DENOM(XCVR);   
   1920              
   1921              /* Original formula: ((float) pll_int + ((float)pll_num / (float)pll_denom)) * 64 */
   1922              return  (uint32_t)(pll_int << 6) + ((pll_num << 6) / pll_denom); /* Calculate the frequency in MHz */
   1923          }
   1924          
   1925          /*! *********************************************************************************
   1926          * \brief  This function overrides the TSM module and starts the RX warmup procedure 
   1927          *
   1928          * \ingroup PrivateAPIs
   1929          *
   1930          * \details
   1931          *
   1932          ***********************************************************************************/
   1933          void XcvrForceRxWu ( void )
   1934          {
   1935              /* Set "FORCE_RX_EN" in TSM Control register */
   1936              XCVR_BWR_TSM_CTRL_FORCE_RX_EN(XCVR, 1); 
   1937          }
   1938          
   1939          /*! *********************************************************************************
   1940          * \brief  This function overrides the TSM module and starts the RX warmdown procedure 
   1941          *
   1942          * \ingroup PrivateAPIs
   1943          *
   1944          * \details
   1945          *
   1946          ***********************************************************************************/
   1947          void XcvrForceRxWd ( void )
   1948          {
   1949              /* Clear "FORCE_RX_EN" in TSM Control register */
   1950              XCVR_BWR_TSM_CTRL_FORCE_RX_EN(XCVR, 0); 
   1951          }
   1952          
   1953          /*! *********************************************************************************
   1954          * \brief  This function overrides the TSM module and starts the TX warmup procedure 
   1955          *
   1956          * \ingroup PrivateAPIs
   1957          *
   1958          * \details
   1959          *
   1960          ***********************************************************************************/
   1961          void XcvrForceTxWu ( void )
   1962          {
   1963              XCVR_BWR_TSM_CTRL_FORCE_TX_EN(XCVR, 1);
   1964          }
   1965          
   1966          /*! *********************************************************************************
   1967          * \brief  This function overrides the TSM module and starts the TX warmdown procedure 
   1968          *
   1969          * \ingroup PrivateAPIs
   1970          *
   1971          * \details
   1972          *
   1973          ***********************************************************************************/
   1974          void XcvrForceTxWd ( void )
   1975          {
   1976              XCVR_BWR_TSM_CTRL_FORCE_TX_EN(XCVR, 0);
   1977              
   1978              /* Clear "TX_CW_NOMOD" bit in TX Digital Control register */
   1979              XCVR_BWR_TX_DIG_CTRL_DFT_MODE(XCVR, 0); /* Normal radio operation */
   1980          }
   1981          
   1982          /*! *********************************************************************************
   1983          * \brief  This function performs an unmodulated TX test.
   1984          *
   1985          * \ingroup PrivateAPIs
   1986          *
   1987          * \details
   1988          *
   1989          ***********************************************************************************/
   1990          void XcvrTxTest ( void )
   1991          {
   1992              volatile uint32_t rez[128], i;
   1993              
   1994              for(i=0;i<=127;i++)
   1995              {
   1996                  XcvrOverrideChannel (i, 0);
   1997                  rez[i] = XcvrGetFreq ();
   1998                  XcvrForceTxWu();
   1999                  XcvrDelay(30000);
   2000                  XcvrForceTxWd();
   2001              }
   2002              
   2003              XcvrOverrideChannel (0xFF, 1);
   2004          }
   2005          
   2006          /*! *********************************************************************************
   2007          * \brief  Temporary delay function 
   2008          *
   2009          * \param[in] time the number of counts to decrement through in a wait loop.
   2010          *
   2011          * \return none.
   2012          *
   2013          * \ingroup PrivateAPIs
   2014          *
   2015          * \details
   2016          *
   2017          ***********************************************************************************/
   2018          void XcvrDelay(volatile uint32_t time){
   2019              while(time>0){
   2020                  time--;
   2021              }
   2022          }
   2023          
   2024          /*! *********************************************************************************
   2025          * \brief  Manual DCOC calibration function to support board level calibration.
   2026          *
   2027          * \param[in] chnum Channel number.
   2028          *
   2029          * \ingroup PrivateAPIs
   2030          *
   2031          * \details
   2032          *   Performs manual DCOC calibration and sets TZA and BBF gains per this calibration.
   2033          *   Disables DCOC_CAL_EN to prevent TSM signals from triggering calibration.
   2034          *   Intended to enable software development to continue during DCOC cal debug.
   2035          *
   2036          ***********************************************************************************/
   2037          void XcvrManualDCOCCal (uint8_t chnum)
   2038          {
   2039              static uint8_t DAC_idx;
   2040              static int16_t dc_meas_i;
   2041              static int16_t dc_meas_q;
   2042              static int16_t dc_meas_total;
   2043              static uint8_t curr_min_dc_tza_i_idx, curr_min_dc_tza_q_idx;
   2044              static int16_t curr_min_dc_tza_i, curr_min_dc_tza_q;
   2045              static int16_t curr_min_dc_total;
   2046              static uint8_t curr_min_dc_bbf_i_idx, curr_min_dc_bbf_q_idx;
   2047              static int16_t curr_min_dc_bbf_i, curr_min_dc_bbf_q;
   2048              uint32_t dcoc_ctrl_0_stack;
   2049              uint32_t dcoc_ctrl_1_stack;
   2050              uint32_t dcoc_cal_gain_state;
   2051              uint8_t gearshift_state;
   2052              
   2053              XcvrOverrideChannel(chnum,TRUE);
   2054              
   2055              dcoc_ctrl_0_stack = XCVR_DCOC_CTRL_0; /* Save state of DCOC_CTRL_0 for later restore */
   2056              dcoc_ctrl_1_stack = XCVR_DCOC_CTRL_1; /* Save state of DCOC_CTRL_1 for later restore */
   2057              dcoc_cal_gain_state = XCVR_DCOC_CAL_GAIN; /* Save state of DCOC_CAL_GAIN for later restore */
   2058              gearshift_state = XCVR_BRD_ANA_SPARE_DCOC_TRK_EST_GS_CNT(XCVR); /* Save state of gearshift control for later restore */
   2059              
   2060              /* Set DCOC_CTRL_0, DCOC_CAL_GAIN, and GEARSHIFT to appropriate values for manual nulling of DC */
   2061              XCVR_DCOC_CTRL_0 = ((0x2 << XCVR_DCOC_CTRL_0_DCOC_ALPHAC_SCALE_IDX_SHIFT) |
   2062                                  (0x3 << XCVR_DCOC_CTRL_0_DCOC_ALPHA_RADIUS_IDX_SHIFT) |
   2063                                  (0x3 << XCVR_DCOC_CTRL_0_DCOC_SIGN_SCALE_IDX_SHIFT) |
   2064                                  (0x12 << XCVR_DCOC_CTRL_0_DCOC_CAL_DURATION_SHIFT) |
   2065                                  (0x52 << XCVR_DCOC_CTRL_0_DCOC_CORR_DLY_SHIFT) |
   2066                                  (0x10 << XCVR_DCOC_CTRL_0_DCOC_CORR_HOLD_TIME_SHIFT) |
   2067                                  (0x1 << XCVR_DCOC_CTRL_0_DCOC_MAN_SHIFT) |
   2068                                  (0x1 << XCVR_DCOC_CTRL_0_DCOC_TRACK_EN_SHIFT) |
   2069                                  (0x1 << XCVR_DCOC_CTRL_0_DCOC_CORRECT_EN_SHIFT) 
   2070                                 );   
   2071              XCVR_DCOC_CTRL_1 = ((0x0 << XCVR_DCOC_CTRL_1_TRACK_FROM_ZERO_SHIFT) |
   2072                                  (0x1 << XCVR_DCOC_CTRL_1_BBA_CORR_POL_SHIFT) |
   2073                                  (0x1 << XCVR_DCOC_CTRL_1_TZA_CORR_POL_SHIFT) 
   2074                                 );   
   2075              XCVR_DCOC_CAL_GAIN = ((0x03 << XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN1_SHIFT) |
   2076                                    (0x02 << XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN1_SHIFT) |
   2077                                    (0x08 << XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN2_SHIFT) |
   2078                                    (0x02 << XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN2_SHIFT) |
   2079                                    (0x03 << XCVR_DCOC_CAL_GAIN_DCOC_TZA_CAL_GAIN3_SHIFT) |
   2080                                    (0x08 << XCVR_DCOC_CAL_GAIN_DCOC_BBF_CAL_GAIN3_SHIFT) 
   2081                                   );   
   2082              
   2083              XCVR_BWR_ANA_SPARE_DCOC_TRK_EST_GS_CNT(XCVR, 0x00);
   2084              
   2085              /* Search for optimal DC DAC settings */
   2086              XCVR_BWR_DCOC_CTRL_0_DCOC_TRACK_EN(XCVR, 1);   /* DCOC track */
   2087              XCVR_BWR_RX_DIG_CTRL_RX_AGC_EN(XCVR, 0);       /* AGC Control */
   2088              XCVR_BWR_RX_DIG_CTRL_RX_DCOC_EN(XCVR, 1);      /* DCOC_EN */
   2089              XCVR_BWR_RX_DIG_CTRL_RX_DCOC_CAL_EN(XCVR, 0);  /* DCOC_CAL 0=disabled; 1=Enabled */
   2090              XcvrForceRxWu();
   2091              XcvrDelay(2000);
   2092              
   2093              XCVR_BWR_DCOC_CTRL_0_DCOC_MAN(XCVR, 1);        /* Force dcoc dacs to use manual override */
   2094              
   2095              /* Go through gain table to get each setting */
   2096              
   2097              static uint8_t tbl_idx;
   2098              uint8_t * tbl_ptr=(uint8_t *)(&XCVR_AGC_GAIN_TBL_03_00);
   2099              static uint8_t tbl_val;
   2100              for (tbl_idx = 0; tbl_idx <27; tbl_idx++)
   2101              {
   2102                  tbl_val = *tbl_ptr;
   2103                  tbl_ptr++;
   2104                  XCVR_BWR_AGC_CTRL_1_LNM_USER_GAIN(XCVR, ((0xF0&tbl_val)>>4));    /* Set Manual Gain Index for LNM */
   2105                  XCVR_BWR_AGC_CTRL_1_BBF_USER_GAIN(XCVR, (0x0F&tbl_val));         /* Set Manual Gain Index for BBF */
   2106                  XCVR_BWR_AGC_CTRL_1_USER_LNM_GAIN_EN(XCVR, 1);  /* Use Manual Gain for LNM */
   2107                  XCVR_BWR_AGC_CTRL_1_USER_BBF_GAIN_EN(XCVR, 1);  /* Use Manual Gain for BBF */
   2108                  
   2109                  XcvrDelay(32*3);
   2110                  
   2111                  /* Init fixed, mid-point values for BBF while sweeping TZA */
   2112                  XCVR_BWR_DCOC_CTRL_3_BBF_DCOC_INIT_I(XCVR, 0x20); /* Set bbf I to mid */
   2113                  XCVR_BWR_DCOC_CTRL_3_BBF_DCOC_INIT_Q(XCVR, 0x20); /* Set bbf Q to mid */
   2114                  
   2115                  /* Measure optimal TZA DAC setting */
   2116                  curr_min_dc_tza_i = 2000;
   2117                  curr_min_dc_tza_q = 2000;
   2118                  curr_min_dc_total = 4000;
   2119                  DAC_idx=0;
   2120                  
   2121                  if(0)  /* Set to 1 for brute force, takes a long time */
   2122                  {
   2123                      do
   2124                      {
   2125                          XCVR_BWR_DCOC_CTRL_3_TZA_DCOC_INIT_I(XCVR, (0x00FF & DAC_idx));
   2126                          XCVR_BWR_DCOC_CTRL_3_TZA_DCOC_INIT_Q(XCVR, (0xFF00 & DAC_idx)>>8);
   2127                          XcvrDelay(32*2);
   2128                          /* Take I measurement */
   2129                          dc_meas_i = XCVR_BRD_DCOC_DC_EST_DC_EST_I(XCVR);
   2130                          dc_meas_i = dc_meas_i | ((dc_meas_i & 0x800) ? 0xF000 : 0x0);
   2131                          dc_meas_i = (dc_meas_i < 0) ? (-1*dc_meas_i) : (dc_meas_i);
   2132                          
   2133                          /* Take Q measurement */
   2134                          dc_meas_q = XCVR_BRD_DCOC_DC_EST_DC_EST_Q(XCVR);
   2135                          dc_meas_q = dc_meas_q | ((dc_meas_q & 0x800) ? 0xF000 : 0x0);
   2136                          dc_meas_q = (dc_meas_q < 0) ? (-1*dc_meas_q) : (dc_meas_q);
   2137                          dc_meas_total = dc_meas_i + dc_meas_q;
   2138                          if(dc_meas_total < curr_min_dc_total)
   2139                          {
   2140                              curr_min_dc_total = dc_meas_total;
   2141                              curr_min_dc_tza_i_idx = (0x00FF & DAC_idx);
   2142                              curr_min_dc_tza_q_idx = (0xFF00 & DAC_idx)>>8;
   2143                          }
   2144                          
   2145                          if(dc_meas_i < curr_min_dc_tza_i)
   2146                          {
   2147                              curr_min_dc_tza_i = dc_meas_i;
   2148                          }
   2149                          if(dc_meas_q < curr_min_dc_tza_q)
   2150                          {
   2151                              curr_min_dc_tza_q = dc_meas_q;
   2152                          }
   2153                          DAC_idx++;
   2154                      } while (DAC_idx > 0); /* Relies on 8 bit increment rolling over to zero. */
   2155                  }
   2156                  else 
   2157                  {
   2158                      do /* First do I channel because it is aggressor */
   2159                      {
   2160                          XCVR_BWR_DCOC_CTRL_3_TZA_DCOC_INIT_I(XCVR, DAC_idx);
   2161                          XCVR_BWR_DCOC_CTRL_3_TZA_DCOC_INIT_Q(XCVR, 0x80);
   2162                          XcvrDelay(32*2);
   2163                          
   2164                          /* Take I measurement */
   2165                          dc_meas_i = XCVR_BRD_DCOC_DC_EST_DC_EST_I(XCVR);
   2166                          dc_meas_i = dc_meas_i | ((dc_meas_i & 0x800) ? 0xF000 : 0x0);
   2167                          dc_meas_i = (dc_meas_i < 0) ? (-1*dc_meas_i) : (dc_meas_i);
   2168                          if(dc_meas_i < curr_min_dc_tza_i)
   2169                          {
   2170                              curr_min_dc_tza_i = dc_meas_i;
   2171                              curr_min_dc_tza_i_idx = DAC_idx;
   2172                          }
   2173                          DAC_idx++;
   2174                      }  while (DAC_idx > 0); /* Relies on 8 bit increment rolling over to zero. */
   2175                      DAC_idx=0;
   2176                      do /* First do Q channel */
   2177                      {
   2178                          XCVR_BWR_DCOC_CTRL_3_TZA_DCOC_INIT_I(XCVR, curr_min_dc_tza_i_idx);
   2179                          XCVR_BWR_DCOC_CTRL_3_TZA_DCOC_INIT_Q(XCVR, DAC_idx);
   2180                          XcvrDelay(32*2);
   2181                          /* Take Q measurement */
   2182                          dc_meas_q = XCVR_BRD_DCOC_DC_EST_DC_EST_Q(XCVR);
   2183                          dc_meas_q = dc_meas_q | ((dc_meas_q & 0x800) ? 0xF000 : 0x0);
   2184                          dc_meas_q = (dc_meas_q < 0) ? (-1*dc_meas_q) : (dc_meas_q);
   2185                          if(dc_meas_q < curr_min_dc_tza_q)
   2186                          {
   2187                              curr_min_dc_tza_q = dc_meas_q;
   2188                              curr_min_dc_tza_q_idx = DAC_idx;
   2189                          }
   2190                          DAC_idx++;
   2191                      }  while (DAC_idx > 0); /* relies on 8 bit increment rolling over to zero. */
   2192                  }
   2193                  /* Now set the manual TZA settings from this sweep */
   2194                  XCVR_BWR_DCOC_CTRL_3_TZA_DCOC_INIT_I(XCVR, curr_min_dc_tza_i_idx);
   2195                  XCVR_BWR_DCOC_CTRL_3_TZA_DCOC_INIT_Q(XCVR, curr_min_dc_tza_q_idx);
   2196                  curr_min_dc_tza_i_idx = (curr_min_dc_tza_i_idx >= 0x80) ? ((curr_min_dc_tza_i_idx-0x80)) : ((0x80+curr_min_dc_tza_i_idx));
   2197                  curr_min_dc_tza_q_idx = (curr_min_dc_tza_q_idx >= 0x80) ? ((curr_min_dc_tza_q_idx-0x80)) : ((0x80+curr_min_dc_tza_q_idx));
   2198                  
   2199                  /* Measure optimal BBF I DAC setting (I and Q split as there are I->Q DC changes) */
   2200                  curr_min_dc_bbf_i = curr_min_dc_tza_i;
   2201                  curr_min_dc_bbf_i_idx = 0x20;
   2202                  for (DAC_idx=0;DAC_idx<=63;DAC_idx+=1)
   2203                  {
   2204                      XCVR_BWR_DCOC_CTRL_3_BBF_DCOC_INIT_I(XCVR, DAC_idx); /* Adjust I bbf DAC */
   2205                      XCVR_BWR_DCOC_CTRL_3_BBF_DCOC_INIT_Q(XCVR, 0x20); //set bbf Q to mid
   2206                      XcvrDelay(32*2);
   2207                      dc_meas_i = XCVR_BRD_DCOC_DC_EST_DC_EST_I(XCVR);    /* Take I measurement */
   2208                      dc_meas_i = dc_meas_i | ((dc_meas_i & 0x800) ? 0xF000 : 0x0);
   2209                      dc_meas_i = (dc_meas_i < 0) ? (-1*dc_meas_i) : (dc_meas_i);
   2210                      if(dc_meas_i < curr_min_dc_bbf_i)
   2211                      {
   2212                          curr_min_dc_bbf_i = dc_meas_i;
   2213                          curr_min_dc_bbf_i_idx = DAC_idx;
   2214                      }
   2215                  }
   2216                  
   2217                  /* Measure optimal BBF Q DAC setting (I and Q split as there are I->Q DC changes) */
   2218                  curr_min_dc_bbf_q = curr_min_dc_tza_q;
   2219                  curr_min_dc_bbf_q_idx = 0x20;
   2220                  for (DAC_idx=0;DAC_idx<=63;DAC_idx+=1)
   2221                  {
   2222                      XCVR_BWR_DCOC_CTRL_3_BBF_DCOC_INIT_I(XCVR, curr_min_dc_bbf_i_idx); /* Set bbf I to calibrated value */
   2223                      XCVR_BWR_DCOC_CTRL_3_BBF_DCOC_INIT_Q(XCVR, DAC_idx);               /* Adjust bbf Q */
   2224                      XcvrDelay(32*2);
   2225                      dc_meas_q = XCVR_BRD_DCOC_DC_EST_DC_EST_Q(XCVR);  /* Take Q measurement */
   2226                      dc_meas_q = dc_meas_q | ((dc_meas_q & 0x800) ? 0xF000 : 0x0);
   2227                      XcvrDelay(32*2);
   2228                      dc_meas_q = (dc_meas_q < 0) ? (-1*dc_meas_q) : (dc_meas_q);
   2229                      if(dc_meas_q < curr_min_dc_bbf_q)
   2230                      {
   2231                          curr_min_dc_bbf_q = dc_meas_q;
   2232                          curr_min_dc_bbf_q_idx = DAC_idx;
   2233                      }
   2234                  }
   2235                  /* Now set the manual BBF Q settings from this sweep */
   2236                  XCVR_BWR_DCOC_CTRL_3_BBF_DCOC_INIT_Q(XCVR, curr_min_dc_bbf_q_idx); /* Set bbf Q to new manual value */
   2237                  XcvrDelay(32*15);
   2238                  
   2239                  dc_meas_i = XCVR_BRD_DCOC_DC_EST_DC_EST_I(XCVR); /* Take final I measurement */
   2240                  XcvrDelay(32*10);
   2241                  dc_meas_q = XCVR_BRD_DCOC_DC_EST_DC_EST_Q(XCVR); /* Take final Q measurement */
   2242                  dc_meas_q = dc_meas_q | ((dc_meas_q & 0x800) ? 0xF000 : 0x0);
   2243                  dc_meas_i = dc_meas_i | ((dc_meas_i & 0x800) ? 0xF000 : 0x0);
   2244                  XcvrDelay(32*2);
   2245                  
   2246                  /* Store this gain setting's dc dac values */
   2247                  XCVR_BWR_DCOC_OFFSET__DCOC_TZA_OFFSET_Q(XCVR, tbl_idx,curr_min_dc_tza_q_idx);
   2248                  XCVR_BWR_DCOC_OFFSET__DCOC_TZA_OFFSET_I(XCVR, tbl_idx,curr_min_dc_tza_i_idx);
   2249                  curr_min_dc_bbf_i_idx = (curr_min_dc_bbf_i_idx >= 0x20) ? ((curr_min_dc_bbf_i_idx-0x20)) : (0x20+(curr_min_dc_bbf_i_idx));
   2250                  curr_min_dc_bbf_q_idx = (curr_min_dc_bbf_q_idx >= 0x20) ? ((curr_min_dc_bbf_q_idx-0x20)) : (0x20+(curr_min_dc_bbf_q_idx));
   2251                  XCVR_BWR_DCOC_OFFSET__DCOC_BBF_OFFSET_Q(XCVR, tbl_idx,curr_min_dc_bbf_q_idx);
   2252                  XCVR_BWR_DCOC_OFFSET__DCOC_BBF_OFFSET_I(XCVR, tbl_idx,curr_min_dc_bbf_i_idx);
   2253              }
   2254              
   2255              /* Now set the manual BBF settings from this sweep */
   2256              XCVR_BWR_DCOC_CTRL_3_BBF_DCOC_INIT_I(XCVR, curr_min_dc_bbf_i_idx); /* Set bbf I to new manual value */
   2257              XCVR_BWR_DCOC_CTRL_3_BBF_DCOC_INIT_Q(XCVR, curr_min_dc_bbf_q_idx); /* Set bbf Q to new manual value */
   2258              XCVR_BWR_DCOC_CTRL_0_DCOC_TRACK_EN(XCVR, DCOC_TRACK_EN_def_c); /* Disable tracking */
   2259              XCVR_BWR_DCOC_CTRL_0_DCOC_MAN(XCVR, 0); /* Force dcoc dacs to not use manual override */
   2260              
   2261              XCVR_BWR_DCOC_CTRL_1_BBA_CORR_POL(XCVR, 1);
   2262              XCVR_BWR_DCOC_CTRL_1_TZA_CORR_POL(XCVR, 1);
   2263              XcvrForceRxWd();
   2264              XcvrDelay(200);
   2265              
   2266              /* Revert AGC settings to normal values for usage */
   2267              XCVR_BWR_AGC_CTRL_1_USER_LNM_GAIN_EN(XCVR, 0); /* Use Manual Gain for LNM */
   2268              XCVR_BWR_AGC_CTRL_1_USER_BBF_GAIN_EN(XCVR, 0); /* Use Manual Gain for BBF */
   2269              XCVR_BWR_RX_DIG_CTRL_RX_AGC_EN(XCVR, RX_AGC_EN_def_c);       /* AGC Control enabled */
   2270              XCVR_DCOC_CTRL_0 = dcoc_ctrl_0_stack; /* Restore DCOC_CTRL_0 state to prior settings */
   2271              XCVR_DCOC_CTRL_1 = dcoc_ctrl_1_stack; /* Restore DCOC_CTRL_1 state to prior settings */
   2272              XCVR_BWR_ANA_SPARE_DCOC_TRK_EST_GS_CNT(XCVR, gearshift_state); /* Restore gearshift state to prior setting */
   2273              XCVR_DCOC_CAL_GAIN = dcoc_cal_gain_state;  /* Restore DCOC_CAL_GAIN state to prior setting */
   2274              XcvrOverrideChannel(0xFF,TRUE);     /* Release channel overrides */    
   2275          }
   2276          
   2277          /*! *********************************************************************************
   2278          * \brief  IQ Mismatch Calibration. Performs IQMCalibrationIter calibrations, averages and set the calibration values in the XCVR_IQMC_CAL register
   2279          *
   2280          * \ingroup PublicAPIs
   2281          *
   2282          * \details  IQMC requires a tone input of 250 kHz (+/-75 kHz) to be applied at the RF port and RF/Ana gains set up to for a 0-5 dBm signal at ADC
   2283          *
   2284          ***********************************************************************************/
   2285          void XcvrIQMCal ( void )
   2286          {
   2287              uint8_t CH_filt_bypass_state;
   2288              uint8_t Decimator_OSR_state;
   2289              uint16_t IQMC_gain_cal_trials[IQMCalibrationTrials]={0};
   2290              uint16_t IQMC_phase_cal_trials[IQMCalibrationTrials]={0};
   2291              uint8_t cnt;
   2292              uint32_t cal_wait_time;  
   2293              uint32_t IQMC_gain_adj_sum = 0;  
   2294              uint32_t IQMC_phase_adj_sum = 0;  
   2295              uint16_t IQMC_gain_adj_mean = 0;  
   2296              uint16_t IQMC_phase_adj_mean = 0; 
   2297              
   2298              /* Read current Rx Decimation OSR Value and Channel Filter State. Set Decimation Filter OSR to 2 and Bypass Rx Channel Filter */
   2299              Decimator_OSR_state = XCVR_BRD_RX_DIG_CTRL_RX_DEC_FILT_OSR(XCVR);
   2300              CH_filt_bypass_state = XCVR_BRD_RX_DIG_CTRL_RX_CH_FILT_BYPASS(XCVR);
   2301              XCVR_BWR_RX_DIG_CTRL_RX_DEC_FILT_OSR(XCVR, 2);     /* Set Decimation OSR to 2 */
   2302              XCVR_BWR_RX_DIG_CTRL_RX_CH_FILT_BYPASS(XCVR, 1);   /* Bypass Channel Filter */
   2303              
   2304              for (cnt=0;cnt<IQMCalibrationTrials;cnt+=1)
   2305              {
   2306                  /* Set up for IQMC calibration trial */ 
   2307                  XCVR_BWR_IQMC_CAL_IQMC_GAIN_ADJ(XCVR, 0x400);          /* Set IQ gain mismatch to default (1.0) */
   2308                  XCVR_BWR_IQMC_CAL_IQMC_PHASE_ADJ(XCVR, 0x0);           /* Set IQ phase mismatch to default (0) */
   2309                  XCVR_BWR_IQMC_CTRL_IQMC_NUM_ITER(XCVR, IQMCalibrationIter);    /* Set number of iterations to compute IQMC. Default: 0x80. Max: 0xFF */
   2310                  XCVR_BWR_IQMC_CTRL_IQMC_CAL_EN(XCVR, 1);               /* Enable IQMC HW Calibration */
   2311                  
   2312                  /* Wait for IQMCalibrationIter * 13 microseconds */
   2313                  cal_wait_time = IQMCalibrationIter * 13 * 32;
   2314                  XcvrDelay(cal_wait_time);
   2315                  
   2316                  /* Read Calibration Trial Results and save in Trial Value Buffers */
   2317                  IQMC_gain_cal_trials[cnt] = XCVR_BRD_IQMC_CAL_IQMC_GAIN_ADJ(XCVR);
   2318                  IQMC_phase_cal_trials[cnt] = XCVR_BRD_IQMC_CAL_IQMC_PHASE_ADJ(XCVR);
   2319                  
   2320                  /* Compute Sum of gain/phase adjustment values */
   2321                  IQMC_gain_adj_sum = IQMC_gain_adj_sum + IQMC_gain_cal_trials[cnt] ;
   2322                  IQMC_phase_adj_sum = IQMC_phase_adj_sum + IQMC_phase_cal_trials[cnt] ;
   2323              }
   2324              
   2325              /* Average Trial Values and load in XCVR_IQMC_CAL register */
   2326              IQMC_gain_adj_mean = IQMC_gain_adj_sum/IQMCalibrationTrials;
   2327              IQMC_phase_adj_mean = IQMC_phase_adj_sum/IQMCalibrationTrials;
   2328              
   2329              XCVR_BWR_IQMC_CAL_IQMC_GAIN_ADJ(XCVR, IQMC_gain_adj_mean);     /* Set IQ gain mismatch to default (1.0) */
   2330              XCVR_BWR_IQMC_CAL_IQMC_PHASE_ADJ(XCVR, IQMC_phase_adj_mean);   /* Set IQ phase mismatch to default (0) */
   2331              
   2332              /* Restore Decimation OSR Value and Channel Filter State. */
   2333              XCVR_BWR_RX_DIG_CTRL_RX_DEC_FILT_OSR(XCVR, Decimator_OSR_state);     
   2334              XCVR_BWR_RX_DIG_CTRL_RX_CH_FILT_BYPASS(XCVR, CH_filt_bypass_state);     
   2335          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     120   XcvrCalcSetupDcoc
       120   -> __aeabi_d2iz
       120   -> __aeabi_ddiv
       120   -> __aeabi_dmul
       120   -> __aeabi_dsub
       120   -> __aeabi_f2d
       120   -> pow
       120   -> round
       120 __aeabi_cdrcmple
       8   XcvrChangeMode
         8   -> XcvrInit_ModeChg_Common
       8   XcvrDelay
       4   XcvrEnaNBRSSIMeas
       4   XcvrFadLppsControl
       0   XcvrForceRxWd
       0   XcvrForceRxWu
       0   XcvrForceTxWd
       0   XcvrForceTxWu
      12   XcvrGetFreq
        12 __aeabi_ldivmod
       0   XcvrGetXtalTrim
       4   XcvrHealthCheck
     160   XcvrIQMCal
       160   -> XcvrDelay
       160   -> __aeabi_memclr4
       8   XcvrInit
         8   -> XcvrInit_ModeChg_Common
      88   XcvrInit_ModeChg_Common
        88   -> XcvrManualDCOCCal
        88   -> XcvrPanic
        88   -> XcvrSetAnalogDef_ModeSwitch
        88   -> XcvrSetAnalogDefaults
        88   -> XcvrSetRxDigDef_ModeSwitch
        88   -> XcvrSetRxDigDefaults
        88   -> XcvrSetTsmDef_ModeSwitch
        88   -> XcvrSetTsmDefaults
        88   -> XcvrSetTxDigPLLDef_ModeSwitch
        88   -> XcvrSetTxDigPLLDefaults
        88   -> __aeabi_fdiv
        88   -> __aeabi_memcpy4
        88   -> __aeabi_ui2f
        88   -> handle_ifr
      32   XcvrManualDCOCCal
        32   -> XcvrDelay
        32   -> XcvrForceRxWd
        32   -> XcvrForceRxWu
        32   -> XcvrOverrideChannel
       8   XcvrOverrideChannel
      40   XcvrOverrideFrequency
        40   -> __aeabi_d2iz
        40   -> __aeabi_dadd
        40   -> __aeabi_ddiv
        40   -> __aeabi_dmul
        40   -> __aeabi_i2d
        40   -> __aeabi_ui2d
        40 __aeabi_cdrcmple
        40 __aeabi_uidiv
        40 __aeabi_uidivmod
      16   XcvrPanic
        16   -- Indirect call
       0   XcvrRegisterPanicCb
       4   XcvrSetAnalogDef_ModeSwitch
       8   XcvrSetAnalogDefaults
         8   -> XcvrSetAnalogDef_ModeSwitch
       0   XcvrSetGain
      16   XcvrSetRxDigDef_ModeSwitch
      32   XcvrSetRxDigDefaults
        32   -> XcvrCalcSetupDcoc
        32   -> XcvrSetRxDigDef_ModeSwitch
       8   XcvrSetTsmDef_ModeSwitch
         8   -> tsm_ll_timing_init
       8   XcvrSetTsmDefaults
         8   -> XcvrSetTsmDef_ModeSwitch
       0   XcvrSetTxDigPLLDef_ModeSwitch
       8   XcvrSetTxDigPLLDefaults
         8   -> XcvrSetTxDigPLLDef_ModeSwitch
       0   XcvrSetXtalTrim
     528   XcvrTxTest
       528   -> XcvrDelay
       528   -> XcvrForceTxWd
       528   -> XcvrForceTxWu
       528   -> XcvrGetFreq
       528   -> XcvrOverrideChannel


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable11
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_10
       4  ??DataTable15_11
       4  ??DataTable15_12
       4  ??DataTable15_13
       4  ??DataTable15_14
       4  ??DataTable15_15
       4  ??DataTable15_16
       4  ??DataTable15_17
       4  ??DataTable15_18
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_10
       8  ??DataTable22_11
       4  ??DataTable22_12
       4  ??DataTable22_13
       8  ??DataTable22_14
       4  ??DataTable22_15
       4  ??DataTable22_16
       4  ??DataTable22_17
       4  ??DataTable22_18
       4  ??DataTable22_19
       4  ??DataTable22_2
       4  ??DataTable22_20
       4  ??DataTable22_3
       4  ??DataTable22_4
       4  ??DataTable22_5
       4  ??DataTable22_6
       4  ??DataTable22_7
       4  ??DataTable22_8
       4  ??DataTable22_9
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_2
       4  ??DataTable23_3
       4  ??DataTable23_4
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_10
       4  ??DataTable24_11
       4  ??DataTable24_12
       4  ??DataTable24_13
       4  ??DataTable24_14
       4  ??DataTable24_15
       4  ??DataTable24_16
       4  ??DataTable24_17
       4  ??DataTable24_18
       4  ??DataTable24_19
       4  ??DataTable24_2
       4  ??DataTable24_20
       4  ??DataTable24_21
       4  ??DataTable24_22
       4  ??DataTable24_23
       4  ??DataTable24_24
       4  ??DataTable24_25
       4  ??DataTable24_26
       4  ??DataTable24_3
       4  ??DataTable24_4
       4  ??DataTable24_5
       4  ??DataTable24_6
       4  ??DataTable24_7
       4  ??DataTable24_8
       4  ??DataTable24_9
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_11
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_12
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_14
       4  ??DataTable5_15
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_10
       4  ??DataTable7_11
       4  ??DataTable7_12
       4  ??DataTable7_13
       4  ??DataTable7_14
       4  ??DataTable7_15
       4  ??DataTable7_16
       4  ??DataTable7_17
       4  ??DataTable7_18
       4  ??DataTable7_19
       4  ??DataTable7_2
       4  ??DataTable7_20
       4  ??DataTable7_21
       4  ??DataTable7_22
       4  ??DataTable7_23
       4  ??DataTable7_24
       4  ??DataTable7_25
       4  ??DataTable7_26
       4  ??DataTable7_27
       4  ??DataTable7_28
       4  ??DataTable7_29
       4  ??DataTable7_3
       4  ??DataTable7_30
       4  ??DataTable7_31
       4  ??DataTable7_32
       4  ??DataTable7_33
       4  ??DataTable7_34
       4  ??DataTable7_35
       4  ??DataTable7_36
       4  ??DataTable7_37
       4  ??DataTable7_38
       4  ??DataTable7_39
       4  ??DataTable7_4
       4  ??DataTable7_40
       4  ??DataTable7_41
       4  ??DataTable7_42
       4  ??DataTable7_43
       4  ??DataTable7_44
       4  ??DataTable7_45
       4  ??DataTable7_46
       4  ??DataTable7_47
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_12
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
      60  ?_0
      64  ?_1
      64  ?_2
       1  DAC_idx
       1  HWDCoffsetCal
    2884  XcvrCalcSetupDcoc
      18  XcvrChangeMode
      18  XcvrDelay
      24  XcvrEnaNBRSSIMeas
      94  XcvrFadLppsControl
       8  XcvrForceRxWd
       8  XcvrForceRxWu
      14  XcvrForceTxWd
       8  XcvrForceTxWu
      68  XcvrGetFreq
       8  XcvrGetXtalTrim
      72  XcvrHealthCheck
     214  XcvrIQMCal
      16  XcvrInit
     832  XcvrInit_ModeChg_Common
    1442  XcvrManualDCOCCal
     162  XcvrOverrideChannel
     240  XcvrOverrideFrequency
      34  XcvrPanic
      12  XcvrRegisterPanicCb
     100  XcvrSetAnalogDef_ModeSwitch
     128  XcvrSetAnalogDefaults
       6  XcvrSetGain
     112  XcvrSetRxDigDef_ModeSwitch
     204  XcvrSetRxDigDefaults
      34  XcvrSetTsmDef_ModeSwitch
     120  XcvrSetTsmDefaults
       2  XcvrSetTxDigPLLDef_ModeSwitch
      90  XcvrSetTxDigPLLDefaults
      12  XcvrSetXtalTrim
      76  XcvrTxTest
       4  adc_gain_trimmed
       1  ble_bbf_cap_tune
       1  ble_bbf_res_tune2
       1  ble_tza_cap_tune
       2  curr_min_dc_bbf_i
       1  curr_min_dc_bbf_i_idx
       2  curr_min_dc_bbf_q
       1  curr_min_dc_bbf_q_idx
       2  curr_min_dc_total
       2  curr_min_dc_tza_i
       1  curr_min_dc_tza_i_idx
       2  curr_min_dc_tza_q
       1  curr_min_dc_tza_q_idx
       2  dc_meas_i
       2  dc_meas_q
       8  gBLERxChfCoeff
       8  gPABiasTbl
       8  gZigbeeRxChfCoeff
       1  gen1_dcgain_trims_enabled
       2  ifr_version
       1  last_mode
    1024  mapTable
       1  panic_fptr_is_valid
       4  panic_function_ptr
       1  tbl_idx
       1  tbl_val
       4  tempstatus
       4  trim_status
       1  zb_bbf_cap_tune
       1  zb_bbf_res_tune2
       1  zb_tza_cap_tune

 
    35 bytes in section .bss
    14 bytes in section .data
 1 236 bytes in section .rodata
 7 932 bytes in section .text
 
 7 932 bytes of CODE  memory
 1 236 bytes of CONST memory
    49 bytes of DATA  memory

Errors: none
Warnings: none
