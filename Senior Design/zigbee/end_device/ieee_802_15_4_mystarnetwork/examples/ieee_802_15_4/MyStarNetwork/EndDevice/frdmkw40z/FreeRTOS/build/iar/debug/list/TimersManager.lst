###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       06/Apr/2016  15:58:57
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\TimersManager\Source\TimersManager.c
#    Command line =  
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\TimersManager\Source\TimersManager.c
#        -D DEBUG -D IAR -D CPU_MKW40Z160VHT4 -lcN "C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork\examples\ieee_802_15_4\MyStarNetwork\EndDevice\frdmkw40z\FreeRTOS\build\iar\debug\list"
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        "C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork\examples\ieee_802_15_4\MyStarNetwork\EndDevice\frdmkw40z\FreeRTOS\build\iar\debug\obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" --preinclude "C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork/examples/ieee_802_15_4/MyStarNetwork/EndDevice/frdmkw40z/FreeRTOS/app_preinclude.h"
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/CMSIS/Include\
#        -I "C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork/boards/frdmkw40z\"
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/devices\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/devices/MKW40Z4/include\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/devices/MKW40Z4/startup\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/system/src/clock/MKW40Z4\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/ieee_802_15_4/Source/App\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/ieee_802_15_4/Source/Mac/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/GPIOIrq\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/Keyboard/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/LED/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/SerialManager/Source/SPI_Adapter\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/Common\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/MemManager/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/Messaging/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/OSAbstraction/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/osa/inc\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/Panic/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/RNG/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/SerialManager/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/TimersManager/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/TimersManager/Source\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/FunctionLib\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/Lists\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/SecLib\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/ModuleInfo\
#        -I "C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork/examples/ieee_802_15_4/MyStarNetwork/EndDevice/common\"
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/devices\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/devices/MKW40Z4/startup\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/rtos/FreeRTOS/include\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/rtos/FreeRTOS/port/iar\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/rtos/FreeRTOS/config/KW40Z4/iar\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/ieee_802_15_4/Source/Phy/Source/MKW40Z\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/ieee_802_15_4/Source/Phy/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/XCVR/MKW40Z4\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/DCDC/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/Flash/Internal\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/drivers/src/flash/C90TFS/drvsrc/include\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/drivers/inc\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/system/inc\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/hal/inc\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/utilities/inc\
#        -On
#    List file    =  
#        C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork\examples\ieee_802_15_4\MyStarNetwork\EndDevice\frdmkw40z\FreeRTOS\build\iar\debug\list\TimersManager.lst
#    Object file  =  
#        C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork\examples\ieee_802_15_4\MyStarNetwork\EndDevice\frdmkw40z\FreeRTOS\build\iar\debug\obj\TimersManager.o
#
###############################################################################

C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\TimersManager\Source\TimersManager.c
      1          /*!
      2          * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3          * All rights reserved.
      4          *
      5          * \file TimersManager.c
      6          * TIMER implementation file for the ARM CORTEX-M4 processor
      7          *
      8          * Redistribution and use in source and binary forms, with or without modification,
      9          * are permitted provided that the following conditions are met:
     10          *
     11          * o Redistributions of source code must retain the above copyright notice, this list
     12          *   of conditions and the following disclaimer.
     13          *
     14          * o Redistributions in binary form must reproduce the above copyright notice, this
     15          *   list of conditions and the following disclaimer in the documentation and/or
     16          *   other materials provided with the distribution.
     17          *
     18          * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     19          *   contributors may be used to endorse or promote products derived from this
     20          *   software without specific prior written permission.
     21          *
     22          * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     23          * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     24          * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     25          * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     26          * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     27          * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     28          * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     29          * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     30          * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     31          * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     32          */
     33          
     34          #include "EmbeddedTypes.h"
     35          #include "TimersManagerInternal.h"
     36          #include "TimersManager.h"
     37          #include "Panic.h"
     38          #include "TMR_Adapter.h"
     39          
     40          #include "fsl_os_abstraction.h"
     41          #include "fsl_rtc_driver.h"
     42          #include "fsl_pit_driver.h"
     43          #include "fsl_clock_manager.h"
     44          #include "pin_mux.h"
     45          
     46          
     47          /*****************************************************************************
     48          ******************************************************************************
     49          * Private macros
     50          ******************************************************************************
     51          *****************************************************************************/
     52          #define mTmrDummyEvent_c (1<<16)
     53          
     54          /*! *********************************************************************************
     55          *************************************************************************************
     56          * Public memory declarations
     57          *************************************************************************************
     58          ********************************************************************************** */
     59          extern const uint8_t gUseRtos_c;
     60          
     61          /*****************************************************************************
     62           *****************************************************************************
     63           * Private prototypes
     64           *****************************************************************************
     65           *****************************************************************************/
     66          
     67          #if defined(FWK_SMALL_RAM_CONFIG)
     68          void FwkInit(void);
     69          #endif
     70          
     71          #if gTMR_Enabled_d
     72          
     73          /*---------------------------------------------------------------------------
     74           * NAME: TMR_GetTimerStatus
     75           * DESCRIPTION: RETURNs the timer status
     76           * PARAMETERS:  IN: timerID - the timer ID
     77           * RETURN: see definition of tmrStatus_t
     78           * NOTES: none
     79           *---------------------------------------------------------------------------*/
     80          static tmrStatus_t TMR_GetTimerStatus
     81          (
     82              tmrTimerID_t timerID
     83          );
     84          
     85          /*---------------------------------------------------------------------------
     86           * NAME: TMR_SetTimerStatus
     87           * DESCRIPTION: Set the timer status
     88           * PARAMETERS:  IN: timerID - the timer ID
     89           *             IN: status - the status of the timer
     90           * RETURN: None
     91           * NOTES: none
     92           *---------------------------------------------------------------------------*/
     93          static void TMR_SetTimerStatus
     94          (
     95              tmrTimerID_t timerID,
     96              tmrStatus_t status
     97          );
     98          
     99          /*---------------------------------------------------------------------------
    100           * NAME: TMR_GetTimerType
    101           * DESCRIPTION: RETURNs the timer type
    102           * PARAMETERS:  IN: timerID - the timer ID
    103           * RETURN: see definition of tmrTimerType_t
    104           * NOTES: none
    105           *---------------------------------------------------------------------------*/
    106          static tmrTimerType_t TMR_GetTimerType
    107          (
    108              tmrTimerID_t timerID
    109          );
    110          
    111          /*---------------------------------------------------------------------------
    112           * NAME: TMR_SetTimerType
    113           * DESCRIPTION: Set the timer type
    114           * PARAMETERS:  IN: timerID - the timer ID
    115           *              IN: type - timer type
    116           * RETURN: none
    117           * NOTES: none
    118           *---------------------------------------------------------------------------*/
    119          static void TMR_SetTimerType
    120          (
    121              tmrTimerID_t timerID,
    122              tmrTimerType_t type
    123          );
    124          
    125          /*---------------------------------------------------------------------------
    126           * NAME: TmrTicksFromMilliseconds
    127           * DESCRIPTION: Convert milliseconds to ticks
    128           * PARAMETERS:  IN: milliseconds
    129           * RETURN: tmrTimerTicks64_t - ticks number
    130           * NOTES: none
    131           *---------------------------------------------------------------------------*/
    132          tmrTimerTicks64_t TmrTicksFromMilliseconds
    133          (
    134              tmrTimeInMilliseconds_t milliseconds
    135          );
    136          
    137          
    138          /*---------------------------------------------------------------------------
    139           * NAME: StackTimer_ISR
    140           * DESCRIPTION: Event function called by driver ISR on channel match in interrupt context.
    141           * PARAMETERS:  IN: User data; unused.
    142           * RETURN: none
    143           * NOTES: none
    144           *---------------------------------------------------------------------------*/
    145          void StackTimer_ISR
    146          (
    147              void
    148          );
    149          
    150          /*---------------------------------------------------------------------------
    151           * NAME: TMR_Task
    152           * DESCRIPTION: Timer thread.
    153           *              Called by the kernel when the timer ISR posts a timer event.
    154           * PARAMETERS:  IN: param - User parameter to timer thread; not used.
    155           * RETURN: None
    156           * NOTES: none
    157           *---------------------------------------------------------------------------*/
    158          
    159          void TMR_Task
    160          (
    161          task_param_t param
    162          );
    163          #endif /*gTMR_Enabled_d*/
    164          
    165          #if gPrecision_Timers_Enabled_d
    166          
    167          /*---------------------------------------------------------------------------
    168           * NAME: TMR_PrecisionTimerOverflowNotify
    169           * DESCRIPTION: Event function called by driver ISR on timer overflow in interrupt context.
    170           * PARAMETERS:  IN: User data; unused.
    171           * RETURN: none
    172           * NOTES: none
    173           *---------------------------------------------------------------------------*/
    174          void TMR_PrecisionTimerOverflowNotify
    175          (
    176              LDD_TUserData *UserDataPtr
    177          );
    178          
    179          #endif /*gPrecision_Timers_Enabled_d*/
    180          
    181          #if gTimestamp_Enabled_d
    182          
    183          /*---------------------------------------------------------------------------
    184           * NAME: TMR_RTCAlarmNotify
    185           * DESCRIPTION: Event function called by driver ISR on RTC alarm in interrupt context.
    186           * PARAMETERS:  IN: User data; unused.
    187           * RETURN: none
    188           * NOTES: none
    189           *---------------------------------------------------------------------------*/
    190          void TMR_RTCAlarmNotify
    191          (
    192              void
    193          );
    194          
    195          #endif /*gTimestamp_Enabled_d*/
    196          
    197          #if gTMR_EnableHWLowPowerTimers_d
    198          void LPTMR_Notify
    199          (
    200              void
    201          );
    202          #endif
    203          
    204          /*****************************************************************************
    205           *****************************************************************************
    206           * Private memory definitions
    207           *****************************************************************************
    208           *****************************************************************************/
    209          
    210          #if gTMR_Enabled_d
    211          
    212          /*
    213           * NAME: previousTimeInTicks
    214           * DESCRIPTION: The previous time in ticks when the counter register was read
    215           * VALUES: 0..65535
    216           */
    217          static tmrTimerTicks16_t previousTimeInTicks;
    218          
    219          /*
    220           * NAME: mMaxToCountDown_c
    221           * DESCRIPTION:  Count to maximum (0xffff - 2*4ms(in ticks)), to be sure that
    222           * the currentTimeInTicks will never roll over previousTimeInTicks in the
    223           * TMR_Task(); A thread have to be executed at most in 4ms.
    224           * VALUES: 0..65535
    225           */
    226          static uint16_t mMaxToCountDown_c;
    227          
    228          /*
    229           * NAME: mTicksFor4ms
    230           * DESCRIPTION:  Ticks for 4ms. The TMR_Task()event will not be issued faster than 4ms
    231           * VALUES: uint16_t range
    232           */
    233          static uint16_t mTicksFor4ms;
    234          
    235          /*
    236           * NAME: mCounterFreqHz
    237           * DESCRIPTION:  The counter frequency in hz.
    238           * VALUES: see definition
    239           */
    240          static uint32_t mCounterFreqHz;
    241          
    242          /*
    243           * NAME: maTmrTimerTable
    244           * DESCRIPTION:  Main timer table. All allocated timers are stored here.
    245           *               A timer's ID is it's index in this table.
    246           * VALUES: see definition
    247           */
    248          static tmrTimerTableEntry_t maTmrTimerTable[gTmrTotalTimers_c];
    249          
    250          /*
    251           * NAME: maTmrTimerStatusTable
    252           * DESCRIPTION: timer status stable. Making the single-byte-per-timer status
    253           *              table a separate array saves a bit of code space.
    254           *              If an entry is == 0, the timer is not allocated.
    255           * VALUES: see definition
    256           */
    257          static tmrStatus_t maTmrTimerStatusTable[gTmrTotalTimers_c];
    258          
    259          /*
    260           * NAME: numberOfActiveTimers
    261           * DESCRIPTION: Number of Active timers (without low power capability)
    262           *              the MCU can not enter low power if numberOfActiveTimers!=0
    263           * VALUES: 0..255
    264           */
    265          static uint8_t numberOfActiveTimers = 0;
    266          
    267          /*
    268           * NAME: numberOfLowPowerActiveTimers
    269           * DESCRIPTION: Number of low power active timer.
    270           *              The MCU can enter in low power if more low power timers are active
    271           * VALUES:
    272           */
    273          static uint8_t numberOfLowPowerActiveTimers = 0;
    274          
    275          #if 0
    276          /*
    277           * NAME: PE_LDD_DeviceDataList
    278           * DESCRIPTION: Array of initialized device structures of LDD components.
    279           * VALUES:
    280           */
    281          LDD_TDeviceData *PE_LDD_DeviceDataList[] = {NULL};
    282          #endif
    283          
    284          #define IncrementActiveTimerNumber(type)  (((type) & gTmrLowPowerTimer_c) \
    285                                                    ?(++numberOfLowPowerActiveTimers) \
    286                                                    :(++numberOfActiveTimers) )
    287          #define DecrementActiveTimerNumber(type)  (((type) & gTmrLowPowerTimer_c) \
    288                                                    ?(--numberOfLowPowerActiveTimers) \
    289                                                    :(--numberOfActiveTimers) )
    290          
    291          /*
    292           * NAME: timerHardwareIsRunning
    293           * DESCRIPTION: Flag if the hardware timer is running or not
    294           * VALUES: TRUE/FALSE
    295           */
    296          static bool_t timerHardwareIsRunning = FALSE;
    297          
    298          
    299          
    300          #if defined(FWK_SMALL_RAM_CONFIG)
    301          extern event_t  gFwkCommonEvent;
    302          #define mTimerThreadEventId gFwkCommonEvent
    303          
    304          #else
    305          /*
    306           * NAME: 
    307           * DESCRIPTION: Defines the timer thread's stack
    308           * VALUES:
    309           */
    310          OSA_TASK_DEFINE( TMR, gTmrTaskStackSize_c );
    311          
    312          /*
    313           * NAME: 
    314           * DESCRIPTION: The OS threadId for TMR task.
    315           * VALUES:
    316           */
    317          static event_t        mTimerThreadEventId;
    318          #endif
    319          
    320          #if gTMR_EnableHWLowPowerTimers_d
    321          
    322          /*
    323           * NAME: previousLpTimeInTicks
    324           * DESCRIPTION: The previous time in ticks when the counter register was read
    325           * VALUES: 0..65535
    326           */
    327          tmrTimerTicks16_t previousLpTimeInTicks;
    328          
    329          /*
    330           * NAME: mLpMaxToCountDown_c
    331           * DESCRIPTION:  Count to maximum (0xffff - 2*4ms(in ticks)), to be sure that
    332           * the currentTimeInTicks will never roll over previousTimeInTicks in the
    333           * TMR_Task(); A thread have to be executed at most in 4ms.
    334           * VALUES: 0..65535
    335           */
    336          static uint16_t mLpMaxToCountDown_c;
    337          
    338          /*
    339           * NAME: mTicksFor4ms
    340           * DESCRIPTION:  Ticks for 4ms. The TMR_Task()event will not be issued faster than 4ms
    341           * VALUES: uint16_t range
    342           */
    343          static uint16_t mLpTicksFor4ms;
    344          
    345          /*
    346           * NAME: mCounterFreqHz
    347           * DESCRIPTION:  The counter frequency in hz.
    348           * VALUES: see definition
    349           */
    350          static uint32_t mLpCounterFreqHz;
    351          
    352          /*
    353           * NAME: timerHardwareIsRunning
    354           * DESCRIPTION: Flag if the hardware timer is running or not
    355           * VALUES: TRUE/FALSE
    356           */
    357          static bool_t lpTimerHardwareIsRunning = FALSE;
    358          
    359          #endif /* gTMR_EnableHWLowPowerTimers_d */
    360          
    361          #endif /*gTMR_Enabled_d*/
    362          
    363          #if gPrecision_Timers_Enabled_d
    364          
    365          /*
    366           * NAME: globalTimeTicks
    367           * DESCRIPTION: 64bit timer extension.
    368           * VALUES:
    369           */
    370          static volatile tmrTimerTicks64_t globalTimeTicks;
    371          
    372          /*
    373           * NAME: gPrecisionTimerHandle
    374           * DESCRIPTION: Hardware timer handle for precision timer
    375           * VALUES:
    376           */
    377          static LDD_TDeviceData *gPrecisionTimerHandle;
    378          
    379          /*
    380           * NAME: gPrecisionTimerTickus
    381           * DESCRIPTION: Period of the hardware timer tick for precision timer
    382           * VALUES:
    383           */
    384          static uint32_t gPrecisionTimerTickus;
    385          
    386          /*
    387           * NAME: gPrecisionTimerTickusReal
    388           * DESCRIPTION: Period of the hardware timer tick for precision timer
    389           * VALUES:
    390           */
    391          static float gPrecisionTimerTickusReal;
    392          
    393          /*
    394           * NAME: gPrecisionTimerPeriodTicks
    395           * DESCRIPTION: Period in ticks of the precision timer
    396           * VALUES:
    397           */
    398          static uint32_t gPrecisionTimerPeriodTicks;
    399          
    400          /*
    401           * NAME: PrecisionTimer_OnCounterRestart_fptr
    402           * DESCRIPTION: Function pointer for pit timer callback. Gets called from PEx Events.c
    403           * VALUES:
    404           */
    405          extern void (*PrecisionTimer_OnCounterRestart_fptr)(LDD_TUserData*);
    406          
    407          #endif
    408          
    409          #if gTimestamp_Enabled_d
    410          
    411          /*
    412           * NAME: gRTCTimeOffset
    413           * DESCRIPTION: Holds time offset in microseconds, used to calculate the date
    414           * VALUES:
    415           */
    416          static volatile uint64_t gRTCTimeOffset;
    417          
    418          /*
    419           * NAME: gRTCPrescalerOffset
    420           * DESCRIPTION: Holds time prescaler offset in ticks, used to calculate the date
    421           * VALUES:
    422           */
    423          static volatile uint16_t gRTCPrescalerOffset;
    424          
    425          /*
    426           * NAME: gRTCAlarmCallback
    427           * DESCRIPTION: Callback for the alarm.
    428           * VALUES:
    429           */
    430          static pfTmrCallBack_t gRTCAlarmCallback;
    431          
    432          /*
    433           * NAME: gRTCAlarmCallbackParam
    434           * DESCRIPTION: Parameter for the alarm callback.
    435           * VALUES:
    436           */
    437          static void *gRTCAlarmCallbackParam;
    438          
    439          #endif /*gTimestamp_Enabled_d*/
    440          
    441          
    442          #if gTMR_PIT_Timestamp_Enabled_d
    443          #if FSL_FEATURE_PIT_TIMER_COUNT < 3
    444          static uint32_t mPIT_TimestampHigh;
    445          #endif
    446          #endif
    447          
    448          /*****************************************************************************
    449          ******************************************************************************
    450          * Private functions
    451          ******************************************************************************
    452          *****************************************************************************/
    453          
    454          #if gTMR_Enabled_d
    455          
    456          /*---------------------------------------------------------------------------
    457          * NAME: TMR_GetTimerStatus
    458          * DESCRIPTION: Returns the timer status
    459          * PARAMETERS:  IN: timerID - the timer ID
    460          * RETURN: see definition of tmrStatus_t
    461          * NOTES: none
    462          *---------------------------------------------------------------------------*/
    463          static tmrStatus_t TMR_GetTimerStatus
    464          (
    465              tmrTimerID_t timerID
    466          )
    467          {
    468              return maTmrTimerStatusTable[timerID] & mTimerStatusMask_c;
    469          }
    470          
    471          /*---------------------------------------------------------------------------
    472          * NAME: TMR_SetTimerStatus
    473          * DESCRIPTION: Set the timer status
    474          * PARAMETERS:  IN: timerID - the timer ID
    475          *              IN: status - the status of the timer
    476          * RETURN: None
    477          * NOTES: none
    478          *---------------------------------------------------------------------------*/
    479          static void TMR_SetTimerStatus
    480          (
    481              tmrTimerID_t timerID,
    482              tmrStatus_t status
    483          )
    484          {
    485              maTmrTimerStatusTable[timerID] = (maTmrTimerStatusTable[timerID] & ~mTimerStatusMask_c) | status;
    486          }
    487          
    488          /*---------------------------------------------------------------------------
    489          * NAME: TMR_GetTimerType
    490          * DESCRIPTION: Returns the timer type
    491          * PARAMETERS:  IN: timerID - the timer ID
    492          * RETURN: see definition of tmrTimerType_t
    493          * NOTES: none
    494          *---------------------------------------------------------------------------*/
    495          static tmrTimerType_t TMR_GetTimerType
    496          (
    497              tmrTimerID_t timerID
    498          )
    499          {
    500              return maTmrTimerStatusTable[timerID] & mTimerType_c;
    501          }
    502          
    503          /*---------------------------------------------------------------------------
    504          * NAME: TMR_SetTimerType
    505          * DESCRIPTION: Set the timer type
    506          * PARAMETERS:  IN: timerID - the timer ID
    507          *              IN: type - timer type
    508          * RETURN: none
    509          * NOTES: none
    510          *---------------------------------------------------------------------------*/
    511          static void TMR_SetTimerType
    512          (
    513              tmrTimerID_t timerID,
    514              tmrTimerType_t type
    515          )
    516          {
    517              maTmrTimerStatusTable[timerID] = (maTmrTimerStatusTable[timerID] & ~mTimerType_c) | type;
    518          }
    519          
    520          #endif /*gTMR_Enabled_d*/
    521          
    522          #if gTimestamp_Enabled_d
    523          
    524          /*---------------------------------------------------------------------------
    525           * NAME: TMR_RTCAlarmNotify
    526           * DESCRIPTION: Event function called by driver ISR on RTC alarm in interrupt context.
    527           * PARAMETERS:  IN: User data; unused.
    528           * RETURN: none
    529           * NOTES: none
    530           *---------------------------------------------------------------------------*/
    531          void TMR_RTCAlarmNotify
    532          (
    533              void
    534          )
    535          {
    536            RTC_Type * rtcBaseAddr = g_rtcBase[gTmrRtcInstance_c];
    537          
    538            RTC_HAL_SetAlarmIntCmd(rtcBaseAddr, FALSE);
    539            RTC_HAL_SetAlarmReg(rtcBaseAddr, RTC_HAL_GetAlarmReg(rtcBaseAddr));
    540            
    541            if( gRTCAlarmCallback != NULL )
    542            {
    543              gRTCAlarmCallback(gRTCAlarmCallbackParam);
    544            }
    545          }
    546          
    547          #endif /*gTimestamp_Enabled_d*/
    548          
    549          
    550          #if (gTMR_PIT_Timestamp_Enabled_d)
    551          #if FSL_FEATURE_PIT_TIMER_COUNT < 3
    552          
    553          static void TMR_PIT_ISR(void)
    554          {
    555              PIT_HAL_ClearIntFlag(g_pitBase[gTmrPitInstance_c], 1);
    556              mPIT_TimestampHigh--;
    557          }
    558          
    559          #endif
    560          #endif
    561          
    562          /*****************************************************************************
    563          ******************************************************************************
    564          * Public functions
    565          ******************************************************************************
    566          *****************************************************************************/
    567          
    568          #if gTMR_Enabled_d
    569          /*---------------------------------------------------------------------------
    570           * NAME: TmrTicksFromMilliseconds
    571           * DESCRIPTION: Convert milliseconds to ticks
    572           * PARAMETERS:  IN: milliseconds
    573           * RETURN: tmrTimerTicks64_t - ticks number
    574           * NOTES: none
    575           *---------------------------------------------------------------------------*/
    576          tmrTimerTicks64_t TmrTicksFromMilliseconds
    577          (
    578              tmrTimeInMilliseconds_t milliseconds
    579          )
    580          {
    581            return (tmrTimerTicks64_t)milliseconds * mCounterFreqHz / 1000;
    582          }
    583          
    584          #if gTMR_EnableHWLowPowerTimers_d
    585          /*---------------------------------------------------------------------------
    586           * NAME: LptmrTicksFromMilliseconds
    587           * DESCRIPTION: Convert milliseconds to ticks
    588           * PARAMETERS:  IN: milliseconds
    589           * RETURN: tmrTimerTicks64_t - ticks number
    590           * NOTES: none
    591           *---------------------------------------------------------------------------*/
    592          tmrTimerTicks64_t LptmrTicksFromMilliseconds
    593          (
    594              tmrTimeInMilliseconds_t milliseconds
    595          )
    596          {
    597              return (tmrTimerTicks64_t)milliseconds * mLpCounterFreqHz / 1000;
    598          }
    599          
    600          /*---------------------------------------------------------------------------
    601           * NAME: LPTMR_Notify
    602           * DESCRIPTION: Event function called by driver ISR on compare match in interrupt context.
    603           * PARAMETERS: none
    604           * RETURN: none
    605           * NOTES: none
    606           *---------------------------------------------------------------------------*/
    607          void LPTMR_Notify(void)
    608          {
    609              (void)OSA_EventSet(&mTimerThreadEventId, mTmrDummyEvent_c);
    610          }
    611          #endif
    612          
    613          /*---------------------------------------------------------------------------
    614           * NAME: TMR_Init
    615           * DESCRIPTION: initialize the timer module
    616           * PARAMETERS: -
    617           * RETURN: -
    618           *---------------------------------------------------------------------------*/
    619          void TMR_Init
    620          (
    621              void
    622          )
    623          {
    624          	static uint8_t initialized = FALSE;
    625          
    626              /* Check if TMR is already initialized */
    627              if( initialized )
    628                  return;
    629              
    630              initialized = TRUE;
    631           
    632              StackTimer_Init(StackTimer_ISR);
    633              mCounterFreqHz = (uint32_t)((StackTimer_GetInputFrequency()));
    634          
    635              /* Count to maximum (0xffff - 2*4ms(in ticks)), to be sure that the currentTimeInTicks
    636              will never roll over previousTimeInTicks in the TMR_Task() */
    637              mMaxToCountDown_c = 0xFFFF - TmrTicksFromMilliseconds(8);
    638              /* The TMR_Task()event will not be issued faster than 4ms*/
    639              mTicksFor4ms = TmrTicksFromMilliseconds(4);
    640          
    641          #if gTMR_EnableHWLowPowerTimers_d
    642              LPTMR_Init(LPTMR_Notify);
    643              mLpCounterFreqHz = LPTMR_GetInputFrequency();
    644              mLpTicksFor4ms = LptmrTicksFromMilliseconds(4);
    645              mLpMaxToCountDown_c = 0xFFFF - (2*mLpTicksFor4ms);
    646          #endif
    647          
    648          #if defined(FWK_SMALL_RAM_CONFIG)
    649              FwkInit();
    650          #else
    651              osa_status_t status;
    652              task_handler_t timerThreadId;    
    653              
    654              status = OSA_EventCreate( &mTimerThreadEventId, kEventAutoClear);
    655              if( kStatus_OSA_Success != status )
    656              {
    657                  panic( 0, (uint32_t)TMR_Init, 0, 0 );
    658                  return;
    659              }
    660          
    661              status = OSA_TaskCreate(TMR_Task, "TMR_Task", gTmrTaskStackSize_c, TMR_stack,
    662                                      gTmrTaskPriority_c, (task_param_t)NULL, FALSE, &timerThreadId);
    663          
    664              if( kStatus_OSA_Success != status )
    665              {
    666                  panic( 0, (uint32_t)TMR_Init, 0, 0 );
    667                  return;
    668              }
    669          #endif
    670          }
    671          
    672          /*---------------------------------------------------------------------------
    673           * NAME: TMR_NotifyClkChanged
    674           * DESCRIPTION: This function is called when the clock is changed
    675           * PARAMETERS: IN: clkKhz (uint32_t) - new clock
    676           * RETURN: -
    677           *---------------------------------------------------------------------------*/
    678          void TMR_NotifyClkChanged
    679          (
    680              uint32_t clkKhz
    681          )
    682          {
    683              (void)clkKhz;
    684              mCounterFreqHz = (uint32_t)((StackTimer_GetInputFrequency()));
    685              /* Clock was changed, so calculate again  mMaxToCountDown_c.
    686              Count to maximum (0xffff - 2*4ms(in ticks)), to be sure that the currentTimeInTicks
    687              will never roll over previousTimeInTicks in the TMR_Task() */
    688              mMaxToCountDown_c = 0xFFFF - TmrTicksFromMilliseconds(8);
    689              /* The TMR_Task()event will not be issued faster than 4ms*/
    690              mTicksFor4ms = TmrTicksFromMilliseconds(4);
    691          #if gTMR_EnableHWLowPowerTimers_d
    692              mLpCounterFreqHz = LPTMR_GetInputFrequency();
    693              mLpTicksFor4ms = LptmrTicksFromMilliseconds(4);
    694              mLpMaxToCountDown_c = 0xFFFF - (2*mLpTicksFor4ms);
    695          #endif
    696          }
    697          
    698          /*---------------------------------------------------------------------------
    699           * NAME: TMR_AllocateTimer
    700           * DESCRIPTION: allocate a timer
    701           * PARAMETERS: -
    702           * RETURN: timer ID
    703           *---------------------------------------------------------------------------*/
    704          tmrTimerID_t TMR_AllocateTimer
    705          (
    706              void
    707          )
    708          {
    709              uint32_t i;
    710          
    711              for (i = 0; i < NumberOfElements(maTmrTimerTable); ++i)
    712              {
    713                  if (!TMR_IsTimerAllocated(i))
    714                  {
    715                      TMR_SetTimerStatus(i, mTmrStatusInactive_c);
    716                      return i;
    717                  }
    718             }
    719          
    720             return gTmrInvalidTimerID_c;
    721          }
    722          
    723          /*---------------------------------------------------------------------------
    724           * NAME: TMR_AreAllTimersOff
    725           * DESCRIPTION: Check if all timers except the LP timers are OFF.
    726           * PARAMETERS: -
    727           * RETURN: TRUE if there are no active non-low power timers, FALSE otherwise
    728           *---------------------------------------------------------------------------*/
    729          bool_t TMR_AreAllTimersOff
    730          (
    731              void
    732          )
    733          {
    734              return !numberOfActiveTimers;
    735          }
    736          
    737          /*---------------------------------------------------------------------------
    738           * NAME: TMR_FreeTimer
    739           * DESCRIPTION: Free a timer
    740           * PARAMETERS:  IN: timerID - the ID of the timer
    741           * RETURN: -
    742           * NOTES: Safe to call even if the timer is running.
    743           *        Harmless if the timer is already free.
    744           *---------------------------------------------------------------------------*/
    745          tmrErrCode_t TMR_FreeTimer
    746          (
    747              tmrTimerID_t timerID
    748          )
    749          {
    750              tmrErrCode_t status;
    751          
    752              status = TMR_StopTimer(timerID);
    753          
    754              if( status == gTmrSuccess_c )
    755              {
    756                  TMR_MarkTimerFree(timerID);
    757              }
    758          
    759              return gTmrSuccess_c;
    760          }
    761          
    762          /*---------------------------------------------------------------------------
    763           * NAME: StackTimer_OnChannel0_Notify
    764           * DESCRIPTION: Event function called by driver ISR on channel match in interrupt context.
    765           * PARAMETERS:  IN: User data; unused.
    766           * RETURN: none
    767           * NOTES: none
    768           *---------------------------------------------------------------------------*/
    769          void StackTimer_ISR(void)
    770          {
    771              StackTimer_ClearIntFlag();
    772              (void)OSA_EventSet(&mTimerThreadEventId, mTmrDummyEvent_c);
    773          }
    774          
    775          /*---------------------------------------------------------------------------
    776           * NAME: TMR_IsTimerActive
    777           * DESCRIPTION: Check if a specified timer is active
    778           * PARAMETERS: IN: timerID - the ID of the timer
    779           * RETURN: TRUE if the timer (specified by the timerID) is active,
    780           *         FALSE otherwise
    781           *---------------------------------------------------------------------------*/
    782          bool_t TMR_IsTimerActive
    783          (
    784              tmrTimerID_t timerID
    785          )
    786          {
    787              return TMR_GetTimerStatus(timerID) == mTmrStatusActive_c;
    788          }
    789          
    790          /*---------------------------------------------------------------------------
    791           * NAME: TMR_IsTimerReady
    792           * DESCRIPTION: Check if a specified timer is ready
    793           * PARAMETERS: IN: timerID - the ID of the timer
    794           * RETURN: TRUE if the timer (specified by the timerID) is ready,
    795           *         FALSE otherwise
    796           *---------------------------------------------------------------------------*/
    797          bool_t TMR_IsTimerReady
    798          (
    799              tmrTimerID_t timerID
    800          )
    801          {
    802              return TMR_GetTimerStatus(timerID) == mTmrStatusReady_c;
    803          }
    804          
    805          /*---------------------------------------------------------------------------
    806           * NAME: TMR_GetRemainingTime
    807           * DESCRIPTION: Returns the remaining time until timeout, for the specified
    808           *              timer
    809           * PARAMETERS: IN: timerID - the ID of the timer
    810           * RETURN: remaining time in milliseconds until next timer timeout
    811           *---------------------------------------------------------------------------*/
    812          uint32_t TMR_GetRemainingTime
    813          (
    814              tmrTimerID_t tmrID
    815          )
    816          {
    817            tmrTimerTicks16_t currentTime, elapsedRemainingTicks;
    818            uint32_t remainingTime, freq = mCounterFreqHz;
    819          
    820            if( (tmrID >= gTmrTotalTimers_c) || 
    821                !TMR_IsTimerAllocated(tmrID) ||
    822                (maTmrTimerTable[tmrID].remainingTicks == 0) )
    823                return 0;
    824          
    825            TmrIntDisableAll();
    826          
    827          #if gTMR_EnableHWLowPowerTimers_d
    828            if( IsLowPowerTimer(TMR_GetTimerType(tmrID)) )
    829            {
    830                currentTime = LPTMR_GetCounterValue();
    831                freq = mLpCounterFreqHz;
    832            }
    833            else
    834          #endif
    835            {
    836                currentTime = StackTimer_GetCounterValue();
    837            }
    838          
    839            if(currentTime < maTmrTimerTable[tmrID].timestamp)
    840            {
    841                currentTime += 0xFFFF;
    842            }
    843          
    844            elapsedRemainingTicks = currentTime - maTmrTimerTable[tmrID].timestamp;
    845          
    846            if(elapsedRemainingTicks > maTmrTimerTable[tmrID].remainingTicks)
    847            {
    848                TmrIntRestoreAll();
    849                return 1;
    850            }
    851          
    852            remainingTime = ((uint64_t)(maTmrTimerTable[tmrID].remainingTicks - elapsedRemainingTicks) * 1000 + freq - 1) / freq;
    853          
    854            TmrIntRestoreAll();
    855            return remainingTime;
    856          }
    857          
    858          
    859          /*---------------------------------------------------------------------------
    860           * NAME: TMR_StartTimer (BeeStack or application)
    861           * DESCRIPTION: Start a specified timer
    862           * PARAMETERS: IN: timerId - the ID of the timer
    863           *             IN: timerType - the type of the timer
    864           *             IN: timeInMilliseconds - time expressed in millisecond units
    865           *             IN: pfTmrCallBack - callback function
    866           *             IN: param - parameter to callback function
    867           * RETURN: -
    868           * NOTES: When the timer expires, the callback function is called in
    869           *        non-interrupt context. If the timer is already running when
    870           *        this function is called, it will be stopped and restarted.
    871           *---------------------------------------------------------------------------*/
    872          tmrErrCode_t TMR_StartTimer
    873          (
    874              tmrTimerID_t timerID,
    875              tmrTimerType_t timerType,
    876              tmrTimeInMilliseconds_t timeInMilliseconds,
    877              void (*pfTimerCallBack)(void *),
    878              void *param
    879          )
    880          {
    881              tmrErrCode_t status;
    882              tmrTimerTicks64_t intervalInTicks;
    883          
    884              /* Stopping an already stopped timer is harmless. */
    885              status = TMR_StopTimer(timerID);
    886          
    887              if( status == gTmrSuccess_c )
    888              {
    889          #if gTMR_EnableHWLowPowerTimers_d
    890                  if( IsLowPowerTimer(timerType) )
    891                  {
    892                      intervalInTicks = LptmrTicksFromMilliseconds(timeInMilliseconds);
    893                      maTmrTimerTable[timerID].timestamp = LPTMR_GetCounterValue();
    894                  }
    895                  else
    896          #endif
    897                  {
    898                      intervalInTicks = TmrTicksFromMilliseconds(timeInMilliseconds);
    899                      maTmrTimerTable[timerID].timestamp = StackTimer_GetCounterValue();
    900                  }
    901                  
    902                  if( !intervalInTicks )
    903                  {
    904                      intervalInTicks = 1;
    905                  }
    906                  
    907                  TMR_SetTimerType(timerID, timerType);
    908                  maTmrTimerTable[timerID].intervalInTicks = intervalInTicks;
    909                  maTmrTimerTable[timerID].remainingTicks = intervalInTicks;
    910                  maTmrTimerTable[timerID].pfCallBack = pfTimerCallBack;
    911                  maTmrTimerTable[timerID].param = param;
    912                  
    913                  /* Enable timer, the timer thread will do the rest of the work. */
    914                  TMR_EnableTimer(timerID);
    915              }
    916          
    917              return status;
    918          }
    919          
    920          /*---------------------------------------------------------------------------
    921           * NAME: TMR_StartLowPowerTimer
    922           * DESCRIPTION: Start a low power timer. When the timer goes off, call the
    923           *              callback function in non-interrupt context.
    924           *              If the timer is running when this function is called, it will
    925           *              be stopped and restarted.
    926           *              Start the timer with the following timer types:
    927           *                          - gTmrLowPowerMinuteTimer_c
    928           *                          - gTmrLowPowerSecondTimer_c
    929           *                          - gTmrLowPowerSingleShotMillisTimer_c
    930           *                          - gTmrLowPowerIntervalMillisTimer_c
    931           *              The MCU can enter in low power if there are only active low
    932           *              power timers.
    933           * PARAMETERS: IN: timerId - the ID of the timer
    934           *             IN: timerType - the type of the timer
    935           *             IN: timeIn - time in ticks
    936           *             IN: pfTmrCallBack - callback function
    937           *             IN: param - parameter to callback function
    938           * RETURN: type/DESCRIPTION
    939           *---------------------------------------------------------------------------*/
    940          tmrErrCode_t TMR_StartLowPowerTimer
    941          (
    942              tmrTimerID_t timerId,
    943              tmrTimerType_t timerType,
    944              uint32_t timeIn,
    945              void (*pfTmrCallBack)(void *),
    946              void *param
    947          )
    948          {
    949          #if(gTMR_EnableLowPowerTimers_d)
    950              return TMR_StartTimer(timerId, timerType | gTmrLowPowerTimer_c, timeIn, pfTmrCallBack, param);
    951          #else
    952              timerId = timerId;
    953              timerType = timerType;
    954              timeIn = timeIn;
    955              pfTmrCallBack = pfTmrCallBack;
    956              param = param;
    957              return gTmrSuccess_c;
    958          #endif
    959          }
    960          
    961          /*---------------------------------------------------------------------------
    962           * NAME: TMR_StartMinuteTimer
    963           * DESCRIPTION: Starts a minutes timer
    964           * PARAMETERS:  IN: timerId - the ID of the timer
    965           *              IN: timeInMinutes - time expressed in minutes
    966           *              IN: pfTmrCallBack - callback function
    967           *              IN: param - parameter to callback function
    968           * RETURN: None
    969           * NOTES: Customized form of TMR_StartTimer(). This is a single shot timer.
    970           *        There are no interval minute timers.
    971           *---------------------------------------------------------------------------*/
    972          #if gTMR_EnableMinutesSecondsTimers_d
    973          tmrErrCode_t TMR_StartMinuteTimer
    974          (
    975              tmrTimerID_t timerId,
    976              tmrTimeInMinutes_t timeInMinutes,
    977              void (*pfTmrCallBack)(void *),
    978              void *param
    979          )
    980          {
    981              return TMR_StartTimer(timerId, gTmrMinuteTimer_c, TmrMinutes(timeInMinutes), pfTmrCallBack, param);
    982          }
    983          #endif
    984          
    985          /*---------------------------------------------------------------------------
    986           * NAME: TMR_StartSecondTimer
    987           * DESCRIPTION: Starts a seconds timer
    988           * PARAMETERS:  IN: timerId - the ID of the timer
    989           *              IN: timeInSeconds - time expressed in seconds
    990           *              IN: pfTmrCallBack - callback function
    991           * RETURN: None
    992           * NOTES: Customized form of TMR_StartTimer(). This is a single shot timer.
    993           *        There are no interval seconds timers.
    994           *---------------------------------------------------------------------------*/
    995          #if gTMR_EnableMinutesSecondsTimers_d
    996          tmrErrCode_t TMR_StartSecondTimer
    997          (
    998              tmrTimerID_t timerId,
    999              tmrTimeInSeconds_t timeInSeconds,
   1000              void (*pfTmrCallBack)(void *),
   1001              void *argument
   1002          )
   1003          {
   1004              return TMR_StartTimer(timerId, gTmrSecondTimer_c, TmrSeconds(timeInSeconds), pfTmrCallBack, argument);
   1005          }
   1006          #endif
   1007          
   1008          /*---------------------------------------------------------------------------
   1009           * NAME: TMR_StartIntervalTimer
   1010           * DESCRIPTION: Starts an interval count timer
   1011           * PARAMETERS:  IN: timerId - the ID of the timer
   1012           *              IN: timeInMilliseconds - time expressed in milliseconds
   1013           *              IN: pfTmrCallBack - callback function
   1014           *              IN: param - parameter to callback function
   1015           * RETURN: None
   1016           * NOTES: Customized form of TMR_StartTimer()
   1017           *---------------------------------------------------------------------------*/
   1018          tmrErrCode_t TMR_StartIntervalTimer
   1019          (
   1020              tmrTimerID_t timerID,
   1021              tmrTimeInMilliseconds_t timeInMilliseconds,
   1022              void (*pfTimerCallBack)(void *),
   1023              void *param
   1024          )
   1025          {
   1026              return TMR_StartTimer(timerID, gTmrIntervalTimer_c, timeInMilliseconds, pfTimerCallBack, param);
   1027          }
   1028          
   1029          /*---------------------------------------------------------------------------
   1030           * NAME: TMR_StartSingleShotTimer
   1031           * DESCRIPTION: Starts an single-shot timer
   1032           * PARAMETERS:  IN: timerId - the ID of the timer
   1033           *              IN: timeInMilliseconds - time expressed in milliseconds
   1034           *              IN: pfTmrCallBack - callback function
   1035           *              IN: param - parameter to callback function
   1036           * RETURN: None
   1037           * NOTES: Customized form of TMR_StartTimer()
   1038           *---------------------------------------------------------------------------*/
   1039          tmrErrCode_t TMR_StartSingleShotTimer
   1040          (
   1041              tmrTimerID_t timerID,
   1042              tmrTimeInMilliseconds_t timeInMilliseconds,
   1043              void (*pfTimerCallBack)(void *),
   1044              void *param
   1045          )
   1046          {
   1047              return TMR_StartTimer(timerID, gTmrSingleShotTimer_c, timeInMilliseconds, pfTimerCallBack, param);
   1048          }
   1049          
   1050          /*---------------------------------------------------------------------------
   1051           * NAME: TMR_StopTimer
   1052           * DESCRIPTION: Stop a timer
   1053           * PARAMETERS:  IN: timerID - the ID of the timer
   1054           * RETURN: None
   1055           * NOTES: Associated timer callback function is not called, even if the timer
   1056           *        expires. Does not frees the timer. Safe to call anytime, regardless
   1057           *        of the state of the timer.
   1058           *---------------------------------------------------------------------------*/
   1059          tmrErrCode_t TMR_StopTimer
   1060          (
   1061              tmrTimerID_t timerID
   1062          )
   1063          {
   1064              tmrStatus_t status;
   1065          	
   1066              /* check if timer is not allocated or if it has an invalid ID (fix@ENGR00323423) */
   1067              if( (timerID >= gTmrTotalTimers_c) || !TMR_IsTimerAllocated(timerID) )
   1068                  return gTmrInvalidId_c;
   1069          
   1070              TmrIntDisableAll();
   1071              status = TMR_GetTimerStatus(timerID);
   1072          
   1073              if ( (status == mTmrStatusActive_c) || (status == mTmrStatusReady_c) )
   1074              {
   1075                  TMR_SetTimerStatus(timerID, mTmrStatusInactive_c);
   1076                  DecrementActiveTimerNumber(TMR_GetTimerType(timerID));
   1077                  /* if no sw active timers are enabled, */
   1078                  /* call the TMR_Task() to countdown the ticks and stop the hw timer*/
   1079                  if (!numberOfActiveTimers && !numberOfLowPowerActiveTimers)
   1080                  {
   1081                    (void)OSA_EventSet(&mTimerThreadEventId, mTmrDummyEvent_c);
   1082                  }
   1083                  
   1084              }
   1085          
   1086              TmrIntRestoreAll();
   1087              return gTmrSuccess_c;
   1088          }
   1089          
   1090          /*---------------------------------------------------------------------------
   1091           * NAME: TMR_Task
   1092           * DESCRIPTION: Timer thread.
   1093           *              Called by the kernel when the timer ISR posts a timer event.
   1094           * PARAMETERS:  IN: events - timer events mask
   1095           * RETURN: None
   1096           * NOTES: none
   1097           *---------------------------------------------------------------------------*/
   1098          void TMR_Task
   1099          (
   1100              task_param_t param
   1101          )
   1102          {
   1103              tmrTimerTicks16_t nextInterruptTime;
   1104              tmrTimerTicks16_t currentTimeInTicks;
   1105              tmrTimerTicks16_t ticksSinceLastHere, ticksdiff;
   1106              pfTmrCallBack_t   pfCallBack;
   1107              tmrTimerType_t    timerType;
   1108              tmrTimerStatus_t  status;
   1109              uint8_t timerID;
   1110          #if gTMR_EnableHWLowPowerTimers_d
   1111              tmrTimerTicks16_t currentLpTimeInTicks;
   1112              tmrTimerTicks16_t lpTicksSinceLastHere;
   1113              tmrTimerTicks16_t nextLpInterruptTime;
   1114          #endif
   1115          
   1116              (void)param;
   1117          
   1118          #if defined(FWK_SMALL_RAM_CONFIG)
   1119              {
   1120          #else
   1121              event_flags_t     ev;
   1122              
   1123              while(1)
   1124              {
   1125                  (void)OSA_EventWait(&mTimerThreadEventId, 0x00FFFFFF, FALSE,OSA_WAIT_FOREVER, &ev);
   1126          #endif
   1127                  TmrIntDisableAll();
   1128          
   1129                  currentTimeInTicks = StackTimer_GetCounterValue();
   1130          #if gTMR_EnableHWLowPowerTimers_d
   1131                  currentLpTimeInTicks = LPTMR_GetCounterValue();
   1132          #endif
   1133          
   1134                  TmrIntRestoreAll();
   1135          
   1136                  /* calculate difference between current and previous.  */
   1137                  ticksSinceLastHere = (currentTimeInTicks - previousTimeInTicks);
   1138                  /* remember for next time */
   1139                  previousTimeInTicks = currentTimeInTicks;
   1140                  /* Find the shortest active timer. */
   1141                  nextInterruptTime = mMaxToCountDown_c;
   1142          
   1143          #if gTMR_EnableHWLowPowerTimers_d
   1144                  nextLpInterruptTime   = mLpMaxToCountDown_c;
   1145                  lpTicksSinceLastHere  = currentLpTimeInTicks - previousLpTimeInTicks;
   1146                  previousLpTimeInTicks = currentLpTimeInTicks;
   1147          #endif
   1148                  
   1149          
   1150                  for (timerID = 0; timerID < NumberOfElements(maTmrTimerTable); ++timerID)
   1151                  {
   1152                      timerType = TMR_GetTimerType(timerID);
   1153          
   1154                      TmrIntDisableAll();
   1155                      status = TMR_GetTimerStatus(timerID);
   1156                      /* If TMR_StartTimer() has been called for this timer, start it's count */
   1157                      /* down as of now. */
   1158                      if( status == mTmrStatusReady_c )
   1159                      {
   1160                          TMR_SetTimerStatus(timerID, mTmrStatusActive_c);
   1161                          TmrIntRestoreAll();
   1162          #if gTMR_EnableHWLowPowerTimers_d
   1163                          if( IsLowPowerTimer(timerType) )
   1164                          {
   1165                              if( nextLpInterruptTime > maTmrTimerTable[timerID].remainingTicks )
   1166                              {
   1167                                  nextLpInterruptTime = maTmrTimerTable[timerID].remainingTicks;
   1168                              }
   1169                          }
   1170                          else
   1171          #endif
   1172                          if (nextInterruptTime > maTmrTimerTable[timerID].remainingTicks)
   1173                          {
   1174                              nextInterruptTime = maTmrTimerTable[timerID].remainingTicks;
   1175                          }                
   1176                          continue;
   1177                      }
   1178                      TmrIntRestoreAll();
   1179          
   1180                      /* Ignore any timer that is not active. */
   1181                      if (status != mTmrStatusActive_c)
   1182                      {
   1183                          continue;
   1184                      }
   1185          
   1186                      /* This timer is active. Decrement it's countdown.. */
   1187          #if gTMR_EnableHWLowPowerTimers_d
   1188                      if( IsLowPowerTimer(timerType) )
   1189                      {
   1190                          if(maTmrTimerTable[timerID].remainingTicks > lpTicksSinceLastHere)
   1191                          {
   1192                              TmrIntDisableAll();
   1193                              maTmrTimerTable[timerID].remainingTicks -= lpTicksSinceLastHere;
   1194                              maTmrTimerTable[timerID].timestamp = LPTMR_GetCounterValue();
   1195                              TmrIntRestoreAll();
   1196          
   1197                              if( nextLpInterruptTime > maTmrTimerTable[timerID].remainingTicks )
   1198                              {
   1199                                  nextLpInterruptTime = maTmrTimerTable[timerID].remainingTicks;
   1200                              }
   1201                              continue;
   1202                          }
   1203                      }
   1204                      else
   1205          #endif
   1206                      if (maTmrTimerTable[timerID].remainingTicks > ticksSinceLastHere)
   1207                      {
   1208                          TmrIntDisableAll();
   1209                          maTmrTimerTable[timerID].remainingTicks -= ticksSinceLastHere;
   1210                          maTmrTimerTable[timerID].timestamp = StackTimer_GetCounterValue();
   1211                          TmrIntRestoreAll();
   1212          
   1213                          if (nextInterruptTime > maTmrTimerTable[timerID].remainingTicks)
   1214                          {
   1215                              nextInterruptTime = maTmrTimerTable[timerID].remainingTicks;
   1216                          }
   1217                          continue;
   1218                      }
   1219          
   1220                      /* If this is an interval timer, restart it. Otherwise, mark it as inactive. */
   1221                      if ( (timerType & gTmrSingleShotTimer_c) ||
   1222                           (timerType & gTmrSetMinuteTimer_c)  ||
   1223                           (timerType & gTmrSetSecondTimer_c)  )
   1224                      {
   1225                          maTmrTimerTable[timerID].remainingTicks = 0;
   1226                          (void)TMR_StopTimer(timerID);
   1227                      }
   1228                      else
   1229                      {
   1230                          TmrIntDisableAll();
   1231          #if gTMR_EnableHWLowPowerTimers_d
   1232                          if( IsLowPowerTimer(timerType) )
   1233                          {
   1234                              maTmrTimerTable[timerID].remainingTicks = maTmrTimerTable[timerID].intervalInTicks;
   1235                              maTmrTimerTable[timerID].timestamp = LPTMR_GetCounterValue();
   1236                              if( nextLpInterruptTime > maTmrTimerTable[timerID].remainingTicks )
   1237                              {
   1238                                  nextLpInterruptTime = maTmrTimerTable[timerID].remainingTicks;
   1239                              }
   1240                          }
   1241                          else
   1242          #endif
   1243                          {
   1244                              maTmrTimerTable[timerID].remainingTicks = maTmrTimerTable[timerID].intervalInTicks;
   1245                              maTmrTimerTable[timerID].timestamp = StackTimer_GetCounterValue();
   1246                              if (nextInterruptTime > maTmrTimerTable[timerID].remainingTicks)
   1247                              {
   1248                                  nextInterruptTime = maTmrTimerTable[timerID].remainingTicks;
   1249                              }
   1250                          }
   1251                          TmrIntRestoreAll();
   1252                      }
   1253                      /* This timer has expired. */
   1254                      pfCallBack = maTmrTimerTable[timerID].pfCallBack;
   1255                      /*Call callback if it is not NULL
   1256                      This is done after the timer got updated,
   1257                      in case the timer gets stopped or restarted in the callback*/
   1258                      if (pfCallBack)
   1259                      {
   1260                          pfCallBack(maTmrTimerTable[timerID].param);
   1261                      }
   1262                  }  /* for (timerID = 0; timerID < ... */
   1263          
   1264                  TmrIntDisableAll();
   1265          
   1266                  /* Check to be sure that the timer was not programmed in the past for different source clocks.
   1267                   * The interrupts are now disabled.
   1268                   */
   1269                  ticksdiff = StackTimer_GetCounterValue();
   1270          
   1271                  /* Number of ticks to be here */
   1272                  ticksdiff = (uint16_t)(ticksdiff - currentTimeInTicks);
   1273          
   1274                  /* Next ticks to count already expired?? */
   1275                  if(ticksdiff >= nextInterruptTime)
   1276                  {
   1277                      /* Is assumed that a thread has to be executed in 4ms...
   1278                  so if the ticks already expired enter in TMR_Task() after 4ms*/
   1279                      nextInterruptTime = ticksdiff + mTicksFor4ms;
   1280                  }
   1281                  else
   1282                  {
   1283                      /* Time reference is 4ms, so be sure that won't be loaded
   1284                         in Cmp Reg. less that 4ms in ticks */
   1285                      if((nextInterruptTime - ticksdiff) < mTicksFor4ms)
   1286                      {
   1287                          nextInterruptTime = ticksdiff + mTicksFor4ms;
   1288                      }
   1289                  }
   1290                  /* Update the compare register */
   1291                  nextInterruptTime += currentTimeInTicks;
   1292          
   1293                  if( numberOfActiveTimers
   1294          #if (!gTMR_EnableHWLowPowerTimers_d)
   1295                     || numberOfLowPowerActiveTimers
   1296          #endif
   1297                    ) /*not about to stop*/
   1298                  {
   1299                    /*Causes a bug with flex timers if CxV is set before hw timer switches off*/
   1300                    StackTimer_SetOffsetTicks(nextInterruptTime);
   1301                    if (!timerHardwareIsRunning)
   1302                    {
   1303                        StackTimer_Enable();
   1304                        timerHardwareIsRunning = TRUE;
   1305                    }
   1306                  }
   1307                  else if( timerHardwareIsRunning )
   1308                  {
   1309                      StackTimer_Disable();
   1310                      timerHardwareIsRunning = FALSE;
   1311                  }
   1312                      
   1313          #if gTMR_EnableHWLowPowerTimers_d
   1314                  ticksdiff = LPTMR_GetCounterValue();
   1315                  ticksdiff = (uint16_t)(ticksdiff - currentLpTimeInTicks);
   1316                  if(ticksdiff >= nextLpInterruptTime)
   1317                  {
   1318                      nextLpInterruptTime = ticksdiff + mLpTicksFor4ms;
   1319                  }
   1320                  else
   1321                  {
   1322                      if((nextLpInterruptTime - ticksdiff) < mLpTicksFor4ms)
   1323                      {
   1324                          nextLpInterruptTime = ticksdiff + mLpTicksFor4ms;
   1325                      }
   1326                  }
   1327                  /* Update the compare register */
   1328                  nextLpInterruptTime += currentLpTimeInTicks;
   1329          
   1330                  if( numberOfLowPowerActiveTimers ) /*not about to stop*/
   1331                  {
   1332                      LPTMR_SetOffsetTicks(nextLpInterruptTime);
   1333                      if( !lpTimerHardwareIsRunning )
   1334                      {
   1335                          LPTMR_Enable();
   1336                          lpTimerHardwareIsRunning = TRUE;
   1337                      }
   1338                  }
   1339                  else if( lpTimerHardwareIsRunning )
   1340                  {
   1341                      LPTMR_Disable();
   1342                      lpTimerHardwareIsRunning = FALSE;
   1343                  }
   1344          #endif
   1345                  TmrIntRestoreAll();      
   1346          
   1347          #if !defined(FWK_SMALL_RAM_CONFIG)        
   1348                  /* For BareMetal break the while(1) after 1 run */
   1349                  if (gUseRtos_c == 0)
   1350                  {
   1351                      break;
   1352                  }        
   1353          #endif        
   1354              }
   1355          }
   1356          
   1357          /*---------------------------------------------------------------------------
   1358           * NAME: TMR_EnableTimer
   1359           * DESCRIPTION: Enable the specified timer
   1360           * PARAMETERS:  IN: tmrID - the timer ID
   1361           * RETURN: None
   1362           * NOTES: none
   1363           *---------------------------------------------------------------------------*/
   1364          void TMR_EnableTimer
   1365          (
   1366              tmrTimerID_t tmrID
   1367          )
   1368          {
   1369              TmrIntDisableAll();
   1370          
   1371              if (TMR_GetTimerStatus(tmrID) == mTmrStatusInactive_c)
   1372              {
   1373                  IncrementActiveTimerNumber(TMR_GetTimerType(tmrID));
   1374                  TMR_SetTimerStatus(tmrID, mTmrStatusReady_c);
   1375                  (void)OSA_EventSet(&mTimerThreadEventId, mTmrDummyEvent_c);
   1376              }
   1377          
   1378              TmrIntRestoreAll();
   1379          }
   1380          
   1381          /*---------------------------------------------------------------------------
   1382           * NAME: TMR_NotCountedMillisTimeBeforeSleep
   1383           * DESCRIPTION: This function is called by Low Power module;
   1384           * Also this function stops the hardware timer.
   1385           * PARAMETERS:  none
   1386           * RETURN: uint32 - time in millisecond that wasn't counted before
   1387           *        entering in sleep
   1388           * NOTES: none
   1389           *---------------------------------------------------------------------------*/
   1390          uint16_t TMR_NotCountedTicksBeforeSleep
   1391          (
   1392              void
   1393          )
   1394          {
   1395          #if (gTMR_EnableLowPowerTimers_d)
   1396              uint16_t currentTimeInTicks;
   1397          
   1398              if (!numberOfLowPowerActiveTimers)
   1399                  return 0;
   1400          
   1401              currentTimeInTicks = StackTimer_GetCounterValue();
   1402              StackTimer_Disable();
   1403              timerHardwareIsRunning = FALSE;
   1404          
   1405              /* The hw timer is stopped but keep timerHardwareIsRunning = TRUE...*/
   1406              /* The Lpm timers are considered as being in running mode, so that  */
   1407              /* not to start the hw timer if a TMR event occurs (this shouldn't happen) */
   1408          
   1409              return  (uint16_t)(currentTimeInTicks - previousTimeInTicks);
   1410          #else
   1411              return 0;
   1412          #endif
   1413          }
   1414          
   1415          /*---------------------------------------------------------------------------
   1416           * NAME: TMR_SyncLpmTimers
   1417           * DESCRIPTION: This function is called by the Low Power module
   1418           * each time the MCU wakes up.
   1419           * PARAMETERS:  sleep duration in milliseconds
   1420           * RETURN: none
   1421           * NOTES: none
   1422           *---------------------------------------------------------------------------*/
   1423          void TMR_SyncLpmTimers
   1424          (
   1425              uint32_t sleepDurationTmrTicks
   1426          )
   1427          {
   1428          #if (gTMR_EnableLowPowerTimers_d)
   1429              uint32_t  timerID;
   1430              tmrTimerType_t timerType;
   1431          
   1432              /* Check if there are low power active timer */
   1433              if (!numberOfLowPowerActiveTimers)
   1434                  return;
   1435          
   1436              /* For each timer, detect the timer type and count down the spent duration in sleep */
   1437              for (timerID = 0; timerID < NumberOfElements(maTmrTimerTable); ++timerID)
   1438              {
   1439          
   1440                  /* Detect the timer type and count down the spent duration in sleep */
   1441                  timerType = TMR_GetTimerType(timerID);
   1442          
   1443                  /* Sync. only the low power timers that are active */
   1444                  if ( (TMR_GetTimerStatus(timerID) == mTmrStatusActive_c)
   1445                          && (IsLowPowerTimer(timerType)) )
   1446                  {
   1447                      /* Timer expired when MCU was in sleep mode??? */
   1448                      if( maTmrTimerTable[timerID].remainingTicks > sleepDurationTmrTicks)
   1449                      {
   1450                          maTmrTimerTable[timerID].remainingTicks -= sleepDurationTmrTicks;
   1451          
   1452                      }
   1453                      else
   1454                      {
   1455                          maTmrTimerTable[timerID].remainingTicks = 0;
   1456                      }
   1457          
   1458                  }
   1459          
   1460              }/* end for (timerID = 0;.... */
   1461          
   1462              StackTimer_Enable();
   1463              previousTimeInTicks = StackTimer_GetCounterValue();
   1464          
   1465          #else
   1466              sleepDurationTmrTicks = sleepDurationTmrTicks;
   1467          #endif /* #if (gTMR_EnableLowPowerTimers_d) */
   1468          }
   1469          /*---------------------------------------------------------------------------
   1470           * NAME: TMR_MakeTMRThreadReady
   1471           * DESCRIPTION: This function is called by the Low Power module
   1472           * each time the MCU wakes up after low power timers synchronisation.
   1473           * PARAMETERS:
   1474           * RETURN: none
   1475           * NOTES: none
   1476           *---------------------------------------------------------------------------*/
   1477          void TMR_MakeTMRThreadReady
   1478          (
   1479           void
   1480          )
   1481          {
   1482          #if (gTMR_EnableLowPowerTimers_d)
   1483          
   1484              (void)OSA_EventSet(&mTimerThreadEventId, mTmrDummyEvent_c);
   1485          
   1486          #endif /* #if (gTMR_EnableLowPowerTimers_d) */
   1487          }
   1488          
   1489          /*---------------------------------------------------------------------------
   1490           * NAME: TMR_GetTimerFreq
   1491           * DESCRIPTION:
   1492           * PARAMETERS: -
   1493           * RETURN: -
   1494           *---------------------------------------------------------------------------*/
   1495          uint32_t TMR_GetTimerFreq
   1496          (
   1497              void
   1498          )
   1499          {
   1500            return mCounterFreqHz ;
   1501          }
   1502          
   1503          /*---------------------------------------------------------------------------
   1504           * NAME: TMR_TimeStampInit
   1505           * DESCRIPTION: Initialize the timestamp module
   1506           * PARAMETERS: -
   1507           * RETURN: -
   1508           *---------------------------------------------------------------------------*/
   1509          void TMR_TimeStampInit(void)
   1510          {
   1511          #if gTMR_PIT_Timestamp_Enabled_d
   1512              TMR_PITInit();
   1513          #else
   1514              TMR_RTCInit();
   1515          #endif
   1516          }
   1517          
   1518          /*---------------------------------------------------------------------------
   1519           * NAME: TMR_GetTimestamp
   1520           * DESCRIPTION: return an 64-bit absolute timestamp
   1521           * PARAMETERS: -
   1522           * RETURN: absolute timestamp in us
   1523           *---------------------------------------------------------------------------*/
   1524          uint64_t TMR_GetTimestamp(void)
   1525          {
   1526          #if gTMR_PIT_Timestamp_Enabled_d
   1527              return TMR_PITGetTimestamp();
   1528          #else
   1529              return TMR_RTCGetTimestamp();
   1530          #endif
   1531          }
   1532          
   1533          #endif /*gTMR_Enabled_d*/
   1534          
   1535          #if gPrecision_Timers_Enabled_d
   1536          
   1537          /*---------------------------------------------------------------------------
   1538           * NAME: TMR_PrecisionTimerInit
   1539           * DESCRIPTION: initialize the precision timer module
   1540           * PARAMETERS: -
   1541           * RETURN: -
   1542           *---------------------------------------------------------------------------*/
   1543          void TMR_PrecisionTimerInit()
   1544          {
   1545            globalTimeTicks = 0;
   1546          
   1547            gPrecisionTimerHandle = PrecisionTimer_Init(NULL);
   1548          
   1549            PrecisionTimer_OnCounterRestart_fptr = TMR_PrecisionTimerOverflowNotify;
   1550          
   1551            if(PrecisionTimer_Enable(gPrecisionTimerHandle) != ERR_OK)
   1552            {
   1553              panic( 0, (uint32_t)TMR_Init, 0, 0 );
   1554              return;
   1555            }
   1556          
   1557            gPrecisionTimerTickus = 1000000U / PrecisionTimer_GetInputFrequency(gPrecisionTimerHandle);
   1558            gPrecisionTimerTickusReal = 1000000.0F / PrecisionTimer_GetInputFrequencyReal(gPrecisionTimerHandle);
   1559            PrecisionTimer_GetPeriodTicks(gPrecisionTimerHandle, (uint32_t*)&gPrecisionTimerPeriodTicks);
   1560          
   1561            (void)gPrecisionTimerTickus;
   1562            (void)gPrecisionTimerTickusReal;
   1563            (void)gPrecisionTimerPeriodTicks;
   1564          }
   1565          
   1566          /*---------------------------------------------------------------------------
   1567           * NAME: TMR_GetAbsoluteTimeus
   1568           * DESCRIPTION: Gets the absolute time in microseconds.
   1569           * PARAMETERS:  None
   1570           * RETURN: Time in microseconds
   1571           * NOTES:
   1572           *---------------------------------------------------------------------------*/
   1573          uint64_t TMR_GetAbsoluteTimeus()
   1574          {
   1575            uint64_t globalTime;
   1576            uint64_t ticks;
   1577          
   1578            TmrIntDisableAll();
   1579            ticks = gPrecisionTimerPeriodTicks - PrecisionTimer_GetCounterValue(gPrecisionTimerHandle) + globalTimeTicks;
   1580            globalTime = (uint64_t)(ticks * gPrecisionTimerTickusReal);
   1581            TmrIntRestoreAll();
   1582          
   1583            return globalTime;
   1584          }
   1585          
   1586          /*---------------------------------------------------------------------------
   1587           * NAME: TMR_PrecisionTimerOverflowNotify
   1588           * DESCRIPTION: Event function called by driver ISR on timer overflow in interrupt context.
   1589           * PARAMETERS:  IN: User data; unused.
   1590           * RETURN: none
   1591           * NOTES: none
   1592           *---------------------------------------------------------------------------*/
   1593          void TMR_PrecisionTimerOverflowNotify(LDD_TUserData *UserDataPtr)
   1594          {
   1595            uint32_t period;
   1596          
   1597            (void)UserDataPtr;
   1598          
   1599            /* I assume here that int_kernel_isr calls the ISR with interrupts disabled*/
   1600            PrecisionTimer_GetPeriodTicks(gPrecisionTimerHandle, &period);
   1601            globalTimeTicks += period;
   1602          }
   1603          
   1604          #endif /*gPrecision_Timers_Enabled_d*/
   1605          
   1606          /*---------------------------------------------------------------------------
   1607           * NAME: TMR_RTCIsOscStarted
   1608           * DESCRIPTION: returns the state of the RTC oscillator
   1609           * PARAMETERS: -
   1610           * RETURN: -
   1611           *---------------------------------------------------------------------------*/
   1612          bool_t TMR_RTCIsOscStarted()
   1613          {
   1614            return TRUE;
   1615          }
   1616          #if gTimestamp_Enabled_d
   1617          
   1618          /*---------------------------------------------------------------------------
   1619           * NAME: TMR_RTCInit
   1620           * DESCRIPTION: initialize the RTC part of the timer module
   1621           * PARAMETERS: -
   1622           * RETURN: -
   1623           *---------------------------------------------------------------------------*/
   1624          void TMR_RTCInit()
   1625          {
   1626            static uint8_t gRTCInitFlag = 0;
   1627            RTC_Type *rtcBaseAddr = g_rtcBase[gTmrRtcInstance_c];
   1628            extern const IRQn_Type g_rtcIrqId[];
   1629          
   1630            TmrIntDisableAll();
   1631          
   1632            if( gRTCInitFlag )
   1633            {
   1634                TmrIntRestoreAll();
   1635                return; /* already initialized */
   1636            }
   1637          
   1638            gRTCInitFlag = TRUE;
   1639          
   1640            /* Overwrite old ISR */
   1641            OSA_InstallIntHandler(g_rtcIrqId[gTmrRtcInstance_c], TMR_RTCAlarmNotify);
   1642          
   1643            RTC_DRV_Init(gTmrRtcInstance_c);
   1644            /* Reset the seconds register */
   1645            RTC_HAL_EnableCounter(rtcBaseAddr, FALSE);
   1646            RTC_HAL_SetSecsReg(rtcBaseAddr, 1);
   1647          
   1648            gRTCTimeOffset = 0;
   1649            gRTCPrescalerOffset = 0;
   1650            gRTCAlarmCallback = NULL;
   1651            gRTCAlarmCallbackParam = NULL;
   1652          
   1653            RTC_HAL_SetAlarmIntCmd(rtcBaseAddr, FALSE);
   1654            RTC_HAL_SetSecsReg(rtcBaseAddr, 0x00 + 0x01);
   1655            RTC_HAL_SetPrescaler(rtcBaseAddr, 0x00);
   1656            
   1657            RTC_HAL_EnableCounter(rtcBaseAddr, TRUE);
   1658          
   1659            TmrIntRestoreAll();
   1660          }
   1661          
   1662          /*---------------------------------------------------------------------------
   1663           * NAME: TMR_RTCGetTimestamp
   1664           * DESCRIPTION: Returns the absolute time at the moment of the call.
   1665           * PARAMETERS: -
   1666           * RETURN: Absolute time at the moment of the call in microseconds.
   1667           *---------------------------------------------------------------------------*/
   1668          uint64_t TMR_RTCGetTimestamp()
   1669          {
   1670            uint32_t seconds1, seconds2, prescaler0, prescaler1, prescaler2;
   1671            uint64_t useconds, offset, prescalerOffset;
   1672            RTC_Type *rtcBaseAddr = g_rtcBase[gTmrRtcInstance_c];
   1673          
   1674            TmrIntDisableAll();
   1675            offset = gRTCTimeOffset;
   1676            prescalerOffset = gRTCPrescalerOffset;
   1677          
   1678            prescaler0 = RTC_HAL_GetPrescaler(rtcBaseAddr);
   1679            seconds1   = RTC_HAL_GetSecsReg(rtcBaseAddr);
   1680            prescaler1 = RTC_HAL_GetPrescaler(rtcBaseAddr);
   1681            seconds2   = RTC_HAL_GetSecsReg(rtcBaseAddr); 
   1682            prescaler2 = RTC_HAL_GetPrescaler(rtcBaseAddr);
   1683          
   1684            TmrIntRestoreAll();
   1685          
   1686            prescaler0 &= 0x7fff;
   1687            seconds1 -= 1;
   1688            prescaler1 &= 0x7fff;
   1689            seconds2 -= 1;
   1690            prescaler2 &= 0x7fff;
   1691          
   1692            if(seconds1 != seconds2)
   1693            {
   1694              seconds1 = seconds2;
   1695              prescaler1 = prescaler2;
   1696            }
   1697            else
   1698            {
   1699              if(prescaler1 != prescaler2)
   1700              {
   1701                prescaler1 = prescaler0;
   1702              }
   1703            }
   1704          
   1705            useconds = ((prescaler1 + prescalerOffset + ((uint64_t)seconds1<<15))*15625)>>9;
   1706          
   1707            return useconds + offset;
   1708          }
   1709          
   1710          /*---------------------------------------------------------------------------
   1711           * NAME: TMR_RTCSetTime
   1712           * DESCRIPTION: Sets the absolute time.
   1713           * PARAMETERS: Time in microseconds.
   1714           * RETURN: -
   1715           *---------------------------------------------------------------------------*/
   1716          void TMR_RTCSetTime(uint64_t microseconds)
   1717          {
   1718              uint64_t initialAlarm;
   1719              RTC_Type *rtcBaseAddr = g_rtcBase[gTmrRtcInstance_c];
   1720              
   1721              TmrIntDisableAll();
   1722              RTC_HAL_EnableCounter(rtcBaseAddr, FALSE);
   1723              
   1724              initialAlarm = gRTCTimeOffset;
   1725              initialAlarm = RTC_HAL_GetAlarmReg(rtcBaseAddr) + (initialAlarm/1000000L);
   1726              gRTCTimeOffset = microseconds;
   1727              
   1728              RTC_HAL_SetSecsReg(rtcBaseAddr, 0x00 + 0x01);
   1729              RTC_HAL_SetPrescaler(rtcBaseAddr, 0x00);
   1730              
   1731              if( (initialAlarm * 1000000L) <= microseconds )
   1732              {
   1733                  RTC_HAL_SetAlarmIntCmd(rtcBaseAddr, FALSE);
   1734                  if( gRTCAlarmCallback != NULL )
   1735                  {
   1736                      gRTCAlarmCallback(gRTCAlarmCallbackParam);
   1737                  }
   1738              }
   1739              else
   1740              {
   1741                  RTC_HAL_SetAlarmReg(rtcBaseAddr, initialAlarm - (microseconds/1000000L));
   1742              }
   1743              
   1744              RTC_HAL_EnableCounter(rtcBaseAddr, TRUE);
   1745              TmrIntRestoreAll();
   1746          }
   1747          
   1748          /*---------------------------------------------------------------------------
   1749           * NAME: TMR_RTCSetAlarm
   1750           * DESCRIPTION: Sets the alarm absolute time in seconds.
   1751           * PARAMETERS: Time in seconds for the alarm. Callback function pointer. Parameter for callback.
   1752           * RETURN: -
   1753           *---------------------------------------------------------------------------*/
   1754          void TMR_RTCSetAlarm(uint64_t seconds, pfTmrCallBack_t callback, void *param)
   1755          {
   1756              RTC_Type *rtcBaseAddr = g_rtcBase[gTmrRtcInstance_c];
   1757          
   1758              TmrIntDisableAll();
   1759              
   1760              gRTCAlarmCallback = callback;
   1761              gRTCAlarmCallbackParam = param;
   1762              seconds = seconds - (gRTCTimeOffset/1000000L);
   1763              RTC_HAL_SetAlarmReg(rtcBaseAddr, seconds);
   1764              RTC_HAL_SetAlarmIntCmd(rtcBaseAddr, TRUE);    
   1765              
   1766              TmrIntRestoreAll();
   1767          }
   1768          
   1769          /*---------------------------------------------------------------------------
   1770           * NAME: TMR_RTCSetAlarmRelative
   1771           * DESCRIPTION: Sets the alarm relative time in seconds.
   1772           * PARAMETERS: Time in seconds for the alarm. Callback function pointer. Parameter for callback.
   1773           * RETURN: -
   1774           *---------------------------------------------------------------------------*/
   1775          void TMR_RTCSetAlarmRelative(uint32_t seconds, pfTmrCallBack_t callback, void *param)
   1776          {
   1777              uint32_t rtcSeconds, rtcPrescaler;
   1778              RTC_Type *rtcBaseAddr = g_rtcBase[gTmrRtcInstance_c];
   1779              
   1780              if( seconds == 0 )
   1781              {
   1782                  callback(param);
   1783                  return;
   1784              }
   1785              
   1786              TmrIntDisableAll();
   1787              
   1788              RTC_HAL_EnableCounter(rtcBaseAddr, FALSE);
   1789              rtcSeconds = RTC_HAL_GetSecsReg(rtcBaseAddr);
   1790              rtcPrescaler = RTC_HAL_GetPrescaler(rtcBaseAddr);
   1791              RTC_HAL_SetPrescaler(rtcBaseAddr, 0x00);
   1792              /*If bit prescaler 14 transitions from 1 to 0 the seconds reg get incremented.
   1793              Rewrite seconds register to prevent this.*/
   1794              RTC_HAL_SetSecsReg(rtcBaseAddr, rtcSeconds);
   1795              RTC_HAL_EnableCounter(rtcBaseAddr, TRUE);
   1796              rtcPrescaler &= 0x7fff;
   1797              
   1798              gRTCPrescalerOffset += rtcPrescaler;
   1799              
   1800              if(gRTCPrescalerOffset & 0x8000)
   1801              {
   1802                  rtcSeconds++;
   1803                  RTC_HAL_EnableCounter(rtcBaseAddr, FALSE);
   1804                  RTC_HAL_SetSecsReg(rtcBaseAddr, rtcSeconds);
   1805                  RTC_HAL_EnableCounter(rtcBaseAddr, TRUE);
   1806                  gRTCPrescalerOffset = gRTCPrescalerOffset & 0x7FFF;
   1807              }
   1808              
   1809              gRTCAlarmCallback = callback;
   1810              gRTCAlarmCallbackParam = param;
   1811              RTC_HAL_SetAlarmReg(rtcBaseAddr,  seconds + rtcSeconds - 1);
   1812              RTC_HAL_SetAlarmIntCmd(rtcBaseAddr, TRUE);
   1813              
   1814              TmrIntRestoreAll();
   1815          }
   1816          
   1817          
   1818          #endif /*gTimestamp_Enabled_d*/
   1819          
   1820          #if gTMR_PIT_Timestamp_Enabled_d
   1821          
   1822          #if (FSL_FEATURE_PIT_TIMER_COUNT >= 3)
   1823          /*---------------------------------------------------------------------------
   1824           * NAME: TMR_PITInit
   1825           * DESCRIPTION: initialize the PIT part of the timer module
   1826           * PARAMETERS: -
   1827           * RETURN: -
   1828           *---------------------------------------------------------------------------*/
   1829          void TMR_PITInit()
   1830          {
   1831              static uint8_t gPITInitFlag = FALSE;
   1832              PIT_Type * baseAddr = g_pitBase[gTmrPitInstance_c];
   1833              uint32_t pitFreq;
   1834              
   1835              if( gPITInitFlag )
   1836              {
   1837                  return; /*already inited*/
   1838              }
   1839              
   1840              TmrIntDisableAll();
   1841              
   1842              gPITInitFlag = TRUE;
   1843              
   1844              PIT_DRV_Init(gTmrPitInstance_c, FALSE);
   1845              PIT_HAL_Disable(baseAddr);
   1846              
   1847              pitFreq = CLOCK_SYS_GetPitFreq(gTmrPitInstance_c);
   1848              
   1849              PIT_HAL_SetTimerPeriodByCount(baseAddr, 0, pitFreq/1000000 -1);
   1850              PIT_HAL_SetTimerPeriodByCount(baseAddr, 1, 0xFFFFFFFF);
   1851              PIT_HAL_SetTimerPeriodByCount(baseAddr, 2, 0xFFFFFFFF);
   1852              
   1853              PIT_HAL_SetTimerChainCmd(baseAddr, 1, TRUE);
   1854              PIT_HAL_SetTimerChainCmd(baseAddr, 2, TRUE);
   1855              
   1856              PIT_HAL_StartTimer(baseAddr, 0);
   1857              PIT_HAL_StartTimer(baseAddr, 1);
   1858              PIT_HAL_StartTimer(baseAddr, 2);
   1859              
   1860              PIT_HAL_Enable(baseAddr);
   1861              
   1862              TmrIntRestoreAll();
   1863          }
   1864          
   1865          /*---------------------------------------------------------------------------
   1866           * NAME: TMR_PITGetTimestamp
   1867           * DESCRIPTION: Returns the absolute time at the moment of the call.
   1868           * PARAMETERS: -
   1869           * RETURN: Absolute time at the moment of the call in microseconds.
   1870           *---------------------------------------------------------------------------*/
   1871          uint64_t TMR_PITGetTimestamp()
   1872          {
   1873              PIT_Type * baseAddr = g_pitBase[gTmrPitInstance_c];
   1874              uint32_t pit2_0, pit2_1 , pit1_0, pit1_1;
   1875              uint64_t useconds;
   1876              
   1877              TmrIntDisableAll();
   1878              pit1_0 = PIT_HAL_ReadTimerCount(baseAddr, 1);
   1879              pit2_0 = PIT_HAL_ReadTimerCount(baseAddr, 2);
   1880              pit1_1 = PIT_HAL_ReadTimerCount(baseAddr, 1);
   1881              pit2_1 = PIT_HAL_ReadTimerCount(baseAddr, 2);
   1882              TmrIntRestoreAll();
   1883          
   1884              if( pit1_1 <= pit1_0)
   1885              {
   1886                  useconds = pit2_0;
   1887              }
   1888              else
   1889              {
   1890                  useconds = pit2_1;
   1891              }
   1892          
   1893              useconds <<= 32;
   1894              useconds += pit1_1;
   1895              useconds = ~useconds ;
   1896          #if !gTMR_PIT_FreqMultipleOfMHZ_d
   1897              {
   1898                  uint32_t pitFreq;
   1899                  uint32_t pitLoadVal;
   1900          
   1901                  pitFreq = CLOCK_SYS_GetPitFreq(gTmrPitInstance_c);
   1902                  pitLoadVal = PIT_HAL_GetTimerPeriodByCount(baseAddr, 0) + 1;
   1903                  pitLoadVal *= 1000000;
   1904          
   1905                  if( pitFreq != pitLoadVal)
   1906                  {
   1907                      /*
   1908                      To adjust the value to useconds the following formula is used.
   1909                      useconds = (useconds*pitLoadVal)/pitFreq;
   1910                      Because this formula causes overflow the useconds/pitFreq is split in its Integer  and Fractional part.
   1911                      */
   1912                      uint64_t uSecAdjust1 , uSecAdjust2;
   1913                      uSecAdjust1  = useconds/pitFreq;
   1914                      uSecAdjust2  = useconds%pitFreq;
   1915                      uSecAdjust1 *= pitLoadVal;
   1916                      uSecAdjust2 *= pitLoadVal;
   1917                      uSecAdjust2 /= pitFreq;
   1918                      useconds = uSecAdjust1 + uSecAdjust2;
   1919                  }
   1920              }
   1921          #endif//gTMR_PIT_FreqMultipleOfMHZ_d
   1922              return useconds;
   1923          }
   1924          
   1925          #else
   1926          
   1927          /*---------------------------------------------------------------------------
   1928           * NAME: TMR_PITInit
   1929           * DESCRIPTION: initialize the PIT part of the timer module
   1930           * PARAMETERS: -
   1931           * RETURN: -
   1932           *---------------------------------------------------------------------------*/
   1933          void TMR_PITInit()
   1934          {
   1935              static uint8_t gPITInitFlag = FALSE;
   1936              PIT_Type * baseAddr = g_pitBase[gTmrPitInstance_c];
   1937              uint32_t pitFreq;
   1938              
   1939              TmrIntDisableAll();
   1940              
   1941              if( gPITInitFlag )
   1942              {
   1943                  TmrIntRestoreAll();
   1944                  return; /*already inited*/
   1945              }
   1946              
   1947              gPITInitFlag = TRUE;
   1948              mPIT_TimestampHigh = (uint32_t)-1;
   1949          
   1950              CLOCK_SYS_EnablePitClock(gTmrPitInstance_c);
   1951              //PIT_HAL_Disable(baseAddr);
   1952          
   1953              pitFreq = CLOCK_SYS_GetPitFreq(gTmrPitInstance_c);
   1954          
   1955              PIT_HAL_SetTimerPeriodByCount(baseAddr, 0, pitFreq/1000000 -1);
   1956              PIT_HAL_SetTimerPeriodByCount(baseAddr, 1, 0xFFFFFFFF);
   1957          
   1958              PIT_HAL_SetTimerChainCmd(baseAddr, 1, TRUE);
   1959              PIT_HAL_SetIntCmd(baseAddr, 1, TRUE);
   1960          
   1961              /* Overwrite old ISR */
   1962              OSA_InstallIntHandler(g_pitIrqId[gTmrPitInstance_c], TMR_PIT_ISR);
   1963              NVIC_ClearPendingIRQ(g_pitIrqId[gTmrPitInstance_c]);
   1964              NVIC_EnableIRQ(g_pitIrqId[gTmrPitInstance_c]);
   1965          
   1966              PIT_HAL_Enable(baseAddr);
   1967          
   1968              PIT_HAL_StartTimer(baseAddr, 1);
   1969              PIT_HAL_StartTimer(baseAddr, 0);
   1970          
   1971              TmrIntRestoreAll();
   1972          }
   1973          
   1974          /*---------------------------------------------------------------------------
   1975           * NAME: TMR_PITGetTimestamp
   1976           * DESCRIPTION: Returns the absolute time at the moment of the call.
   1977           * PARAMETERS: -
   1978           * RETURN: Absolute time at the moment of the call in microseconds.
   1979           *---------------------------------------------------------------------------*/
   1980          uint64_t TMR_PITGetTimestamp()
   1981          {
   1982              PIT_Type * baseAddr = g_pitBase[gTmrPitInstance_c];
   1983              uint32_t  pit2, pit1_0, pit1_1, pitIF;
   1984              uint64_t useconds;
   1985              
   1986              TmrIntDisableAll();
   1987              
   1988              pit2 = mPIT_TimestampHigh;
   1989              pit1_0 = PIT_HAL_ReadTimerCount(baseAddr, 1);
   1990              pitIF = PIT_HAL_IsIntPending(baseAddr, 1);
   1991              pit1_1 = PIT_HAL_ReadTimerCount(baseAddr, 1);
   1992              
   1993              TmrIntRestoreAll();
   1994              
   1995              if(pitIF)
   1996              {
   1997                  useconds = pit2-1;
   1998              }
   1999              else
   2000              {
   2001                  useconds = pit2;
   2002              }
   2003              useconds <<= 32;
   2004              if(pitIF)
   2005              {
   2006                  useconds += pit1_1;
   2007              }
   2008              else
   2009              {
   2010                  useconds += pit1_0;
   2011              }
   2012              useconds = ~useconds ;
   2013          #if !gTMR_PIT_FreqMultipleOfMHZ_d
   2014              {
   2015                  uint32_t pitFreq;
   2016                  uint32_t pitLoadVal;
   2017                  
   2018                  pitFreq = CLOCK_SYS_GetPitFreq(gTmrPitInstance_c);
   2019                  pitLoadVal = PIT_HAL_GetTimerPeriodByCount(baseAddr, 0) + 1;
   2020                  pitLoadVal *= 1000000;
   2021                  
   2022                  if( pitFreq != pitLoadVal)
   2023                  {
   2024                      /*
   2025                      To adjust the value to useconds the following formula is used.
   2026                      useconds = (useconds*pitLoadVal)/pitFreq;
   2027                      Because this formula causes overflow the useconds/pitFreq is split in its Integer  and Fractional part.
   2028                      */
   2029                      uint64_t uSecAdjust1 , uSecAdjust2;
   2030                      uSecAdjust1  = useconds/pitFreq;
   2031                      uSecAdjust2  = useconds%pitFreq;
   2032                      uSecAdjust1 *= pitLoadVal;
   2033                      uSecAdjust2 *= pitLoadVal;
   2034                      uSecAdjust2 /= pitFreq;
   2035                      useconds = uSecAdjust1 + uSecAdjust2;
   2036                  }
   2037              }
   2038          #endif//gTMR_PIT_FreqMultipleOfMHZ_d
   2039              return useconds;
   2040          }
   2041          
   2042          #endif
   2043          
   2044          #endif//gTMR_PIT_Timestamp_Enabled_d
   2045          
   2046          
   2047          /*****************************************************************************
   2048           *                               <<< EOF >>>                                 *
   2049           *****************************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   CLOCK_SYS_EnablePitClock
         8   -> SIM_HAL_EnableClock
       8   CLOCK_SYS_GetPitFreq
         8   -> CLOCK_SYS_GetBusClockFreq
       0   NVIC_ClearPendingIRQ
       0   NVIC_EnableIRQ
      16   PIT_HAL_ClearIntFlag
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       0   PIT_HAL_Enable
      16   PIT_HAL_IsIntPending
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   PIT_HAL_ReadTimerCount
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   PIT_HAL_SetIntCmd
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   PIT_HAL_SetTimerChainCmd
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   PIT_HAL_SetTimerPeriodByCount
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   PIT_HAL_StartTimer
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       4   RTC_HAL_EnableCounter
       0   RTC_HAL_GetAlarmReg
       0   RTC_HAL_GetPrescaler
       0   RTC_HAL_GetSecsReg
       4   RTC_HAL_SetAlarmIntCmd
       0   RTC_HAL_SetAlarmReg
       0   RTC_HAL_SetPrescaler
       0   RTC_HAL_SetSecsReg
       4   SIM_HAL_EnableClock
       8   StackTimer_ISR
         8   -> OSA_EventSet
         8   -> StackTimer_ClearIntFlag
       8   TMR_AllocateTimer
         8   -> TMR_SetTimerStatus
       4   TMR_AreAllTimersOff
       8   TMR_EnableTimer
         8   -> OSA_EnterCritical
         8   -> OSA_EventSet
         8   -> OSA_ExitCritical
         8   -> TMR_GetTimerStatus
         8   -> TMR_GetTimerType
         8   -> TMR_SetTimerStatus
      16   TMR_FreeTimer
        16   -> TMR_StopTimer
      24   TMR_GetRemainingTime
        24   -> OSA_EnterCritical
        24   -> OSA_ExitCritical
        24   -> StackTimer_GetCounterValue
        24 __aeabi_lmul
        24 __aeabi_uldivmod
       0   TMR_GetTimerFreq
       0   TMR_GetTimerStatus
       0   TMR_GetTimerType
       8   TMR_GetTimestamp
         8   -> TMR_PITGetTimestamp
      32   TMR_Init
        32   -> OSA_EventCreate
        32   -> OSA_TaskCreate
        32   -> StackTimer_GetInputFrequency
        32   -> StackTimer_Init
        32   -> TmrTicksFromMilliseconds
        32   -> panic
       8   TMR_IsTimerActive
         8   -> TMR_GetTimerStatus
       8   TMR_IsTimerReady
         8   -> TMR_GetTimerStatus
       8   TMR_MakeTMRThreadReady
         8   -> OSA_EventSet
       8   TMR_NotCountedTicksBeforeSleep
         8   -> StackTimer_Disable
         8   -> StackTimer_GetCounterValue
      16   TMR_NotifyClkChanged
        16   -> StackTimer_GetInputFrequency
        16   -> TmrTicksFromMilliseconds
      32   TMR_PITGetTimestamp
        32   -> OSA_EnterCritical
        32   -> OSA_ExitCritical
        32   -> PIT_HAL_IsIntPending
        32   -> PIT_HAL_ReadTimerCount
      16   TMR_PITInit
        16   -> CLOCK_SYS_EnablePitClock
        16   -> CLOCK_SYS_GetPitFreq
        16   -> NVIC_ClearPendingIRQ
        16   -> NVIC_EnableIRQ
        16   -> OSA_EnterCritical
        16   -> OSA_ExitCritical
        16   -> OSA_InstallIntHandler
        16   -> PIT_HAL_Enable
        16   -> PIT_HAL_SetIntCmd
        16   -> PIT_HAL_SetTimerChainCmd
        16   -> PIT_HAL_SetTimerPeriodByCount
        16   -> PIT_HAL_StartTimer
        16 __aeabi_uidiv
       8   TMR_PIT_ISR
         8   -> PIT_HAL_ClearIntFlag
       8   TMR_RTCAlarmNotify
         8   -- Indirect call
         8   -> RTC_HAL_GetAlarmReg
         8   -> RTC_HAL_SetAlarmIntCmd
         8   -> RTC_HAL_SetAlarmReg
      64   TMR_RTCGetTimestamp
        64   -> OSA_EnterCritical
        64   -> OSA_ExitCritical
        64   -> RTC_HAL_GetPrescaler
        64   -> RTC_HAL_GetSecsReg
        64 __aeabi_lmul
       8   TMR_RTCInit
         8   -> OSA_EnterCritical
         8   -> OSA_ExitCritical
         8   -> OSA_InstallIntHandler
         8   -> RTC_DRV_Init
         8   -> RTC_HAL_EnableCounter
         8   -> RTC_HAL_SetAlarmIntCmd
         8   -> RTC_HAL_SetPrescaler
         8   -> RTC_HAL_SetSecsReg
       0   TMR_RTCIsOscStarted
      24   TMR_RTCSetAlarm
        24   -> OSA_EnterCritical
        24   -> OSA_ExitCritical
        24   -> RTC_HAL_SetAlarmIntCmd
        24   -> RTC_HAL_SetAlarmReg
        24 __aeabi_uldivmod
      32   TMR_RTCSetAlarmRelative
        32   -- Indirect call
        32   -> OSA_EnterCritical
        32   -> OSA_ExitCritical
        32   -> RTC_HAL_EnableCounter
        32   -> RTC_HAL_GetPrescaler
        32   -> RTC_HAL_GetSecsReg
        32   -> RTC_HAL_SetAlarmIntCmd
        32   -> RTC_HAL_SetAlarmReg
        32   -> RTC_HAL_SetPrescaler
        32   -> RTC_HAL_SetSecsReg
      32   TMR_RTCSetTime
        32   -- Indirect call
        32   -> OSA_EnterCritical
        32   -> OSA_ExitCritical
        32   -> RTC_HAL_EnableCounter
        32   -> RTC_HAL_GetAlarmReg
        32   -> RTC_HAL_SetAlarmIntCmd
        32   -> RTC_HAL_SetAlarmReg
        32   -> RTC_HAL_SetPrescaler
        32   -> RTC_HAL_SetSecsReg
        32 __aeabi_lmul
        32 __aeabi_uldivmod
       0   TMR_SetTimerStatus
       0   TMR_SetTimerType
      24   TMR_StartIntervalTimer
        24   -> TMR_StartTimer
      32   TMR_StartLowPowerTimer
        32   -> TMR_StartTimer
      24   TMR_StartMinuteTimer
        24   -> TMR_StartTimer
      24   TMR_StartSecondTimer
        24   -> TMR_StartTimer
      24   TMR_StartSingleShotTimer
        24   -> TMR_StartTimer
      40   TMR_StartTimer
        40   -> StackTimer_GetCounterValue
        40   -> TMR_EnableTimer
        40   -> TMR_SetTimerType
        40   -> TMR_StopTimer
        40   -> TmrTicksFromMilliseconds
      16   TMR_StopTimer
        16   -> OSA_EnterCritical
        16   -> OSA_EventSet
        16   -> OSA_ExitCritical
        16   -> TMR_GetTimerStatus
        16   -> TMR_GetTimerType
        16   -> TMR_SetTimerStatus
      16   TMR_SyncLpmTimers
        16   -> StackTimer_Enable
        16   -> StackTimer_GetCounterValue
        16   -> TMR_GetTimerStatus
        16   -> TMR_GetTimerType
      48   TMR_Task
        48   -- Indirect call
        48   -> OSA_EnterCritical
        48   -> OSA_EventWait
        48   -> OSA_ExitCritical
        48   -> StackTimer_Disable
        48   -> StackTimer_Enable
        48   -> StackTimer_GetCounterValue
        48   -> StackTimer_SetOffsetTicks
        48   -> TMR_GetTimerStatus
        48   -> TMR_GetTimerType
        48   -> TMR_SetTimerStatus
        48   -> TMR_StopTimer
       8   TMR_TimeStampInit
         8   -> TMR_PITInit
       4   TmrTicksFromMilliseconds
         4 __aeabi_lmul
         4 __aeabi_uldivmod


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable20
       4  ??DataTable23
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_2
       4  ??DataTable24_3
       4  ??DataTable24_4
       4  ??DataTable24_5
       4  ??DataTable24_6
       4  ??DataTable24_7
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_2
       4  ??DataTable25_3
       4  ??DataTable25_4
       4  ??DataTable25_5
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable26_2
       4  ??DataTable26_3
       4  ??DataTable26_4
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable27_2
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable29
       4  ??DataTable29_1
       4  ??DataTable29_2
       4  ??DataTable30
       4  ??DataTable30_1
       4  ??DataTable34
       4  ??DataTable34_1
       4  ??DataTable35
       4  ??DataTable35_1
       4  ??DataTable35_2
       4  ??DataTable36
       4  ??DataTable37
       4  ??DataTable37_1
       4  ??DataTable37_2
       4  ??DataTable37_3
       4  ??DataTable37_4
       4  ??DataTable38
       4  ??DataTable38_1
       4  ??DataTable38_2
       4  ??DataTable38_3
       4  ??DataTable38_4
       4  ??DataTable38_5
       4  ??DataTable40
       4  ??DataTable40_1
       4  ??DataTable40_2
       4  ??DataTable40_3
       4  ??DataTable40_4
       4  ??DataTable40_5
       4  ??DataTable40_6
       4  ??DataTable40_7
       4  ??DataTable40_8
      40  ?_0
      92  ?_1
      12  ?_2
      14  CLOCK_SYS_EnablePitClock
      10  CLOCK_SYS_GetPitFreq
      14  NVIC_ClearPendingIRQ
      14  NVIC_EnableIRQ
      42  PIT_HAL_ClearIntFlag
      12  PIT_HAL_Enable
      52  PIT_HAL_IsIntPending
      38  PIT_HAL_ReadTimerCount
      54  PIT_HAL_SetIntCmd
      52  PIT_HAL_SetTimerChainCmd
      40  PIT_HAL_SetTimerPeriodByCount
      48  PIT_HAL_StartTimer
      22  RTC_HAL_EnableCounter
       4  RTC_HAL_GetAlarmReg
       6  RTC_HAL_GetPrescaler
       4  RTC_HAL_GetSecsReg
      22  RTC_HAL_SetAlarmIntCmd
       4  RTC_HAL_SetAlarmReg
      14  RTC_HAL_SetPrescaler
      12  RTC_HAL_SetSecsReg
      46  SIM_HAL_EnableClock
      18  StackTimer_ISR
      42  TMR_AllocateTimer
      20  TMR_AreAllTimersOff
      92  TMR_EnableTimer
      32  TMR_FreeTimer
     210  TMR_GetRemainingTime
       6  TMR_GetTimerFreq
      12  TMR_GetTimerStatus
      12  TMR_GetTimerType
       8  TMR_GetTimestamp
     144  TMR_Init
      26  TMR_IsTimerActive
      26  TMR_IsTimerReady
      14  TMR_MakeTMRThreadReady
      40  TMR_NotCountedTicksBeforeSleep
      38  TMR_NotifyClkChanged
     126  TMR_PITGetTimestamp
     170  TMR_PITInit
      24  TMR_PIT_ISR
      48  TMR_RTCAlarmNotify
     204  TMR_RTCGetTimestamp
     136  TMR_RTCInit
       4  TMR_RTCIsOscStarted
      68  TMR_RTCSetAlarm
     176  TMR_RTCSetAlarmRelative
     190  TMR_RTCSetTime
      20  TMR_SetTimerStatus
      20  TMR_SetTimerType
      28  TMR_StartIntervalTimer
      34  TMR_StartLowPowerTimer
      30  TMR_StartMinuteTimer
      32  TMR_StartSecondTimer
      28  TMR_StartSingleShotTimer
     154  TMR_StartTimer
     140  TMR_StopTimer
     144  TMR_SyncLpmTimers
     668  TMR_Task
       8  TMR_TimeStampInit
       4  TMR_stack
       4  TMR_task_handler
      26  TmrTicksFromMilliseconds
       1  gPITInitFlag
       4  gRTCAlarmCallback
       4  gRTCAlarmCallbackParam
       1  gRTCInitFlag
       2  gRTCPrescalerOffset
       8  gRTCTimeOffset
       1  initialized
       4  mCounterFreqHz
       2  mMaxToCountDown_c
       4  mPIT_TimestampHigh
       2  mTicksFor4ms
       8  mTimerThreadEventId
       8  maTmrTimerStatusTable
     256  maTmrTimerTable
       1  numberOfActiveTimers
       1  numberOfLowPowerActiveTimers
       2  previousTimeInTicks
       1  timerHardwareIsRunning

 
   318 bytes in section .bss
   144 bytes in section .rodata
 3 982 bytes in section .text
 
 3 982 bytes of CODE  memory
   144 bytes of CONST memory
   318 bytes of DATA  memory

Errors: none
Warnings: none
