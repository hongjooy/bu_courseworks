###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       06/Apr/2016  15:58:52
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\SecLib\SecLib.c
#    Command line =  
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\SecLib\SecLib.c
#        -D DEBUG -D IAR -D CPU_MKW40Z160VHT4 -lcN "C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork\examples\ieee_802_15_4\MyStarNetwork\EndDevice\frdmkw40z\FreeRTOS\build\iar\debug\list"
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        "C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork\examples\ieee_802_15_4\MyStarNetwork\EndDevice\frdmkw40z\FreeRTOS\build\iar\debug\obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" --preinclude "C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork/examples/ieee_802_15_4/MyStarNetwork/EndDevice/frdmkw40z/FreeRTOS/app_preinclude.h"
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/CMSIS/Include\
#        -I "C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork/boards/frdmkw40z\"
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/devices\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/devices/MKW40Z4/include\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/devices/MKW40Z4/startup\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/system/src/clock/MKW40Z4\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/ieee_802_15_4/Source/App\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/ieee_802_15_4/Source/Mac/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/GPIOIrq\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/Keyboard/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/LED/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/SerialManager/Source/SPI_Adapter\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/Common\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/MemManager/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/Messaging/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/OSAbstraction/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/osa/inc\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/Panic/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/RNG/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/SerialManager/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/TimersManager/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/TimersManager/Source\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/FunctionLib\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/Lists\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/SecLib\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/ModuleInfo\
#        -I "C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork/examples/ieee_802_15_4/MyStarNetwork/EndDevice/common\"
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/devices\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/devices/MKW40Z4/startup\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/rtos/FreeRTOS/include\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/rtos/FreeRTOS/port/iar\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/rtos/FreeRTOS/config/KW40Z4/iar\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/ieee_802_15_4/Source/Phy/Source/MKW40Z\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/ieee_802_15_4/Source/Phy/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/XCVR/MKW40Z4\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/DCDC/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/Flash/Internal\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/drivers/src/flash/C90TFS/drvsrc/include\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/drivers/inc\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/system/inc\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/hal/inc\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/utilities/inc\
#        -On
#    List file    =  
#        C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork\examples\ieee_802_15_4\MyStarNetwork\EndDevice\frdmkw40z\FreeRTOS\build\iar\debug\list\SecLib.lst
#    Object file  =  
#        C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork\examples\ieee_802_15_4\MyStarNetwork\EndDevice\frdmkw40z\FreeRTOS\build\iar\debug\obj\SecLib.o
#
###############################################################################

C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\SecLib\SecLib.c
      1          /*!
      2          * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3          * All rights reserved.
      4          *
      5          * \file SecLib.c
      6          * This is the source file for the security module that implements AES.
      7          *
      8          * Redistribution and use in source and binary forms, with or without modification,
      9          * are permitted provided that the following conditions are met:
     10          *
     11          * o Redistributions of source code must retain the above copyright notice, this list
     12          *   of conditions and the following disclaimer.
     13          *
     14          * o Redistributions in binary form must reproduce the above copyright notice, this
     15          *   list of conditions and the following disclaimer in the documentation and/or
     16          *   other materials provided with the distribution.
     17          *
     18          * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     19          *   contributors may be used to endorse or promote products derived from this
     20          *   software without specific prior written permission.
     21          *
     22          * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     23          * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     24          * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     25          * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     26          * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     27          * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     28          * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     29          * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     30          * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     31          * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     32          */
     33          
     34          
     35          /*! *********************************************************************************
     36          *************************************************************************************
     37          * Include
     38          *************************************************************************************
     39          ********************************************************************************** */
     40          
     41          #include "board.h"
     42          #include "MemManager.h"
     43          #include "FunctionLib.h"
     44          #include "SecLib.h"
     45          #include "fsl_device_registers.h"
     46          #include "fsl_os_abstraction.h"
     47          
     48          #if FSL_FEATURE_SOC_MMCAU_COUNT
     49          
     50          #ifndef FREESCALE_MMCAU
     51          #define FREESCALE_MMCAU 1
     52          #endif
     53          
     54          #ifndef FREESCALE_MMCAU_SHA
     55          #define FREESCALE_MMCAU_SHA 1
     56          #endif
     57          
     58          #include "cau_api.h"
     59          #endif
     60          
     61          #if FSL_FEATURE_SOC_LTC_COUNT
     62          #include "fsl_ltc_driver.h"
     63          #endif
     64          
     65          #if gSecLib_DisallowMcuSleep_d
     66          #include "PWR_Interface.h"
     67          #endif
     68          
     69          
     70          /*! *********************************************************************************
     71          *************************************************************************************
     72          * Private macros
     73          *************************************************************************************
     74          ********************************************************************************** */
     75          /* AES constants */
     76          #define AES128 128
     77          #define AES128_ROUNDS 10
     78          
     79          #define AES192 192
     80          #define AES192_ROUNDS 12
     81          
     82          #define AES256 256
     83          #define AES256_ROUNDS 14
     84          
     85          #ifndef gLTC_IsrPrio_c
     86          #define gLTC_IsrPrio_c 0x80
     87          #endif
     88          
     89          #if gSecLib_DisallowMcuSleep_d
     90          #define SecLib_DisallowToSleep() PWR_DisallowDeviceToSleep()
     91          #define SecLib_AllowToSleep()    PWR_AllowDeviceToSleep()
     92          #else
     93          #define SecLib_DisallowToSleep()
     94          #define SecLib_AllowToSleep()
     95          #endif
     96          
     97          
     98          /*! *********************************************************************************
     99          *************************************************************************************
    100          * Private type definitions
    101          *************************************************************************************
    102          ********************************************************************************** */
    103          typedef union _uuint128_tag
    104          {
    105              uint8_t  u8[16];
    106              uint64_t u64[2];
    107          } uuint128_t;
    108          
    109          #if FSL_FEATURE_SOC_MMCAU_COUNT
    110          typedef struct mmcauAesContext_tag{
    111              uint8_t keyExpansion[44*4];
    112              uint8_t alignedIn[AES_BLOCK_SIZE];
    113              uint8_t alignedOut[AES_BLOCK_SIZE];
    114          }mmcauAesContext_t;
    115          #endif
    116          
    117          
    118          /************************************************************************************
    119          *************************************************************************************
    120          * Private memory declarations
    121          *************************************************************************************
    122          ************************************************************************************/
    123          
    124          /*! *********************************************************************************
    125          *************************************************************************************
    126          * Public prototypes
    127          *************************************************************************************
    128          ********************************************************************************** */
    129          
    130          /* AES function - SW emulated*/
    131          void sw_Aes128(const uint8_t *pData, const uint8_t *pKey, uint8_t enc, uint8_t *pReturnData);
    132          uint8_t sw_AES128_CCM(uint8_t* pInput,   uint16_t inputLen,
    133                                uint8_t* pAuthData, uint16_t authDataLen,
    134                                uint8_t* pNonce,    uint8_t  nonceSize,
    135                                uint8_t* pKey,      uint8_t* pOutput,
    136                                uint8_t* pCbcMac,   uint8_t  macSize,
    137                                uint32_t flags);
    138          
    139          /* SHA1 functions - SW emulated*/
    140          void sw_sha1_initialize_output (uint32_t *sha1_state);
    141          void sw_sha1_hash_n (uint8_t *msg_data, int32_t num_blks, uint32_t *sha1_state);
    142          void sw_sha1_hash   (uint8_t *msg_data, uint32_t *sha1_state);
    143          void sw_sha1_update (uint8_t *msg_data, int32_t num_blks, uint32_t *sha1_state);
    144          
    145          /* SHA256 functions - SW emulated*/
    146          void sw_sha256_initialize_output (uint32_t *sha256_state);
    147          void sw_sha256_hash_n (uint8_t *msg_data, int32_t num_blks, uint32_t *sha256_state);
    148          void sw_sha256_hash   (uint8_t *msg_data, uint32_t *sha256_state);
    149          void sw_sha256_update (uint8_t *msg_data, int32_t num_blks, uint32_t *sha256_state);
    150          
    151          
    152          /*! *********************************************************************************
    153          *************************************************************************************
    154          * Private prototypes
    155          *************************************************************************************
    156          ********************************************************************************** */
    157          static void SHA1_hash_n(uint8_t* pData, uint32_t nBlk, uint32_t* pHash);
    158          static void SHA256_hash_n(uint8_t* pData, uint32_t nBlk, uint32_t* pHash);
    159          static void AES_128_CMAC_Generate_Subkey(uint8_t *key, uint8_t *K1, uint8_t *K2);
    160          static void SecLib_LeftShiftOneBit(uint8_t *input, uint8_t *output);
    161          static void SecLib_Padding(uint8_t *lastb, uint8_t *pad, uint32_t length);
    162          static void SecLib_Xor128(uint8_t *a, uint8_t *b, uint8_t *out);
    163          
    164          #if FSL_FEATURE_SOC_LTC_COUNT 
    165          #if LTC_DRV_RTOS_SLEEP
    166          static void LTC_ISR(void);
    167          #endif
    168          #else
    169          static void AES_128_IncrementCounter(uint8_t* ctr);
    170          #endif
    171          
    172          
    173          /*! *********************************************************************************
    174          *************************************************************************************
    175          * Public functions
    176          *************************************************************************************
    177          ********************************************************************************** */
    178          
    179          /*! *********************************************************************************
    180          * \brief  This function performs initialization of the cryptografic HW acceleration.
    181          *
    182          ********************************************************************************** */
    183          void SecLib_Init(void)
    184          {
    185          #if FSL_FEATURE_SOC_LTC_COUNT
    186          
    187          #if LTC_DRV_RTOS_SLEEP
    188              IRQn_Type irqId = g_ltcIrqId[BOARD_LTC_INSTANCE];
    189          
    190              OSA_InstallIntHandler(irqId, LTC_ISR);
    191          
    192              NVIC_SetPriority(irqId, gLTC_IsrPrio_c >> (8 - __NVIC_PRIO_BITS));
    193              NVIC_ClearPendingIRQ(irqId);
    194              NVIC_EnableIRQ(irqId);
    195          #endif
    196              LTC_DRV_Init(BOARD_LTC_INSTANCE);
    197          #endif
    198          }
    199          
    200          /*! *********************************************************************************
    201          * \brief  This function performs AES-128 encryption on a 16-byte block.
    202          *
    203          * \param[in]  pInput Pointer to the location of the 16-byte plain text block.
    204          *
    205          * \param[in]  pKey Pointer to the location of the 128-bit key.
    206          *
    207          * \param[out]  pOutput Pointer to the location to store the 16-byte ciphered output.
    208          *
    209          * \pre All Input/Output pointers must refer to a memory address alligned to 4 bytes!
    210          *
    211          ********************************************************************************** */
    212          void AES_128_Encrypt(const uint8_t* pInput,
    213                               const uint8_t* pKey,
    214                               uint8_t* pOutput)
    215          {
    216              SecLib_DisallowToSleep();
    217          #if FSL_FEATURE_SOC_MMCAU_COUNT
    218              mmcauAesContext_t *pCtx = MEM_BufferAlloc(sizeof(mmcauAesContext_t));
    219              uint8_t* pIn;
    220              uint8_t* pOut;
    221          
    222              if ( NULL == pCtx )
    223              {
    224                  return;
    225              }
    226          
    227              /* Check if pKey is 4 bytes aligned */
    228              if ((uint32_t)pKey & 0x00000003)
    229              {
    230                  FLib_MemCpy(pCtx->alignedIn, (uint8_t*)pKey, AES_BLOCK_SIZE);
    231                  pIn = pCtx->alignedIn;
    232              }
    233              else
    234              {
    235                  pIn = (uint8_t*)pKey;
    236              }
    237          
    238              /* Expand Key */
    239              mmcau_aes_set_key(pIn, AES128, pCtx->keyExpansion);
    240          
    241              /* Check if pData is 4 bytes aligned */
    242              if ((uint32_t)pInput & 0x00000003)
    243              {
    244                  FLib_MemCpy(pCtx->alignedIn, (uint8_t*)pInput, AES_BLOCK_SIZE);
    245                  pIn = pCtx->alignedIn;
    246              }
    247              else
    248              {
    249                  pIn = (uint8_t*)pInput;
    250              }
    251          
    252              /* Check if pReturnData is 4 bytes aligned */
    253              if ((uint32_t)pOutput & 0x00000003)
    254              {
    255                  pOut = pCtx->alignedOut;
    256              }
    257              else
    258              {
    259                  pOut = pOutput;
    260              }
    261          
    262              /* Encrypt data */
    263              mmcau_aes_encrypt(pIn, pCtx->keyExpansion, AES128_ROUNDS, pOut);
    264          
    265              if (pOut == pCtx->alignedOut)
    266              {
    267                  FLib_MemCpy(pOutput, pCtx->alignedOut, AES_BLOCK_SIZE);
    268              }
    269          
    270              MEM_BufferFree(pCtx);
    271          
    272          #elif FSL_FEATURE_SOC_LTC_COUNT
    273              LTC_DRV_aes_encrypt_ecb(BOARD_LTC_INSTANCE, pInput, pKey, AES_BLOCK_SIZE, pOutput);
    274          
    275          #else
    276              sw_Aes128(pInput, pKey, 1, pOutput);
    277          #endif
    278              SecLib_AllowToSleep();
    279          }
    280          
    281          /*! *********************************************************************************
    282          * \brief  This function performs AES-128 decryption on a 16-byte block.
    283          *
    284          * \param[in]  pInput Pointer to the location of the 16-byte plain text block.
    285          *
    286          * \param[in]  pKey Pointer to the location of the 128-bit key.
    287          *
    288          * \param[out]  pOutput Pointer to the location to store the 16-byte ciphered output.
    289          *
    290          * \pre All Input/Output pointers must refer to a memory address alligned to 4 bytes!
    291          *
    292          ********************************************************************************** */
    293          void AES_128_Decrypt(const uint8_t* pInput,
    294                               const uint8_t* pKey,
    295                               uint8_t* pOutput)
    296          {
    297              SecLib_DisallowToSleep();
    298          #if FSL_FEATURE_SOC_MMCAU_COUNT
    299              mmcauAesContext_t *pCtx = MEM_BufferAlloc(sizeof(mmcauAesContext_t));
    300              uint8_t* pIn;
    301              uint8_t* pOut;
    302          
    303              if ( NULL == pCtx )
    304              {
    305                  return;
    306              }
    307          
    308              /* Check if pKey is 4 bytes aligned */
    309              if ((uint32_t)pKey & 0x00000003) 
    310              {
    311                  FLib_MemCpy( pCtx->alignedIn, (uint8_t*)pKey, AES_BLOCK_SIZE);
    312                  pIn = pCtx->alignedIn;
    313              }
    314              else
    315              {
    316                  pIn = (uint8_t*)pKey;
    317              }
    318          
    319              /* Expand Key */  
    320              mmcau_aes_set_key(pIn, AES128, pCtx->keyExpansion);
    321          
    322              /* Check if pData is 4 bytes aligned */
    323              if ((uint32_t)pInput & 0x00000003) 
    324              {
    325                  FLib_MemCpy( pCtx->alignedIn, (uint8_t*)pInput, AES_BLOCK_SIZE);
    326                  pIn = pCtx->alignedIn;
    327              }
    328              else
    329              {
    330                  pIn = (uint8_t*)pInput;
    331              }
    332          
    333              /* Check if pReturnData is 4 bytes aligned */
    334              if ((uint32_t)pOutput & 0x00000003)
    335              {
    336                  pOut = pCtx->alignedOut;
    337              }
    338              else
    339              {
    340                  pOut = pOutput;
    341              }
    342          
    343              /* Decrypt data */
    344              mmcau_aes_decrypt(pIn, pCtx->keyExpansion, AES128_ROUNDS, pOut);
    345          
    346              if (pOut == pCtx->alignedOut)
    347              {
    348                  FLib_MemCpy( pOutput, pCtx->alignedOut, AES_BLOCK_SIZE);
    349              }
    350          
    351              MEM_BufferFree(pCtx);
    352          
    353          #elif FSL_FEATURE_SOC_LTC_COUNT
    354              LTC_DRV_aes_decrypt_ecb(BOARD_LTC_INSTANCE, pInput, pKey, AES_BLOCK_SIZE, kLtcEncryptKey, pOutput);
    355          #else 
    356              sw_Aes128(pInput, pKey, 0, pOutput);
    357          #endif
    358              SecLib_AllowToSleep();
    359          }
    360          
    361          /*! *********************************************************************************
    362          * \brief  This function performs AES-128-ECB encryption on a message block.
    363          *
    364          * \param[in]  pInput Pointer to the location of the input message.
    365          *
    366          * \param[in]  inputLen Input message length in bytes.
    367          *
    368          * \param[in]  pKey Pointer to the location of the 128-bit key.
    369          *
    370          * \param[out]  pOutput Pointer to the location to store the ciphered output.
    371          *
    372          * \pre All Input/Output pointers must refer to a memory address alligned to 4 bytes!
    373          *
    374          ********************************************************************************** */
    375          void AES_128_ECB_Encrypt(uint8_t* pInput,
    376                                   uint32_t inputLen,
    377                                   uint8_t* pKey,
    378                                   uint8_t* pOutput)
    379          {
    380              uint8_t tempBuffIn[AES_BLOCK_SIZE] = {0};
    381              uint8_t tempBuffOut[AES_BLOCK_SIZE] = {0};
    382          
    383              /* If remaining data bigger than one AES block size */
    384              while( inputLen > AES_BLOCK_SIZE )
    385              {
    386                  AES_128_Encrypt(pInput, pKey, pOutput);
    387                  pInput += AES_BLOCK_SIZE;
    388                  pOutput += AES_BLOCK_SIZE;
    389                  inputLen -= AES_BLOCK_SIZE;
    390              }
    391          
    392              /* If remaining data is smaller then one AES block size */
    393              FLib_MemCpy(tempBuffIn, pInput, inputLen);
    394              AES_128_Encrypt(tempBuffIn, pKey, tempBuffOut);
    395              FLib_MemCpy(pOutput, tempBuffOut, inputLen);
    396          }
    397          
    398          /*! *********************************************************************************
    399          * \brief  This function performs AES-128-ECB encryption on a message block.
    400          *
    401          * \param[in]  pInput Pointer to the location of the input message.
    402          *
    403          * \param[in]  numBlocks Input message number of 16-byte blocks.
    404          *
    405          * \param[in]  pKey Pointer to the location of the 128-bit key.
    406          *
    407          * \param[out]  pOutput Pointer to the location to store the ciphered output.
    408          *
    409          * \pre All Input/Output pointers must refer to a memory address alligned to 4 bytes!
    410          *
    411          ********************************************************************************** */
    412          void AES_128_ECB_Block_Encrypt(uint8_t* pInput,
    413                                         uint32_t numBlocks,
    414                                         const uint8_t* pKey,
    415                                         uint8_t* pOutput)
    416          {
    417              while( numBlocks )
    418              {
    419                  AES_128_Encrypt(pInput, pKey, pOutput);
    420                  numBlocks--;
    421                  pInput += AES_BLOCK_SIZE;
    422                  pOutput += AES_BLOCK_SIZE;
    423              }
    424          }
    425          
    426          /*! *********************************************************************************
    427          * \brief  This function performs AES-128-CBC encryption on a message block.
    428          *
    429          * \param[in]  pInput Pointer to the location of the input message.
    430          *
    431          * \param[in]  inputLen Input message length in bytes.
    432          *
    433          * \param[in]  pInitVector Pointer to the location of the 128-bit initialization vector.
    434          *
    435          * \param[in]  pKey Pointer to the location of the 128-bit key.
    436          *
    437          * \param[out]  pOutput Pointer to the location to store the ciphered output.
    438          *
    439          ********************************************************************************** */
    440          void AES_128_CBC_Encrypt(uint8_t* pInput,
    441                                   uint32_t inputLen,
    442                                   uint8_t* pInitVector,
    443                                   uint8_t* pKey,
    444                                   uint8_t* pOutput)
    445          {
    446          #if FSL_FEATURE_SOC_LTC_COUNT
    447              SecLib_DisallowToSleep();
    448              LTC_DRV_aes_encrypt_cbc(BOARD_LTC_INSTANCE, pInput, inputLen, pInitVector, pKey, AES_BLOCK_SIZE, pOutput);
    449              SecLib_AllowToSleep();
    450          
    451          #else
    452              static uint8_t tempBuffIn[AES_BLOCK_SIZE] = {0};
    453              uint8_t tempBuffOut[AES_BLOCK_SIZE] = {0};
    454          
    455              if( pInitVector != NULL )
    456              {
    457                  FLib_MemCpy(tempBuffIn, pInitVector, AES_BLOCK_SIZE);
    458              }
    459          
    460              /* If remaining data is bigger than one AES block size */
    461              while( inputLen > AES_BLOCK_SIZE )
    462              {
    463                  SecLib_XorN(tempBuffIn, pInput, AES_BLOCK_SIZE);
    464                  AES_128_Encrypt(tempBuffIn, pKey, pOutput);
    465                  FLib_MemCpy(tempBuffIn, pOutput, AES_BLOCK_SIZE);
    466                  pInput += AES_BLOCK_SIZE;
    467                  pOutput += AES_BLOCK_SIZE;
    468                  inputLen -= AES_BLOCK_SIZE;
    469              }
    470          
    471              /* If remaining data is smaller then one AES block size  */
    472              SecLib_XorN(tempBuffIn, pInput, inputLen);
    473              AES_128_Encrypt(tempBuffIn, pKey, tempBuffOut);
    474              FLib_MemCpy(tempBuffIn, tempBuffOut, AES_BLOCK_SIZE);
    475              FLib_MemCpy(pOutput, tempBuffOut, inputLen);
    476          #endif
    477          }
    478          
    479          /*! *********************************************************************************
    480          * \brief  This function performs AES-128-CBC encryption on a message block after
    481          *padding it with 1 bit of 1 and 0 bits trail.
    482          *
    483          * \param[in]  pInput Pointer to the location of the input message.
    484          *
    485          * \param[in]  inputLen Input message length in bytes. 
    486          *
    487          *             IMPORTANT: User must make sure that input and output
    488          *             buffers have at least inputLen + 16 bytes size
    489          *
    490          * \param[in]  pInitVector Pointer to the location of the 128-bit initialization vector.
    491          *
    492          * \param[in]  pKey Pointer to the location of the 128-bit key.
    493          *
    494          * \param[out]  pOutput Pointer to the location to store the ciphered output.
    495          *
    496          * Return value: size of output buffer (after padding)
    497          *
    498          ********************************************************************************** */
    499          uint32_t AES_128_CBC_Encrypt_And_Pad(uint8_t* pInput, 
    500                                   uint32_t inputLen,
    501                                   uint8_t* pInitVector, 
    502                                   uint8_t* pKey, 
    503                                   uint8_t* pOutput)
    504          {
    505              uint32_t newLen = 0;
    506              uint8_t idx;
    507              /*compute new length*/
    508              newLen = inputLen + (AES_BLOCK_SIZE - (inputLen & (AES_BLOCK_SIZE-1)));
    509              /*pad the input buffer with 1 bit of 1 and trail of 0's from inputLen to newLen*/
    510              for(idx=0; idx < (newLen - inputLen)-1; idx++)
    511              {
    512                  pInput[newLen-1 - idx] = 0x00;
    513              }
    514              pInput[inputLen] = 0x80;
    515          
    516              /* CBC-Encrypt */
    517          #if FSL_FEATURE_SOC_LTC_COUNT
    518              SecLib_DisallowToSleep();
    519              LTC_DRV_aes_encrypt_cbc(BOARD_LTC_INSTANCE, pInput, newLen, pInitVector, pKey, AES_BLOCK_SIZE, pOutput);
    520              SecLib_AllowToSleep();
    521          #else
    522              static uint8_t tempBuffIn[AES_BLOCK_SIZE] = {0};
    523              
    524              if( pInitVector != NULL )
    525              {
    526                  FLib_MemCpy(tempBuffIn, pInitVector, AES_BLOCK_SIZE);
    527              }
    528              inputLen = newLen;
    529              while( inputLen > 0 )
    530              {
    531                  SecLib_XorN(tempBuffIn, pInput, AES_BLOCK_SIZE);
    532                  AES_128_Encrypt(tempBuffIn, pKey, pOutput);
    533                  FLib_MemCpy(tempBuffIn, pOutput, AES_BLOCK_SIZE);
    534                  pInput += AES_BLOCK_SIZE;
    535                  pOutput += AES_BLOCK_SIZE;
    536                  inputLen -= AES_BLOCK_SIZE;
    537              }
    538          #endif
    539              return newLen;
    540          }
    541          /*! *********************************************************************************
    542          * \brief  This function performs AES-128-CBC decryption on a message block.
    543          *
    544          * \param[in]  pInput Pointer to the location of the input message.
    545          *
    546          * \param[in]  inputLen Input message length in bytes.
    547          *
    548          * \param[in]  pInitVector Pointer to the location of the 128-bit initialization vector.
    549          *
    550          * \param[in]  pKey Pointer to the location of the 128-bit key.
    551          *
    552          * \param[out]  pOutput Pointer to the location to store the ciphered output.
    553          *
    554          * Return value: size of output buffer (after depadding)
    555          *
    556          ********************************************************************************** */
    557          uint32_t AES_128_CBC_Decrypt_And_Depad(uint8_t* pInput, 
    558                                                 uint32_t inputLen,
    559                                                 uint8_t* pInitVector, 
    560                                                 uint8_t* pKey, 
    561                                                 uint8_t* pOutput)
    562          {
    563              uint32_t newLen = inputLen;
    564          #if FSL_FEATURE_SOC_LTC_COUNT
    565              SecLib_DisallowToSleep();
    566              LTC_DRV_aes_decrypt_cbc(BOARD_LTC_INSTANCE, pInput, inputLen, pInitVector, pKey,
    567                                      AES_BLOCK_SIZE, kLtcDecryptKey, pOutput);
    568              SecLib_AllowToSleep();
    569          
    570          #else
    571              static uint8_t temp[2*AES_BLOCK_SIZE] = {0};
    572          
    573              if((inputLen & (AES_BLOCK_SIZE - 1)) != 0)
    574              {
    575                  return 0;
    576              }
    577          
    578              if(pInitVector != NULL)
    579              {
    580                  FLib_MemCpy(temp, pInitVector, AES_BLOCK_SIZE);
    581              }
    582          
    583              FLib_MemCpy(temp + AES_BLOCK_SIZE, pInput, AES_BLOCK_SIZE);
    584          
    585              while( inputLen > 0 )
    586              {
    587                  AES_128_Decrypt(pInput, pKey, pOutput);
    588                  
    589                  SecLib_XorN(pOutput, temp, AES_BLOCK_SIZE);
    590                  
    591                  pInput += AES_BLOCK_SIZE;
    592                  pOutput += AES_BLOCK_SIZE;
    593                  inputLen -= AES_BLOCK_SIZE;
    594                  
    595                  FLib_MemCpy(temp, temp + AES_BLOCK_SIZE, AES_BLOCK_SIZE);
    596                  if(inputLen > 0)
    597                  {
    598                      FLib_MemCpy(temp + AES_BLOCK_SIZE, pInput, AES_BLOCK_SIZE);
    599                  }
    600              }
    601          
    602              pOutput -= newLen;
    603          #endif
    604              while( (pOutput[--newLen] != 0x80) && (newLen !=0) );
    605              return newLen;
    606          }
    607          /*! *********************************************************************************
    608          * \brief  This function performs AES-128-CTR encryption on a message block.
    609          *
    610          * \param[in]  pInput Pointer to the location of the input message.
    611          *
    612          * \param[in]  inputLen Input message length in bytes.
    613          *
    614          * \param[in]  pCounter Pointer to the location of the 128-bit counter.
    615          *
    616          * \param[in]  pKey Pointer to the location of the 128-bit key.
    617          *
    618          * \param[out]  pOutput Pointer to the location to store the ciphered output.
    619          *
    620          ********************************************************************************** */
    621          void AES_128_CTR(uint8_t* pInput,
    622                           uint32_t inputLen,
    623                           uint8_t* pCounter,
    624                           uint8_t* pKey,
    625                           uint8_t* pOutput)
    626          {
    627          #if FSL_FEATURE_SOC_LTC_COUNT
    628              SecLib_DisallowToSleep();
    629              LTC_DRV_aes_encrypt_ctr(BOARD_LTC_INSTANCE, pInput, inputLen, pCounter, pKey, AES_BLOCK_SIZE, pOutput, NULL, NULL);
    630              SecLib_AllowToSleep();
    631          
    632          #else
    633              uint8_t tempBuffIn[AES_BLOCK_SIZE] = {0};
    634              uint8_t encrCtr[AES_BLOCK_SIZE] = {0};
    635          
    636              /* If remaining data bigger than one AES block size */
    637              while( inputLen > AES_BLOCK_SIZE )
    638              {
    639                  FLib_MemCpy(tempBuffIn, pInput, AES_BLOCK_SIZE);
    640                  AES_128_Encrypt(pCounter, pKey, encrCtr);
    641                  SecLib_XorN(tempBuffIn, encrCtr, AES_BLOCK_SIZE);
    642                  FLib_MemCpy(pOutput, tempBuffIn, AES_BLOCK_SIZE);
    643                  pInput += AES_BLOCK_SIZE;
    644                  pOutput += AES_BLOCK_SIZE;
    645                  inputLen -= AES_BLOCK_SIZE;
    646                  AES_128_IncrementCounter(pCounter);
    647              }
    648          
    649              /* If remaining data is smaller then one AES block size  */
    650              FLib_MemCpy(tempBuffIn, pInput, inputLen);
    651              AES_128_Encrypt(pCounter, pKey, encrCtr);
    652              SecLib_XorN(tempBuffIn, encrCtr, AES_BLOCK_SIZE);
    653              FLib_MemCpy(pOutput, tempBuffIn, inputLen);
    654              AES_128_IncrementCounter(pCounter);
    655          #endif
    656          }
    657          
    658          /*! *********************************************************************************
    659          * \brief  This function performs AES-128-OFB encryption on a message block.
    660          *
    661          * \param[in]  pInput Pointer to the location of the input message.
    662          *
    663          * \param[in]  inputLen Input message length in bytes.
    664          *
    665          * \param[in]  pInitVector Pointer to the location of the 128-bit initialization vector.
    666          *
    667          * \param[in]  pKey Pointer to the location of the 128-bit key.
    668          *
    669          * \param[out]  pOutput Pointer to the location to store the ciphered output.
    670          *
    671          ********************************************************************************** */
    672          void AES_128_OFB(uint8_t* pInput,
    673                           uint32_t inputLen,
    674                           uint8_t* pInitVector,
    675                           uint8_t* pKey,
    676                           uint8_t* pOutput)
    677          {
    678              uint8_t tempBuffIn[AES_BLOCK_SIZE] = {0};
    679              uint8_t tempBuffOut[AES_BLOCK_SIZE] = {0};
    680          
    681              if( pInitVector != NULL )
    682              {
    683                  FLib_MemCpy(tempBuffIn, pInitVector, AES_BLOCK_SIZE);
    684              }
    685          
    686              /* If remaining data is bigger than one AES block size */
    687              while( inputLen > AES_BLOCK_SIZE )
    688              {
    689                  AES_128_Encrypt(tempBuffIn, pKey, tempBuffOut);
    690                  FLib_MemCpy(tempBuffIn, tempBuffOut, AES_BLOCK_SIZE);
    691                  SecLib_XorN(tempBuffOut, pInput, AES_BLOCK_SIZE);
    692                  FLib_MemCpy(pOutput, tempBuffOut, AES_BLOCK_SIZE);
    693                  pInput += AES_BLOCK_SIZE;
    694                  pOutput += AES_BLOCK_SIZE;
    695                  inputLen -= AES_BLOCK_SIZE;
    696              }
    697          
    698              /* If remaining data is smaller then one AES block size  */
    699              AES_128_Encrypt(tempBuffIn, pKey, tempBuffOut);
    700              FLib_MemCpy(tempBuffIn, tempBuffOut, AES_BLOCK_SIZE);
    701              SecLib_XorN(tempBuffOut, pInput, inputLen);
    702              FLib_MemCpy(pOutput, tempBuffOut, inputLen);
    703          }
    704          
    705          /*! *********************************************************************************
    706          * \brief  This function performs AES-128-CMAC on a message block.
    707          *
    708          * \param[in]  pInput Pointer to the location of the input message.
    709          *
    710          * \param[in]  inputLen Length of the input message in bytes. The input data must be provided MSB first.
    711          *
    712          * \param[in]  pKey Pointer to the location of the 128-bit key. The key must be provided MSB first.
    713          *
    714          * \param[out]  pOutput Pointer to the location to store the 16-byte authentication code. The code will be generated MSB first.
    715          *
    716          * \remarks This is public open source code! Terms of use must be checked before use!
    717          *
    718          ********************************************************************************** */
    719          void AES_128_CMAC(uint8_t* pInput,
    720                            uint32_t inputLen,
    721                            uint8_t* pKey,
    722                            uint8_t* pOutput)
    723          {
    724              uint8_t X[16];
    725              uint8_t Y[16];
    726              uint8_t M_last[16];
    727              uint8_t padded[16];
    728          
    729              uint8_t K1[16];
    730              uint8_t K2[16];
    731          
    732              uint8_t n;
    733              uint32_t i;
    734              uint8_t flag;
    735          
    736              AES_128_CMAC_Generate_Subkey(pKey, K1, K2);
    737          
    738              n = (uint8_t) ((inputLen + 15) / 16); /* n is number of rounds */
    739          
    740              if (n == 0) {
    741                  n = 1;
    742                  flag = 0;
    743              } else {
    744                  if ((inputLen % 16) == 0) { /* last block is a complete block */
    745                      flag = 1;
    746                  } else { /* last block is not complete block */
    747                      flag = 0;
    748                  }
    749              }
    750          
    751              /* Process the last block  - the last part the MSB first input data */
    752              if (flag) { /* last block is complete block */
    753                  SecLib_Xor128(&pInput[16 * (n - 1)], K1, M_last);
    754              } else {
    755                  SecLib_Padding(&pInput[16 * (n - 1)], padded, inputLen % 16);
    756                  SecLib_Xor128(padded, K2, M_last);
    757              }
    758          
    759              for (i = 0; i < 16; i++)
    760                  X[i] = 0;
    761          
    762              for (i = 0; i < n - 1; i++) {
    763                  SecLib_Xor128(X, &pInput[16 * i], Y); /* Y := Mi (+) X  */
    764                  AES_128_Encrypt(Y, pKey, X); /* X := AES-128(KEY, Y); */
    765              }
    766          
    767              SecLib_Xor128(X, M_last, Y);
    768              AES_128_Encrypt(Y, pKey, X);
    769          
    770              for (i = 0; i < 16; i++) {
    771                  pOutput[i] = X[i];
    772              }
    773          }
    774          
    775          
    776          /*! *********************************************************************************
    777          * \brief  This function performs AES-128-CMAC on a message block accepting input data
    778          *         which is in LSB first format and computing the authentication code starting fromt he end of the data.
    779          * 
    780          * \param[in]  pInput Pointer to the location of the input message.
    781          *
    782          * \param[in]  inputLen Length of the input message in bytes. The input data must be provided LSB first.
    783          *
    784          * \param[in]  pKey Pointer to the location of the 128-bit key. The key must be provided MSB first.
    785          *
    786          * \param[out]  pOutput Pointer to the location to store the 16-byte authentication code. The code will be generated MSB first.
    787          *
    788          ********************************************************************************** */
    789          void AES_128_CMAC_LsbFirstInput (uint8_t* pInput,
    790                                           uint32_t inputLen,
    791                                           uint8_t* pKey,
    792                                           uint8_t* pOutput)
    793          {
    794              uint8_t X[16];
    795              uint8_t Y[16];
    796              uint8_t M_last[16];
    797              uint8_t padded[16];
    798              uint8_t reversedBlock[16];
    799          
    800              uint8_t K1[16];
    801              uint8_t K2[16];
    802          
    803              uint8_t n;
    804              uint32_t i;
    805              uint8_t flag;
    806          
    807              AES_128_CMAC_Generate_Subkey(pKey, K1, K2);
    808          
    809              n = (uint8_t) ((inputLen + 15) / 16); /* n is number of rounds */
    810          
    811              if (n == 0)
    812              {
    813                  n = 1;
    814                  flag = 0;
    815              } 
    816              else
    817              {
    818                  if ((inputLen % 16) == 0) /* last block is a complete block */
    819                  {
    820                      flag = 1;
    821                  }
    822                  else /* last block is not complete block */
    823                  { 
    824                      flag = 0;
    825                  }
    826              }
    827              
    828              /* Process the last block  - the first part the LSB first input data */
    829              if (flag)  /* last block is complete block */
    830              {
    831                  FLib_MemCpyReverseOrder (reversedBlock, &pInput[0], 16);
    832                  SecLib_Xor128 (reversedBlock, K1, M_last);
    833              } 
    834              else 
    835              {
    836                  FLib_MemCpyReverseOrder (reversedBlock, &pInput[0], inputLen % 16);
    837                  SecLib_Padding(reversedBlock, padded, inputLen % 16);
    838                  SecLib_Xor128(padded, K2, M_last);
    839              }
    840          
    841              for (i = 0; i < 16; i++)
    842              {
    843                  X[i] = 0;
    844              }
    845              
    846              for (i = 0; i < n - 1; i++)
    847              {
    848                  FLib_MemCpyReverseOrder (reversedBlock, &pInput[inputLen - 16 * (i + 1)], 16);
    849                  SecLib_Xor128(X, reversedBlock, Y); /* Y := Mi (+) X  */
    850                  AES_128_Encrypt(Y, pKey, X); /* X := AES-128(KEY, Y); */
    851              }
    852          
    853              SecLib_Xor128(X, M_last, Y);
    854              AES_128_Encrypt(Y, pKey, X);
    855          
    856              for (i = 0; i < 16; i++) {
    857                  pOutput[i] = X[i];
    858              }
    859          }
    860          
    861          
    862          /*! *********************************************************************************
    863          * \brief  This function performs AES 128 CMAC Pseudo-Random Function (AES-CMAC-PRF-128),
    864          *         according to rfc4615, on a message block.
    865          * 
    866          * \details The AES-CMAC-PRF-128 algorithm behaves similar to teh AES CMAC 128 algorithm
    867          *          but removes 128 bit key size restriction.
    868          *
    869          * \param[in]  pInput Pointer to the location of the input message.
    870          *
    871          * \param[in]  inputLen Length of the input message in bytes.
    872          *
    873          * \param[in]  pVarKey Pointer to the location of the variable length key.
    874          *
    875          * \param[in]  varKeyLen Length of the input key in bytes
    876          *
    877          * \param[out]  pOutput Pointer to the location to store the 16-byte pseudo random variable.
    878          *
    879          ********************************************************************************** */
    880          void AES_CMAC_PRF_128(uint8_t* pInput, 
    881                                uint32_t inputLen, 
    882                                uint8_t* pVarKey,
    883                                uint32_t varKeyLen,
    884                                uint8_t* pOutput)
    885          {
    886              uint8_t  K[16];  /*!< Temporary key location to be used if the key length is not 16 bytes. */
    887              uint8_t* pCmacKey = pVarKey; /*!<  Pointer to the key used by the CMAC operation which generates the
    888                                            *    output. */
    889              
    890              if (0 == varKeyLen)
    891              {
    892                  /*! If the key length is 0 return immediately.
    893                   *  This is an erroneous situation. */
    894                  return;
    895              }
    896              
    897              if (varKeyLen != 16)
    898              {
    899                  uint8_t K0[16] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    900                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
    901                  /*! Perform AES 128 CMAC on the variable key if it has a length which
    902                   *  is different from 16 bytes using a 128 bit key with all zeroes and
    903                   *  set the CMAC key to point to the result. */
    904                  AES_128_CMAC(pVarKey, varKeyLen, K0, K);
    905                  pCmacKey = K;
    906              }
    907              
    908              /*! Perform the CMAC operation which generates the output using the local
    909               *  key pointer whcih will be set to the initial key or the generated one. */
    910              AES_128_CMAC(pInput, inputLen, pCmacKey, pOutput);
    911          }
    912          
    913          /*! *********************************************************************************
    914          * \brief  This function performs AES-128-EAX encryption on a message block.
    915          *
    916          * \param[in]  pInput Pointer to the location of the input message.
    917          *
    918          * \param[in]  inputLen Length of the input message in bytes.
    919          *
    920          * \param[in]  pNonce Pointer to the location of the nonce.
    921          *
    922          * \param[in]  nonceLen Nonce length in bytes.
    923          *
    924          * \param[in]  pHeader Pointer to the location of header.
    925          *
    926          * \param[in]  headerLen Header length in bytes.
    927          *
    928          * \param[in]  pKey Pointer to the location of the 128-bit key.
    929          *
    930          * \param[out]  pOutput Pointer to the location to store the 16-byte authentication code.
    931          *
    932          * \param[out]  pTag Pointer to the location to store the 128-bit tag.
    933          *
    934          ********************************************************************************** */
    935          secResultType_t AES_128_EAX_Encrypt(uint8_t* pInput,
    936                                              uint32_t inputLen,
    937                                              uint8_t* pNonce,
    938                                              uint32_t nonceLen,
    939                                              uint8_t* pHeader,
    940                                              uint8_t headerLen,
    941                                              uint8_t* pKey,
    942                                              uint8_t* pOutput,
    943                                              uint8_t* pTag)
    944          {
    945              uint8_t *buf;
    946              uint32_t buf_len;
    947              uint8_t nonce_mac[AES_BLOCK_SIZE];
    948              uint8_t hdr_mac[AES_BLOCK_SIZE];
    949              uint8_t data_mac[AES_BLOCK_SIZE];
    950              uint8_t tempBuff[AES_BLOCK_SIZE];
    951              uint32_t i;
    952          
    953              if( nonceLen > inputLen )
    954              {
    955                  buf_len = nonceLen;
    956              }
    957              else
    958              {
    959                  buf_len = inputLen;
    960              }
    961          
    962              if( headerLen > buf_len )
    963              {
    964                  buf_len = headerLen;
    965              }
    966          
    967              buf_len += 16U;
    968          
    969              buf = MEM_BufferAlloc(buf_len);
    970          
    971              if( buf == NULL )
    972                  return gSecAllocError_c;
    973          
    974              FLib_MemSet(buf, 0, 15);
    975          
    976              buf[15] = 0;
    977              FLib_MemCpy((buf + 16), pNonce, nonceLen);
    978              AES_128_CMAC(buf, 16 + nonceLen, pKey, nonce_mac);
    979          
    980              buf[15] = 1;
    981              FLib_MemCpy((buf + 16), pHeader, headerLen);
    982              AES_128_CMAC(buf, 16 + headerLen, pKey, hdr_mac);
    983          
    984              /* keep the original value of nonce_mac, because AES_128_CTR will increment it */
    985              FLib_MemCpy(tempBuff, nonce_mac, nonceLen);
    986          
    987              AES_128_CTR(pInput, inputLen, tempBuff, pKey, pOutput);
    988          
    989              buf[15] = 2;
    990              FLib_MemCpy((buf + 16), pOutput, inputLen);
    991              AES_128_CMAC(buf, 16 + inputLen, pKey, data_mac);
    992          
    993              for (i = 0; i < AES_BLOCK_SIZE; i++)
    994              {
    995                  pTag[i] = nonce_mac[i] ^ data_mac[i] ^ hdr_mac[i];
    996              }
    997          
    998              MEM_BufferFree(buf);
    999          
   1000              return gSecSuccess_c;
   1001          }
   1002          
   1003          /*! *********************************************************************************
   1004          * \brief  This function performs AES-128-EAX decryption on a message block.
   1005          *
   1006          * \param[in]  pInput Pointer to the location of the input message.
   1007          *
   1008          * \param[in]  inputLen Length of the input message in bytes.
   1009          *
   1010          * \param[in]  pNonce Pointer to the location of the nonce.
   1011          *
   1012          * \param[in]  nonceLen Nonce length in bytes.
   1013          *
   1014          * \param[in]  pHeader Pointer to the location of header.
   1015          *
   1016          * \param[in]  headerLen Header length in bytes.
   1017          *
   1018          * \param[in]  pKey Pointer to the location of the 128-bit key.
   1019          *
   1020          * \param[out]  pOutput Pointer to the location to store the 16-byte authentication code.
   1021          *
   1022          * \param[out]  pTag Pointer to the location to store the 128-bit tag.
   1023          *
   1024          ********************************************************************************** */
   1025          secResultType_t AES_128_EAX_Decrypt(uint8_t* pInput,
   1026                                              uint32_t inputLen,
   1027                                              uint8_t* pNonce,
   1028                                              uint32_t nonceLen,
   1029                                              uint8_t* pHeader,
   1030                                              uint8_t headerLen,
   1031                                              uint8_t* pKey,
   1032                                              uint8_t* pOutput,
   1033                                              uint8_t* pTag)
   1034          {
   1035              uint8_t *buf;
   1036              uint32_t buf_len;
   1037              uint8_t nonce_mac[AES_BLOCK_SIZE];
   1038              uint8_t hdr_mac[AES_BLOCK_SIZE];
   1039              uint8_t data_mac[AES_BLOCK_SIZE];
   1040              uint32_t i;
   1041          
   1042              if( nonceLen > inputLen )
   1043              {
   1044                  buf_len = nonceLen;
   1045              }
   1046              else
   1047              {
   1048                  buf_len = inputLen;
   1049              }
   1050          
   1051              if( headerLen > buf_len )
   1052              {
   1053                  buf_len = headerLen;
   1054              }
   1055          
   1056              buf_len += 16U;
   1057          
   1058              buf = MEM_BufferAlloc(buf_len);
   1059          
   1060              if( buf == NULL )
   1061                  return gSecAllocError_c;
   1062          
   1063              FLib_MemSet(buf, 0, 15);
   1064          
   1065              buf[15] = 0;
   1066              FLib_MemCpy((buf + 16), pNonce, nonceLen);
   1067              AES_128_CMAC(buf, 16 + nonceLen, pKey, nonce_mac);
   1068          
   1069              buf[15] = 1;
   1070              FLib_MemCpy((buf + 16), pHeader, headerLen);
   1071              AES_128_CMAC(buf, 16 + headerLen, pKey, hdr_mac);
   1072          
   1073              buf[15] = 2;
   1074              FLib_MemCpy((buf + 16), pInput, inputLen);
   1075              AES_128_CMAC(buf, 16 + inputLen, pKey, data_mac);
   1076          
   1077              MEM_BufferFree(buf);
   1078          
   1079              for (i = 0; i < AES_BLOCK_SIZE; i++)
   1080              {
   1081                  if (pTag[i] != (nonce_mac[i] ^ data_mac[i] ^ hdr_mac[i]))
   1082                      return gSecError_c;
   1083              }
   1084          
   1085              AES_128_CTR(pInput, inputLen, nonce_mac, pKey, pOutput);
   1086          
   1087              return gSecSuccess_c;
   1088          }
   1089          
   1090          /*! *********************************************************************************
   1091          * \brief  This function performs AES-128-CCM on a message block.
   1092          *
   1093          * \param[in]  pInput       Pointer to the location of the input message (plaintext or cyphertext).
   1094          *
   1095          * \param[in]  inputLen     Length of the input plaintext in bytes when encrypting.
   1096          *                          Length of the input cypertext without the MAC length when decrypting.
   1097          * 
   1098          * \param[in]  pAuthData    Pointer to the additional authentication data.
   1099          *
   1100          * \param[in]  authDataLen  Length of additional authentication data.
   1101          *
   1102          * \param[in]  pNonce       Pointer to the Nonce.
   1103          *
   1104          * \param[in]  nonceSize    The size of the nonce (7-13).
   1105          *
   1106          * \param[in]  pKey         Pointer to the location of the 128-bit key.
   1107          *
   1108          * \param[out]  pOutput     Pointer to the location to store the plaintext data when decrypting.
   1109          *                          Pointer to the location to store the cyphertext data when encrypting.
   1110          *
   1111          * \param[out]  pCbcMac     Pointer to the location to store the Message Authentication Code (MAC) when encrypting.
   1112          *                          Pointer to the location where the received MAC can be found when decrypting.
   1113          *
   1114          * \param[out]  macSize     The size of the MAC.
   1115          *
   1116          * \param[out]  flags       Select encrypt/decrypt operations (gSecLib_CCM_Encrypt_c, gSecLib_CCM_Decrypt_c)
   1117          *
   1118          * \return 0 if encryption/decryption was successfull; otherwise, error code for failed encryption/decryption
   1119          *
   1120          * \remarks At decryption, MIC fail is also signaled by returning a non-zero value.
   1121          *
   1122          ********************************************************************************** */
   1123          uint8_t AES_128_CCM(uint8_t* pInput,
   1124                              uint16_t inputLen,
   1125                              uint8_t* pAuthData,
   1126                              uint16_t authDataLen,
   1127                              uint8_t* pNonce,
   1128                              uint8_t  nonceSize,
   1129                              uint8_t* pKey,
   1130                              uint8_t* pOutput,
   1131                              uint8_t* pCbcMac,
   1132                              uint8_t  macSize,
   1133                              uint32_t flags)
   1134          {
   1135              uint8_t status;
   1136          
   1137              SecLib_DisallowToSleep();
   1138          
   1139          #if FSL_FEATURE_SOC_LTC_COUNT
   1140              if( flags & gSecLib_CCM_Decrypt_c )
   1141              {
   1142                  status = LTC_DRV_aes_decrypt_tag_ccm(BOARD_LTC_INSTANCE, pInput, inputLen, pNonce, nonceSize, pAuthData, authDataLen, pKey, AES_BLOCK_SIZE, pOutput, pCbcMac, macSize);
   1143              }
   1144              else
   1145              {
   1146                  status = LTC_DRV_aes_encrypt_tag_ccm(BOARD_LTC_INSTANCE, pInput, inputLen, pNonce, nonceSize, pAuthData, authDataLen, pKey, AES_BLOCK_SIZE, pOutput, pCbcMac, macSize);
   1147              }
   1148          
   1149          #else
   1150                  status = sw_AES128_CCM(pInput, inputLen, pAuthData, authDataLen, pNonce, nonceSize, pKey, pOutput, pCbcMac, macSize, flags);
   1151          #endif
   1152          
   1153              SecLib_AllowToSleep();
   1154          
   1155              return status;
   1156          }
   1157          
   1158          /*! *********************************************************************************
   1159          * \brief  This function calculates XOR of individual byte pairs in two uint8_t arrays.
   1160          *         pDst[i] := pDst[i] ^ pSrc[i] for i=0 to n-1
   1161          *
   1162          * \param[in, out]  pDst First byte array operand for XOR and destination byte array
   1163          *
   1164          * \param[in]  pSrc Second byte array operand for XOR
   1165          *
   1166          * \param[in]  n  Length of the byte arrays which will be XORed
   1167          *
   1168          ********************************************************************************** */
   1169          void SecLib_XorN(uint8_t* pDst,
   1170                           uint8_t* pSrc,
   1171                           uint8_t n)
   1172          {
   1173              while( n )
   1174              {
   1175                  *pDst = *pDst ^ *pSrc;
   1176                  pDst = pDst + 1;
   1177                  pSrc = pSrc + 1;
   1178                  n--;
   1179              }
   1180          }
   1181          
   1182          /*! *********************************************************************************
   1183          *************************************************************************************
   1184          * Private functions
   1185          *************************************************************************************
   1186          ********************************************************************************** */
   1187          
   1188          #if !(FSL_FEATURE_SOC_LTC_COUNT)
   1189          /*! *********************************************************************************
   1190          * \brief  Increments the value of a given counter vector.
   1191          *
   1192          * \param [in/out]     ctr         Counter.
   1193          *
   1194          * \remarks
   1195          *
   1196          ********************************************************************************** */
   1197          static void AES_128_IncrementCounter(uint8_t* ctr)
   1198          {
   1199              uint32_t i;
   1200              uint64_t tempLow;
   1201              uuint128_t tempCtr;
   1202          
   1203              for(i=0;i<AES_BLOCK_SIZE;i++)
   1204              {
   1205                  tempCtr.u8[AES_BLOCK_SIZE-i-1] = ctr[i];
   1206              }
   1207          
   1208              tempLow = tempCtr.u64[0];
   1209              tempCtr.u64[0]++;
   1210          
   1211              if(tempLow > tempCtr.u64[0])
   1212              {
   1213                  tempCtr.u64[1]++;
   1214              }
   1215          
   1216              for(i=0;i<AES_BLOCK_SIZE;i++)
   1217              {
   1218                  ctr[i] = tempCtr.u8[AES_BLOCK_SIZE-i-1];
   1219              }
   1220          }
   1221          #endif /* !(FSL_FEATURE_SOC_LTC_COUNT) */
   1222          
   1223          /*! *********************************************************************************
   1224          * \brief  Generates the two subkeys that correspond two an AES key
   1225          *
   1226          * \param [in]    key        AES Key.
   1227          *
   1228          * \param [out]   K1         First subkey.
   1229          *
   1230          * \param [out]   K2         Second subkey.
   1231          *
   1232          * \remarks   This is public open source code! Terms of use must be checked before use!
   1233          *
   1234          ********************************************************************************** */
   1235          static void AES_128_CMAC_Generate_Subkey(uint8_t *key,
   1236                                                   uint8_t *K1,
   1237                                                   uint8_t *K2)
   1238          {
   1239              uint8_t const_Rb[16] = {0x00, 0x00, 0x00, 0x00,
   1240                                      0x00, 0x00, 0x00, 0x00,
   1241                                      0x00, 0x00, 0x00, 0x00,
   1242                                      0x00, 0x00, 0x00, 0x87};
   1243              uint8_t L[16];
   1244              uint8_t Z[16];
   1245              uint8_t tmp[16];
   1246              uint32_t i;
   1247          
   1248              for ( i=0; i<16; i++ ) Z[i] = 0;
   1249          
   1250              AES_128_Encrypt(Z,key,L);
   1251          
   1252              if ( (L[0] & 0x80) == 0 )
   1253              {
   1254                  /* If MSB(L) = 0, then K1 = L << 1 */
   1255                  SecLib_LeftShiftOneBit(L,K1);
   1256              }
   1257              else
   1258              {
   1259                  /* Else K1 = ( L << 1 ) (+) Rb */
   1260                  SecLib_LeftShiftOneBit(L,tmp);
   1261                  SecLib_Xor128(tmp,const_Rb,K1);
   1262              }
   1263          
   1264              if ( (K1[0] & 0x80) == 0 )
   1265              {
   1266                  SecLib_LeftShiftOneBit(K1,K2);
   1267              }
   1268              else
   1269              {
   1270                  SecLib_LeftShiftOneBit(K1,tmp);
   1271                  SecLib_Xor128(tmp,const_Rb,K2);
   1272              }
   1273          }
   1274          
   1275          /*! *********************************************************************************
   1276          * \brief    Shifts a given vector to the left with one bit.
   1277          *
   1278          * \param [in]      input         Input vector.
   1279          *
   1280          * \param [out]     output        Output vector.
   1281          *
   1282          * \remarks   This is public open source code! Terms of use must be checked before use!
   1283          *
   1284          ********************************************************************************** */
   1285          static void SecLib_LeftShiftOneBit(uint8_t *input,
   1286                                             uint8_t *output)
   1287          {
   1288              int32_t i;
   1289              uint8_t overflow = 0;
   1290          
   1291              for ( i=15; i>=0; i-- )
   1292              {
   1293                  output[i] = input[i] << 1;
   1294                  output[i] |= overflow;
   1295                  overflow = (input[i] & 0x80) ? 1 : 0;
   1296              }
   1297          }
   1298          
   1299          /*! *********************************************************************************
   1300          * \brief  This function pads an incomplete 16 byte block of data, where padding is 
   1301          *         the concatenation of x and a single '1',
   1302          *         followed by the minimum number of '0's, so that the total length is equal to 128 bits.
   1303          *
   1304          * \param[in, out] lastb Pointer to the last block to be padded
   1305          *
   1306          * \param[in]  pad       Padded block destination
   1307          *
   1308          * \param[in]  length    Number of bytes in the block to be padded
   1309          *
   1310          * \remarks   This is public open source code! Terms of use must be checked before use!
   1311          *
   1312          ********************************************************************************** */
   1313          static void SecLib_Padding(uint8_t *lastb,
   1314                                     uint8_t *pad,
   1315                                     uint32_t length)
   1316          {
   1317              uint32_t j;
   1318          
   1319              /* original last block */
   1320              for ( j=0; j<16; j++ ) {
   1321                  if ( j < length ) {
   1322                      pad[j] = lastb[j];
   1323                  } else if ( j == length ) {
   1324                      pad[j] = 0x80;
   1325                  } else {
   1326                      pad[j] = 0x00;
   1327                  }
   1328              }
   1329          }
   1330          
   1331          /*! *********************************************************************************
   1332          * \brief  This function Xors 2 blocks of 128 bits and copies the result to a set destination
   1333          *
   1334          * \param [in]    a        Pointer to the first block to XOR
   1335          *
   1336          * \param [in]    b        Pointer to the second block to XOR.
   1337          *
   1338          * \param [out]   out      Destination pointer
   1339          *
   1340          * \remarks   This is public open source code! Terms of use must be checked before use!
   1341          *
   1342          ********************************************************************************** */
   1343          static void SecLib_Xor128(uint8_t *a,
   1344                                    uint8_t *b,
   1345                                    uint8_t *out)
   1346          {
   1347              uint32_t i;
   1348          
   1349              for (i=0;i<16; i++)
   1350              {
   1351                out[i] = a[i] ^ b[i];
   1352              }
   1353          }
   1354          
   1355          
   1356          /*! *********************************************************************************
   1357          * \brief  This function initializes the SHA1 context data
   1358          *
   1359          * \param [in]    ctx        Pointer to the SHA1 context data
   1360          *
   1361          ********************************************************************************** */
   1362          void SHA1_Init(sha1Context_t * ctx)
   1363          {
   1364              ctx->bytes = 0;
   1365              ctx->totalBytes = 0;
   1366          #if FSL_FEATURE_SOC_MMCAU_COUNT
   1367              (void)mmcau_sha1_initialize_output(ctx->hash);
   1368          #else
   1369              sw_sha1_initialize_output(ctx->hash);
   1370          #endif
   1371          }
   1372          
   1373          /*! *********************************************************************************
   1374          * \brief  This function performs SHA1 on multiple bytes, and updates the context data
   1375          *
   1376          * \param [in]    pData      Pointer to the input data
   1377          * \param [in]    numBytes   Number of bytes to hash
   1378          * \param [in]    ctx        Pointer to the SHA1 context data
   1379          *
   1380          ********************************************************************************** */
   1381          void SHA1_HashUpdate(sha1Context_t* ctx, uint8_t* pData, uint32_t numBytes)
   1382          {
   1383              uint16_t blocks;
   1384          
   1385              /* update total byte count */
   1386              ctx->totalBytes += numBytes;
   1387              /* Check if we have at least 1 SHA1 block */
   1388              if( ctx->bytes + numBytes < SHA1_BLOCK_SIZE )
   1389              {
   1390                  /* store bytes for later processing */
   1391                  FLib_MemCpy(&ctx->buffer[ctx->bytes], pData, numBytes);
   1392                  ctx->bytes += numBytes;
   1393                  return;
   1394              }
   1395              /* Check for bytes leftover from previous update */
   1396              if( ctx->bytes )
   1397              {
   1398                  uint8_t copyBytes = SHA1_BLOCK_SIZE - ctx->bytes;
   1399          
   1400                  FLib_MemCpy(&ctx->buffer[ctx->bytes], pData, copyBytes);
   1401                  SHA1_hash_n(ctx->buffer, 1, ctx->hash);
   1402                  pData += copyBytes;
   1403                  numBytes -= copyBytes;
   1404                  ctx->bytes = 0;
   1405              }
   1406              /* Hash 64 bytes blocks */
   1407              blocks = numBytes/SHA1_BLOCK_SIZE;
   1408              SHA1_hash_n(pData, blocks, ctx->hash);
   1409              numBytes -= blocks*SHA1_BLOCK_SIZE;
   1410              pData += blocks*SHA1_BLOCK_SIZE;
   1411              /* Check for remaining bytes */
   1412              if( numBytes )
   1413              {
   1414                  ctx->bytes = numBytes;
   1415                  FLib_MemCpy(ctx->buffer, pData, numBytes);
   1416              }
   1417          }
   1418          
   1419          /*! *********************************************************************************
   1420          * \brief  This function performs SHA1 on the last bytes of data, and updates the context data.
   1421          *         The final hash value is stored on the context data.
   1422          *
   1423          * \param [in]    pData      Pointer to the input data
   1424          * \param [in]    numBytes   Number of bytes to hash
   1425          * \param [in]    ctx        Pointer to the SHA1 context data
   1426          *
   1427          ********************************************************************************** */
   1428          void SHA1_HashFinish(sha1Context_t* ctx, uint8_t* pData, uint32_t numBytes)
   1429          {
   1430              uint32_t i, temp;
   1431          
   1432              /* perform final hash update */
   1433              SHA1_HashUpdate(ctx, pData, numBytes);
   1434              /* update remaining bytes */
   1435              numBytes = ctx->bytes;
   1436              /* Add 1 bit (a 0x80 byte) after the message to begin padding */
   1437              ctx->buffer[numBytes++] = 0x80;
   1438              /* Chack for space to fit an 8 byte length field plus the 0x80 */
   1439              if( ctx->bytes >= 56 )
   1440              {
   1441                  /* Fill the rest of the chunk with zeros */
   1442                  FLib_MemSet(&ctx->buffer[numBytes], 0, SHA1_BLOCK_SIZE - numBytes);
   1443                  SHA1_hash_n(ctx->buffer, 1, ctx->hash);
   1444                  numBytes = 0;
   1445              }
   1446              /* Fill the rest of the chunk with zeros */
   1447              FLib_MemSet(&ctx->buffer[numBytes], 0, SHA1_BLOCK_SIZE - numBytes);
   1448              /* Append the total length of the message, in bits (bytes << 3) */
   1449              ctx->totalBytes <<= 3;
   1450              FLib_MemCpyReverseOrder(&ctx->buffer[60], &ctx->totalBytes, sizeof(uint32_t));
   1451              SHA1_hash_n(ctx->buffer, 1, ctx->hash);
   1452              /* Convert to Big Endian */
   1453              for(i=0; i<SHA256_HASH_SIZE/sizeof(uint32_t); i++)
   1454              {
   1455                  temp = ctx->hash[i];
   1456                  FLib_MemCpyReverseOrder(&ctx->hash[i], &temp, sizeof(uint32_t));
   1457              }
   1458          }
   1459          
   1460          /*! *********************************************************************************
   1461          * \brief  This function performs all SHA1 steps on multiple bytes: initialize, 
   1462          *         update, finish, and update context data.
   1463          *         The final hash value is stored on the context data.
   1464          *
   1465          * \param [in]    pData      Pointer to the input data
   1466          * \param [in]    numBytes   Number of bytes to hash
   1467          * \param [in]    ctx        Pointer to the SHA1 context data
   1468          *
   1469          ********************************************************************************** */
   1470          void SHA1_Hash(sha1Context_t* ctx, uint8_t* pData, uint32_t numBytes)
   1471          {
   1472              SHA1_Init(ctx);
   1473              SHA1_HashFinish(ctx, pData, numBytes);
   1474          }
   1475          
   1476          /*! *********************************************************************************
   1477          * \brief  This function initializes the SHA256 context data
   1478          *
   1479          * \param [in]    ctx        Pointer to the SHA256 context data
   1480          *
   1481          ********************************************************************************** */
   1482          void SHA256_Init(sha256Context_t * ctx)
   1483          {
   1484              ctx->bytes = 0;
   1485              ctx->totalBytes = 0;
   1486          #if FSL_FEATURE_SOC_MMCAU_COUNT
   1487              (void)mmcau_sha256_initialize_output(ctx->hash);
   1488          #else
   1489              sw_sha256_initialize_output(ctx->hash);
   1490          #endif
   1491          }
   1492          
   1493          /*! *********************************************************************************
   1494          * \brief  This function performs SHA256 on multiple bytes, and updates the context data
   1495          *
   1496          * \param [in]    pData      Pointer to the input data
   1497          * \param [in]    numBytes   Number of bytes to hash
   1498          * \param [in]    ctx        Pointer to the SHA256 context data
   1499          *
   1500          ********************************************************************************** */
   1501          void SHA256_HashUpdate(sha256Context_t* ctx, uint8_t* pData, uint32_t numBytes)
   1502          {
   1503              uint16_t blocks;
   1504          
   1505              /* update total byte count */
   1506              ctx->totalBytes += numBytes;
   1507              /* Check if we have at least 1 SHA256 block */
   1508              if( ctx->bytes + numBytes < SHA256_BLOCK_SIZE )
   1509              {
   1510                  /* store bytes for later processing */
   1511                  FLib_MemCpy(&ctx->buffer[ctx->bytes], pData, numBytes);
   1512                  ctx->bytes += numBytes;
   1513                  return;
   1514              }
   1515              /* Check for bytes leftover from previous update */
   1516              if( ctx->bytes )
   1517              {
   1518                  uint8_t copyBytes = SHA256_BLOCK_SIZE - ctx->bytes;
   1519          
   1520                  FLib_MemCpy(&ctx->buffer[ctx->bytes], pData, copyBytes);
   1521                  SHA256_hash_n(ctx->buffer, 1, ctx->hash);
   1522                  pData += copyBytes;
   1523                  numBytes -= copyBytes;
   1524                  ctx->bytes = 0;
   1525              }
   1526              /* Hash 64 bytes blocks */
   1527              blocks = numBytes/SHA256_BLOCK_SIZE;
   1528              SHA256_hash_n(pData, blocks, ctx->hash);
   1529              numBytes -= blocks*SHA256_BLOCK_SIZE;
   1530              pData += blocks*SHA256_BLOCK_SIZE;
   1531              /* Check for remaining bytes */
   1532              if( numBytes )
   1533              {
   1534                  ctx->bytes = numBytes;
   1535                  FLib_MemCpy(ctx->buffer, pData, numBytes);
   1536              }
   1537          }
   1538          
   1539          /*! *********************************************************************************
   1540          * \brief  This function performs SHA256 on the last bytes of data, and updates the context data.
   1541          *         The final hash value is stored on the context data.
   1542          *
   1543          * \param [in]    pData      Pointer to the input data
   1544          * \param [in]    numBytes   Number of bytes to hash
   1545          * \param [in]    ctx        Pointer to the SHA256 context data
   1546          *
   1547          ********************************************************************************** */
   1548          void SHA256_HashFinish(sha256Context_t* ctx, uint8_t* pData, uint32_t numBytes)
   1549          {
   1550              uint32_t i, temp;
   1551          
   1552              SHA256_HashUpdate(ctx, pData, numBytes);
   1553              /* update remaining bytes */
   1554              numBytes = ctx->bytes;
   1555              /* Add 1 bit (a 0x80 byte) after the message to begin padding */
   1556              ctx->buffer[numBytes++] = 0x80;
   1557              /* Chack for space to fit an 8 byte length field plus the 0x80 */
   1558              if( ctx->bytes >= 56 )
   1559              {
   1560                  /* Fill the rest of the chunk with zeros */
   1561                  FLib_MemSet(&ctx->buffer[numBytes], 0, SHA256_BLOCK_SIZE - numBytes);
   1562                  SHA256_hash_n(ctx->buffer, 1, ctx->hash);
   1563                  numBytes = 0;
   1564              }
   1565              /* Fill the rest of the chunk with zeros */
   1566              FLib_MemSet(&ctx->buffer[numBytes], 0, SHA256_BLOCK_SIZE - numBytes);
   1567              /* Append the total length of the message(Big Endian), in bits (bytes << 3) */
   1568              ctx->totalBytes <<= 3;
   1569              FLib_MemCpyReverseOrder(&ctx->buffer[60], &ctx->totalBytes, sizeof(uint32_t));
   1570              SHA256_hash_n(ctx->buffer, 1, ctx->hash);
   1571              /* Convert to Big Endian */
   1572              for(i=0; i<SHA256_HASH_SIZE/sizeof(uint32_t); i++)
   1573              {
   1574                  temp = ctx->hash[i];
   1575                  FLib_MemCpyReverseOrder(&ctx->hash[i], &temp, sizeof(uint32_t));
   1576              }
   1577          }
   1578          
   1579          /*! *********************************************************************************
   1580          * \brief  This function performs all SHA256 steps on multiple bytes: initialize, 
   1581          *         update, finish, and update context data.
   1582          *         The final hash value is stored on the context data.
   1583          *
   1584          * \param [in]    pData      Pointer to the input data
   1585          * \param [in]    numBytes   Number of bytes to hash
   1586          * \param [in]    ctx        Pointer to the SHA256 context data
   1587          *
   1588          ********************************************************************************** */
   1589          void SHA256_Hash(sha256Context_t* ctx, uint8_t* pData, uint32_t numBytes)
   1590          {
   1591              SHA256_Init(ctx);
   1592              SHA256_HashFinish(ctx, pData, numBytes);
   1593          }
   1594          
   1595          /*! *********************************************************************************
   1596          * \brief  This function performs the initialization of the HMAC context data, and 
   1597          *         performs the initial hash.
   1598          *
   1599          * \param [in]    ctx        Pointer to the HMAC context data
   1600          * \param [in]    pKey       Pointer to the key
   1601          * \param [in]    keyLen     Length of the key
   1602          *
   1603          ********************************************************************************** */
   1604          void HMAC_SHA256_Init(HMAC_SHA256_context_t* ctx, uint8_t* pKey, uint32_t keyLen) 
   1605          {
   1606              uint8_t i;
   1607          
   1608              if( keyLen > SHA256_BLOCK_SIZE )    
   1609              {
   1610                  SHA256_Hash(&ctx->shaCtx, pKey, keyLen);
   1611                  pKey = (uint8_t*)ctx->shaCtx.hash;
   1612                  keyLen = SHA256_HASH_SIZE;
   1613              }
   1614          
   1615              /* Create i_pad */
   1616              for(i=0; i<keyLen; i++)
   1617                  ctx->pad[i] = pKey[i] ^ gHmacIpad_c;
   1618          
   1619              for(i=keyLen; i<SHA256_BLOCK_SIZE; i++)
   1620                  ctx->pad[i] = gHmacIpad_c;
   1621              /* start hashing of the i_key_pad */
   1622              SHA256_Init(&ctx->shaCtx);
   1623              SHA256_HashUpdate(&ctx->shaCtx, ctx->pad, SHA256_BLOCK_SIZE);
   1624          
   1625              /* create o_pad by xor-ing pad[i] with 0x36 ^ 0x5C: */
   1626              for(i=0; i<SHA256_BLOCK_SIZE; i++)
   1627                  ctx->pad[i] ^= (gHmacIpad_c^gHmacOpad_c);
   1628          }
   1629          
   1630          /*! *********************************************************************************
   1631          * \brief  This function performs HMAC update on the input message.
   1632          *         The intermediar hash value is stored on the context data.
   1633          *
   1634          * \param [in]    ctx        Pointer to the HMAC context data
   1635          * \param [in]    pMsg       Pointer to the input data
   1636          * \param [in]    msgLen     Length of the message
   1637          *
   1638          ********************************************************************************** */
   1639          void HMAC_SHA256_Update(HMAC_SHA256_context_t* ctx, uint8_t* pData, uint32_t numBytes)
   1640          {
   1641              SHA256_HashUpdate(&ctx->shaCtx, pData, numBytes);
   1642          }
   1643          
   1644          /*! *********************************************************************************
   1645          * \brief  This function performs the final step of the HMAC
   1646          *         The final hash value is stored on the context data.
   1647          *
   1648          * \param [in]    ctx        Pointer to the HMAC context data
   1649          *
   1650          ********************************************************************************** */
   1651          void HMAC_SHA256_Finish(HMAC_SHA256_context_t* ctx) 
   1652          {
   1653              uint8_t hash1[SHA256_HASH_SIZE];
   1654          
   1655              /* finalize the hash of the i_key_pad and message */
   1656              SHA256_HashFinish(&ctx->shaCtx, NULL, 0);
   1657              FLib_MemCpy(hash1, ctx->shaCtx.hash, SHA256_HASH_SIZE);
   1658              /* perform hash of the o_key_pas and hash1 */
   1659              SHA256_Init(&ctx->shaCtx);
   1660              SHA256_HashUpdate(&ctx->shaCtx, ctx->pad, SHA256_BLOCK_SIZE);
   1661              SHA256_HashFinish(&ctx->shaCtx, hash1, SHA256_HASH_SIZE);
   1662          }
   1663          
   1664          /*! *********************************************************************************
   1665          * \brief  This function performs all HMAC steps on multiple bytes: initialize, 
   1666          *         update, finish, and update context data.
   1667          *         The final hash value is stored on the context data.
   1668          *
   1669          * \param [in]    ctx        Pointer to the HMAC context data
   1670          * \param [in]    pKey       Pointer to the key
   1671          * \param [in]    keyLen     Length of the key
   1672          * \param [in]    pMsg       Pointer to the input data
   1673          * \param [in]    msgLen     Length of the message
   1674          *
   1675          ********************************************************************************** */
   1676          void HMAC_SHA256(HMAC_SHA256_context_t* ctx, uint8_t* pKey, uint32_t keyLen, uint8_t* pMsg, uint32_t msgLen)
   1677          {
   1678              HMAC_SHA256_Init(ctx, pKey, keyLen);
   1679              HMAC_SHA256_Update(ctx, pMsg, msgLen);
   1680              HMAC_SHA256_Finish(ctx);
   1681          }
   1682          
   1683          /*! *********************************************************************************
   1684          *************************************************************************************
   1685          * Private functions
   1686          *************************************************************************************
   1687          ********************************************************************************** */
   1688          
   1689          /*! *********************************************************************************
   1690          * \brief  This function performs SHA1 on multiple blocks
   1691          *
   1692          * \param [in]    pData      Pointer to the input data
   1693          * \param [in]    nBlk       Number of SHA1 blocks to hash
   1694          * \param [in]    ctx        Pointer to the SHA1 context data
   1695          *
   1696          ********************************************************************************** */
   1697          static void SHA1_hash_n(uint8_t* pData, uint32_t nBlk, uint32_t* pHash)
   1698          {
   1699              if( nBlk )
   1700              {
   1701                  SecLib_DisallowToSleep();
   1702          #if FSL_FEATURE_SOC_MMCAU_COUNT
   1703                  mmcau_sha1_hash_n(pData, nBlk, pHash);
   1704          #else
   1705                  sw_sha1_hash_n(pData, nBlk, pHash);
   1706          #endif
   1707                  SecLib_AllowToSleep();
   1708              }
   1709          }
   1710          
   1711          /*! *********************************************************************************
   1712          * \brief  This function performs SHA256 on multiple blocks
   1713          *
   1714          * \param [in]    pData      Pointer to the input data
   1715          * \param [in]    nBlk       Number of SHA256 blocks to hash
   1716          * \param [in]    ctx        Pointer to the SHA256 context data
   1717          *
   1718          ********************************************************************************** */
   1719          static void SHA256_hash_n(uint8_t* pData, uint32_t nBlk, uint32_t* pHash)
   1720          {
   1721              if( nBlk )
   1722              {
   1723                  SecLib_DisallowToSleep();
   1724          #if FSL_FEATURE_SOC_MMCAU_COUNT
   1725                  mmcau_sha256_hash_n(pData, nBlk, pHash);
   1726          #else
   1727                  sw_sha256_hash_n(pData, nBlk, pHash);
   1728          #endif
   1729                  SecLib_AllowToSleep();
   1730              }
   1731          }
   1732          
   1733          /*! *********************************************************************************
   1734          * \brief  This function is the ISR for the LTC driver
   1735          *
   1736          ********************************************************************************** */
   1737          #if FSL_FEATURE_SOC_LTC_COUNT && LTC_DRV_RTOS_SLEEP
   1738          static void LTC_ISR(void)
   1739          {
   1740              LTC_DRV_IRQHandler(BOARD_LTC_INSTANCE);
   1741          }
   1742          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      48   AES_128_CBC_Decrypt_And_Depad
        48   -> LTC_DRV_aes_decrypt_cbc
      40   AES_128_CBC_Encrypt
        40   -> LTC_DRV_aes_encrypt_cbc
      40   AES_128_CBC_Encrypt_And_Pad
        40   -> LTC_DRV_aes_encrypt_cbc
      72   AES_128_CCM
        72   -> LTC_DRV_aes_decrypt_tag_ccm
        72   -> LTC_DRV_aes_encrypt_tag_ccm
     128   AES_128_CMAC
       128   -> AES_128_CMAC_Generate_Subkey
       128   -> AES_128_Encrypt
       128   -> SecLib_Padding
       128   -> SecLib_Xor128
       128 __aeabi_uidivmod
      88   AES_128_CMAC_Generate_Subkey
        88   -> AES_128_Encrypt
        88   -> SecLib_LeftShiftOneBit
        88   -> SecLib_Xor128
        88   -> __aeabi_memcpy4
     144   AES_128_CMAC_LsbFirstInput
       144   -> AES_128_CMAC_Generate_Subkey
       144   -> AES_128_Encrypt
       144   -> FLib_MemCpyReverseOrder
       144   -> SecLib_Padding
       144   -> SecLib_Xor128
       144 __aeabi_uidivmod
      48   AES_128_CTR
        48   -> LTC_DRV_aes_ctr
      24   AES_128_Decrypt
        24   -> LTC_DRV_aes_decrypt_ecb
      88   AES_128_EAX_Decrypt
        88   -> AES_128_CMAC
        88   -> AES_128_CTR
        88   -> FLib_MemCpy
        88   -> FLib_MemSet
        88   -> MEM_BufferAlloc
        88   -> MEM_BufferFree
     104   AES_128_EAX_Encrypt
       104   -> AES_128_CMAC
       104   -> AES_128_CTR
       104   -> FLib_MemCpy
       104   -> FLib_MemSet
       104   -> MEM_BufferAlloc
       104   -> MEM_BufferFree
      24   AES_128_ECB_Block_Encrypt
        24   -> AES_128_Encrypt
      56   AES_128_ECB_Encrypt
        56   -> AES_128_Encrypt
        56   -> FLib_MemCpy
        56   -> __aeabi_memclr4
      24   AES_128_Encrypt
        24   -> LTC_DRV_aes_encrypt_ecb
      56   AES_128_OFB
        56   -> AES_128_Encrypt
        56   -> FLib_MemCpy
        56   -> SecLib_XorN
        56   -> __aeabi_memclr4
      64   AES_CMAC_PRF_128
        64   -> AES_128_CMAC
        64   -> __aeabi_memclr4
      24   HMAC_SHA256
        24   -> HMAC_SHA256_Finish
        24   -> HMAC_SHA256_Init
        24   -> HMAC_SHA256_Update
      40   HMAC_SHA256_Finish
        40   -> FLib_MemCpy
        40   -> SHA256_HashFinish
        40   -> SHA256_HashUpdate
        40   -> SHA256_Init
      24   HMAC_SHA256_Init
        24   -> SHA256_Hash
        24   -> SHA256_HashUpdate
        24   -> SHA256_Init
      16   HMAC_SHA256_Update
        16   -> SHA256_HashUpdate
      16   SHA1_Hash
        16   -> SHA1_HashFinish
        16   -> SHA1_Init
      24   SHA1_HashFinish
        24   -> FLib_MemCpyReverseOrder
        24   -> FLib_MemSet
        24   -> SHA1_HashUpdate
        24   -> SHA1_hash_n
      24   SHA1_HashUpdate
        24   -> FLib_MemCpy
        24   -> SHA1_hash_n
       8   SHA1_Init
         8   -> sw_sha1_initialize_output
      16   SHA1_hash_n
        16   -> sw_sha1_hash_n
      16   SHA256_Hash
        16   -> SHA256_HashFinish
        16   -> SHA256_Init
      24   SHA256_HashFinish
        24   -> FLib_MemCpyReverseOrder
        24   -> FLib_MemSet
        24   -> SHA256_HashUpdate
        24   -> SHA256_hash_n
      24   SHA256_HashUpdate
        24   -> FLib_MemCpy
        24   -> SHA256_hash_n
       8   SHA256_Init
         8   -> sw_sha256_initialize_output
      16   SHA256_hash_n
        16   -> sw_sha256_hash_n
       8   SecLib_Init
         8   -> LTC_DRV_Init
      12   SecLib_LeftShiftOneBit
       8   SecLib_Padding
      12   SecLib_Xor128
       8   SecLib_XorN


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
      16  ?_0
      16  ?_1
      16  ?_2
      16  ?_3
      16  ?_4
      16  ?_5
      54  AES_128_CBC_Decrypt_And_Depad
      36  AES_128_CBC_Encrypt
      84  AES_128_CBC_Encrypt_And_Pad
     128  AES_128_CCM
     250  AES_128_CMAC
     122  AES_128_CMAC_Generate_Subkey
     274  AES_128_CMAC_LsbFirstInput
      44  AES_128_CTR
      28  AES_128_Decrypt
     224  AES_128_EAX_Decrypt
     226  AES_128_EAX_Encrypt
      34  AES_128_ECB_Block_Encrypt
      84  AES_128_ECB_Encrypt
      26  AES_128_Encrypt
     140  AES_128_OFB
      62  AES_CMAC_PRF_128
      38  HMAC_SHA256
      58  HMAC_SHA256_Finish
     136  HMAC_SHA256_Init
      20  HMAC_SHA256_Update
      26  SHA1_Hash
     152  SHA1_HashFinish
     176  SHA1_HashUpdate
      22  SHA1_Init
      24  SHA1_hash_n
      26  SHA256_Hash
     154  SHA256_HashFinish
     176  SHA256_HashUpdate
      22  SHA256_Init
      24  SHA256_hash_n
      10  SecLib_Init
      42  SecLib_LeftShiftOneBit
      40  SecLib_Padding
      24  SecLib_Xor128
      26  SecLib_XorN

 
    96 bytes in section .rodata
 3 016 bytes in section .text
 
 3 016 bytes of CODE  memory
    96 bytes of CONST memory

Errors: none
Warnings: none
