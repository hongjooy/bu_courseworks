###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       06/Apr/2016  15:58:56
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0\rtos\FreeRTOS\src\tasks.c
#    Command line =  
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0\rtos\FreeRTOS\src\tasks.c
#        -D DEBUG -D IAR -D CPU_MKW40Z160VHT4 -lcN "C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork\examples\ieee_802_15_4\MyStarNetwork\EndDevice\frdmkw40z\FreeRTOS\build\iar\debug\list"
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        "C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork\examples\ieee_802_15_4\MyStarNetwork\EndDevice\frdmkw40z\FreeRTOS\build\iar\debug\obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" --preinclude "C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork/examples/ieee_802_15_4/MyStarNetwork/EndDevice/frdmkw40z/FreeRTOS/app_preinclude.h"
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/CMSIS/Include\
#        -I "C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork/boards/frdmkw40z\"
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/devices\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/devices/MKW40Z4/include\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/devices/MKW40Z4/startup\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/system/src/clock/MKW40Z4\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/ieee_802_15_4/Source/App\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/ieee_802_15_4/Source/Mac/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/GPIOIrq\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/Keyboard/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/LED/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/SerialManager/Source/SPI_Adapter\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/Common\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/MemManager/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/Messaging/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/OSAbstraction/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/osa/inc\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/Panic/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/RNG/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/SerialManager/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/TimersManager/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/TimersManager/Source\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/FunctionLib\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/Lists\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/SecLib\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/ModuleInfo\
#        -I "C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork/examples/ieee_802_15_4/MyStarNetwork/EndDevice/common\"
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/devices\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/devices/MKW40Z4/startup\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/rtos/FreeRTOS/include\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/rtos/FreeRTOS/port/iar\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/rtos/FreeRTOS/config/KW40Z4/iar\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/ieee_802_15_4/Source/Phy/Source/MKW40Z\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/ieee_802_15_4/Source/Phy/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/XCVR/MKW40Z4\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/DCDC/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/Flash/Internal\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/drivers/src/flash/C90TFS/drvsrc/include\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/drivers/inc\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/system/inc\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/hal/inc\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/utilities/inc\
#        -On
#    List file    =  
#        C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork\examples\ieee_802_15_4\MyStarNetwork\EndDevice\frdmkw40z\FreeRTOS\build\iar\debug\list\tasks.lst
#    Object file  =  
#        C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork\examples\ieee_802_15_4\MyStarNetwork\EndDevice\frdmkw40z\FreeRTOS\build\iar\debug\obj\tasks.o
#
###############################################################################

C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0\rtos\FreeRTOS\src\tasks.c
      1          /*
      2              FreeRTOS V8.2.0 - Copyright (C) 2015 Real Time Engineers Ltd.
      3              All rights reserved
      4          
      5              VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
      6          
      7              This file is part of the FreeRTOS distribution.
      8          
      9              FreeRTOS is free software; you can redistribute it and/or modify it under
     10              the terms of the GNU General Public License (version 2) as published by the
     11              Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
     12          
     13          	***************************************************************************
     14              >>!   NOTE: The modification to the GPL is included to allow you to     !<<
     15              >>!   distribute a combined work that includes FreeRTOS without being   !<<
     16              >>!   obliged to provide the source code for proprietary components     !<<
     17              >>!   outside of the FreeRTOS kernel.                                   !<<
     18          	***************************************************************************
     19          
     20              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
     21              WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     22              FOR A PARTICULAR PURPOSE.  Full license text is available on the following
     23              link: http://www.freertos.org/a00114.html
     24          
     25              ***************************************************************************
     26               *                                                                       *
     27               *    FreeRTOS provides completely free yet professionally developed,    *
     28               *    robust, strictly quality controlled, supported, and cross          *
     29               *    platform software that is more than just the market leader, it     *
     30               *    is the industry's de facto standard.                               *
     31               *                                                                       *
     32               *    Help yourself get started quickly while simultaneously helping     *
     33               *    to support the FreeRTOS project by purchasing a FreeRTOS           *
     34               *    tutorial book, reference manual, or both:                          *
     35               *    http://www.FreeRTOS.org/Documentation                              *
     36               *                                                                       *
     37              ***************************************************************************
     38          
     39              http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
     40          	the FAQ page "My application does not run, what could be wrong?".  Have you
     41          	defined configASSERT()?
     42          
     43          	http://www.FreeRTOS.org/support - In return for receiving this top quality
     44          	embedded software for free we request you assist our global community by
     45          	participating in the support forum.
     46          
     47          	http://www.FreeRTOS.org/training - Investing in training allows your team to
     48          	be as productive as possible as early as possible.  Now you can receive
     49          	FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
     50          	Ltd, and the world's leading authority on the world's leading RTOS.
     51          
     52              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     53              including FreeRTOS+Trace - an indispensable productivity tool, a DOS
     54              compatible FAT file system, and our tiny thread aware UDP/IP stack.
     55          
     56              http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
     57              Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
     58          
     59              http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
     60              Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
     61              licenses offer ticketed support, indemnification and commercial middleware.
     62          
     63              http://www.SafeRTOS.com - High Integrity Systems also provide a safety
     64              engineered and independently SIL3 certified version for use in safety and
     65              mission critical applications that require provable dependability.
     66          
     67              1 tab == 4 spaces!
     68          */
     69          
     70          /* Standard includes. */
     71          #include <stdlib.h>
     72          #include <string.h>
     73          
     74          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     75          all the API functions to use the MPU wrappers.  That should only be done when
     76          task.h is included from an application file. */
     77          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     78          
     79          /* FreeRTOS includes. */
     80          #include "FreeRTOS.h"
     81          #include "task.h"
     82          #include "timers.h"
     83          #include "StackMacros.h"
     84          
     85          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) )
     86          #include "Utility.h" /* interface to utility because used for safe string routines */ /* << EST */
     87          #endif
     88          
     89          #if (configCOMPILER == configCOMPILER_ARM_IAR) /* << EST: suppress warnings for IAR */
     90          #pragma diag_suppress=pa082 /* Warning[Pa082]: undefined behavior: the order of volatile accesses is undefined in this statement */
     91          #endif
     92          
     93          /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
     94          MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
     95          header files above, but not in this file, in order to generate the correct
     96          privileged Vs unprivileged linkage and placement. */
     97          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
     98          
     99          /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
    100          functions but without including stdio.h here. */
    101          #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
    102          	/* At the bottom of this file are two optional functions that can be used
    103          	to generate human readable text from the raw data generated by the
    104          	uxTaskGetSystemState() function.  Note the formatting functions are provided
    105          	for convenience only, and are NOT considered part of the kernel. */
    106          	#include <stdio.h>
    107          #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
    108          
    109          /* Sanity check the configuration. */
    110          #if configUSE_TICKLESS_IDLE != 0
    111          	#if INCLUDE_vTaskSuspend != 1
    112          		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
    113          	#endif /* INCLUDE_vTaskSuspend */
    114          #endif /* configUSE_TICKLESS_IDLE */
    115          
    116          /*
    117           * Defines the size, in words, of the stack allocated to the idle task.
    118           */
    119          #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
    120          
    121          #if( configUSE_PREEMPTION == 0 )
    122          	/* If the cooperative scheduler is being used then a yield should not be
    123          	performed just because a higher priority task has been woken. */
    124          	#define taskYIELD_IF_USING_PREEMPTION()
    125          #else
    126          	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
    127          #endif
    128          
    129          /* Value that can be assigned to the eNotifyState member of the TCB. */
    130          typedef enum
    131          {
    132          	eNotWaitingNotification = 0,
    133          	eWaitingNotification,
    134          	eNotified
    135          } eNotifyValue;
    136          
    137          /*
    138           * Task control block.  A task control block (TCB) is allocated for each task,
    139           * and stores task state information, including a pointer to the task's context
    140           * (the task's run time environment, including register values)
    141           */
    142          typedef struct tskTaskControlBlock
    143          {
    144          	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */
    145          
    146          	#if ( portUSING_MPU_WRAPPERS == 1 )
    147          		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */
    148          		BaseType_t		xUsingStaticallyAllocatedStack; /* Set to pdTRUE if the stack is a statically allocated array, and pdFALSE if the stack is dynamically allocated. */
    149          	#endif
    150          
    151          	ListItem_t			xGenericListItem;	/*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */
    152          	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
    153          	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
    154          	StackType_t			*pxStack;			/*< Points to the start of the stack. */
    155          	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.  Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    156          
    157          	#if ( portSTACK_GROWTH > 0 )
    158          		StackType_t		*pxEndOfStack;		/*< Points to the end of the stack on architectures where the stack grows up from low memory. */
    159          	#endif
    160          
    161          	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
    162          		UBaseType_t 	uxCriticalNesting; 	/*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */
    163          	#endif
    164          
    165          	#if ( configUSE_TRACE_FACILITY == 1 )
    166          		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */
    167          		UBaseType_t  	uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. */
    168          	#endif
    169          
    170          	#if ( configUSE_MUTEXES == 1 )
    171          		UBaseType_t 	uxBasePriority;		/*< The priority last assigned to the task - used by the priority inheritance mechanism. */
    172          		UBaseType_t 	uxMutexesHeld;
    173          	#endif
    174          
    175          	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
    176          		TaskHookFunction_t pxTaskTag;
    177          	#endif
    178          
    179          	#if ( configGENERATE_RUN_TIME_STATS == 1 )
    180          		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state. */
    181          	#endif
    182          
    183          	#if ( configUSE_NEWLIB_REENTRANT == 1 )
    184          		/* Allocate a Newlib reent structure that is specific to this task.
    185          		Note Newlib support has been included by popular demand, but is not
    186          		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
    187          		responsible for resulting newlib operation.  User must be familiar with
    188          		newlib and must provide system-wide implementations of the necessary
    189          		stubs. Be warned that (at the time of writing) the current newlib design
    190          		implements a system-wide malloc() that must be provided with locks. */
    191          		struct 	_reent xNewLib_reent;
    192          	#endif
    193          
    194          	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
    195          		volatile uint32_t ulNotifiedValue;
    196          		volatile eNotifyValue eNotifyState;
    197          	#endif
    198          
    199          } tskTCB;
    200          
    201          /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
    202          below to enable the use of older kernel aware debuggers. */
    203          typedef tskTCB TCB_t;
    204          
    205          /*
    206           * Some kernel aware debuggers require the data the debugger needs access to to
    207           * be global, rather than file scope.
    208           */
    209          #ifdef portREMOVE_STATIC_QUALIFIER
    210          	#define static
    211          #endif
    212          
    213          /*lint -e956 A manual analysis and inspection has been used to determine which
    214          static variables must be declared volatile. */
    215          
    216          PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
    217          
    218          /* Lists for ready and blocked tasks. --------------------*/
    219          PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks. */
    220          PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
    221          PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
    222          PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list currently being used. */
    223          PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
    224          PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */
    225          
    226          #if ( INCLUDE_vTaskDelete == 1 )
    227          
    228          	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but their memory not yet freed. */
    229          	PRIVILEGED_DATA static volatile UBaseType_t uxTasksDeleted = ( UBaseType_t ) 0U;
    230          
    231          #endif
    232          
    233          #if ( INCLUDE_vTaskSuspend == 1 )
    234          
    235          	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
    236          
    237          #endif
    238          
    239          #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
    240          
    241          	PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle = NULL;			/*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. */
    242          
    243          #endif
    244          
    245          /* Other file private variables. --------------------------------*/
    246          PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
    247          PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) 0U;
    248          PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
    249          PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
    250          PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
    251          PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
    252          PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
    253          PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
    254          PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= portMAX_DELAY;
    255          
    256          /* Context switches are held pending while the scheduler is suspended.  Also,
    257          interrupts must not manipulate the xGenericListItem of a TCB, or any of the
    258          lists the xGenericListItem can be referenced from, if the scheduler is suspended.
    259          If an interrupt needs to unblock a task while the scheduler is suspended then it
    260          moves the task's event list item into the xPendingReadyList, ready for the
    261          kernel to move the task from the pending ready list into the real ready list
    262          when the scheduler is unsuspended.  The pending ready list itself can only be
    263          accessed from a critical section. */
    264          PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
    265          
    266          #if ( configGENERATE_RUN_TIME_STATS == 1 )
    267          
    268          	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter the last time a task was switched in. */
    269          	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution time as defined by the run time counter clock. */
    270          
    271          #endif
    272          
    273          /*lint +e956 */
    274          
    275          /* Debugging and trace facilities private variables and macros. ------------*/
    276          
    277          /*
    278           * The value used to fill the stack of a task when the task is created.  This
    279           * is used purely for checking the high water mark for tasks.
    280           */
    281          #define tskSTACK_FILL_BYTE	( 0xa5U )
    282          
    283          /*
    284           * Macros used by vListTask to indicate which state a task is in.
    285           */
    286          #define tskBLOCKED_CHAR		( 'B' )
    287          #define tskREADY_CHAR		( 'R' )
    288          #define tskDELETED_CHAR		( 'D' )
    289          #define tskSUSPENDED_CHAR	( 'S' )
    290          
    291          /*-----------------------------------------------------------*/
    292          
    293          #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
    294          
    295          	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
    296          	performed in a generic way that is not optimised to any particular
    297          	microcontroller architecture. */
    298          
    299          	/* uxTopReadyPriority holds the priority of the highest priority ready
    300          	state task. */
    301          	#define taskRECORD_READY_PRIORITY( uxPriority )														\
    302          	{																									\
    303          		if( ( uxPriority ) > uxTopReadyPriority )														\
    304          		{																								\
    305          			uxTopReadyPriority = ( uxPriority );														\
    306          		}																								\
    307          	} /* taskRECORD_READY_PRIORITY */
    308          
    309          	/*-----------------------------------------------------------*/
    310          
    311          	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
    312          	{																									\
    313          		/* Find the highest priority queue that contains ready tasks. */								\
    314          		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )						\
    315          		{																								\
    316          			configASSERT( uxTopReadyPriority );															\
    317          			--uxTopReadyPriority;																		\
    318          		}																								\
    319          																										\
    320          		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
    321          		the	same priority get an equal share of the processor time. */									\
    322          		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );		\
    323          	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
    324          
    325          	/*-----------------------------------------------------------*/
    326          
    327          	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
    328          	they are only required when a port optimised method of task selection is
    329          	being used. */
    330          	#define taskRESET_READY_PRIORITY( uxPriority )
    331          	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
    332          
    333          #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
    334          
    335          	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
    336          	performed in a way that is tailored to the particular microcontroller
    337          	architecture being used. */
    338          
    339          	/* A port optimised version is provided.  Call the port defined macros. */
    340          	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )
    341          
    342          	/*-----------------------------------------------------------*/
    343          
    344          	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
    345          	{																								\
    346          	UBaseType_t uxTopPriority;																		\
    347          																									\
    348          		/* Find the highest priority queue that contains ready tasks. */							\
    349          		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
    350          		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
    351          		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
    352          	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
    353          
    354          	/*-----------------------------------------------------------*/
    355          
    356          	/* A port optimised version is provided, call it only if the TCB being reset
    357          	is being referenced from a ready list.  If it is referenced from a delayed
    358          	or suspended list then it won't be in a ready list. */
    359          	#define taskRESET_READY_PRIORITY( uxPriority )														\
    360          	{																									\
    361          		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
    362          		{																								\
    363          			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
    364          		}																								\
    365          	}
    366          
    367          #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
    368          
    369          /*-----------------------------------------------------------*/
    370          
    371          /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
    372          count overflows. */
    373          #define taskSWITCH_DELAYED_LISTS()																	\
    374          {																									\
    375          	List_t *pxTemp;																					\
    376          																									\
    377          	/* The delayed tasks list should be empty when the lists are switched. */						\
    378          	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
    379          																									\
    380          	pxTemp = pxDelayedTaskList;																		\
    381          	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
    382          	pxOverflowDelayedTaskList = pxTemp;																\
    383          	xNumOfOverflows++;																				\
    384          	prvResetNextTaskUnblockTime();																	\
    385          }
    386          
    387          /*-----------------------------------------------------------*/
    388          
    389          /*
    390           * Place the task represented by pxTCB into the appropriate ready list for
    391           * the task.  It is inserted at the end of the list.
    392           */
    393          #define prvAddTaskToReadyList( pxTCB )																\
    394          	traceMOVED_TASK_TO_READY_STATE( pxTCB )															\
    395          	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
    396          	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) )
    397          /*-----------------------------------------------------------*/
    398          
    399          /*
    400           * Several functions take an TaskHandle_t parameter that can optionally be NULL,
    401           * where NULL is used to indicate that the handle of the currently executing
    402           * task should be used in place of the parameter.  This macro simply checks to
    403           * see if the parameter is NULL and returns a pointer to the appropriate TCB.
    404           */
    405          #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( TCB_t * ) ( pxHandle ) )
    406          
    407          /* The item value of the event list item is normally used to hold the priority
    408          of the task to which it belongs (coded to allow it to be held in reverse
    409          priority order).  However, it is occasionally borrowed for other purposes.  It
    410          is important its value is not updated due to a task priority change while it is
    411          being used for another purpose.  The following bit definition is used to inform
    412          the scheduler that the value should not be changed - in which case it is the
    413          responsibility of whichever module is using the value to ensure it gets set back
    414          to its original value when it is released. */
    415          #if configUSE_16_BIT_TICKS == 1
    416          	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
    417          #else
    418          	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
    419          #endif
    420          
    421          /* Callback function prototypes. --------------------------*/
    422          #if configCHECK_FOR_STACK_OVERFLOW > 0
    423          	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
    424          #endif
    425          
    426          #if configUSE_TICK_HOOK > 0
    427          	extern void vApplicationTickHook( void );
    428          #endif
    429          
    430          /* File private functions. --------------------------------*/
    431          
    432          /*
    433           * Utility to ready a TCB for a given task.  Mainly just copies the parameters
    434           * into the TCB structure.
    435           */
    436          static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    437          
    438          /**
    439           * Utility task that simply returns pdTRUE if the task referenced by xTask is
    440           * currently in the Suspended state, or pdFALSE if the task referenced by xTask
    441           * is in any other state.
    442           */
    443          #if ( INCLUDE_vTaskSuspend == 1 )
    444          	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
    445          #endif /* INCLUDE_vTaskSuspend */
    446          
    447          /*
    448           * Utility to ready all the lists used by the scheduler.  This is called
    449           * automatically upon the creation of the first task.
    450           */
    451          static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
    452          
    453          /*
    454           * The idle task, which as all tasks is implemented as a never ending loop.
    455           * The idle task is automatically created and added to the ready lists upon
    456           * creation of the first user task.
    457           *
    458           * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
    459           * language extensions.  The equivalent prototype for this function is:
    460           *
    461           * void prvIdleTask( void *pvParameters );
    462           *
    463           */
    464          static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
    465          
    466          /*
    467           * Utility to free all memory allocated by the scheduler to hold a TCB,
    468           * including the stack pointed to by the TCB.
    469           *
    470           * This does not free memory allocated by the task itself (i.e. memory
    471           * allocated by calls to pvPortMalloc from within the tasks application code).
    472           */
    473          #if ( INCLUDE_vTaskDelete == 1 )
    474          
    475          	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
    476          
    477          #endif
    478          
    479          /*
    480           * Used only by the idle task.  This checks to see if anything has been placed
    481           * in the list of tasks waiting to be deleted.  If so the task is cleaned up
    482           * and its TCB deleted.
    483           */
    484          static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
    485          
    486          /*
    487           * The currently executing task is entering the Blocked state.  Add the task to
    488           * either the current or the overflow delayed task list.
    489           */
    490          static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake ) PRIVILEGED_FUNCTION;
    491          
    492          /*
    493           * Allocates memory from the heap for a TCB and associated stack.  Checks the
    494           * allocation was successful.
    495           */
    496          static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer ) PRIVILEGED_FUNCTION;
    497          
    498          /*
    499           * Fills an TaskStatus_t structure with information on each task that is
    500           * referenced from the pxList list (which may be a ready list, a delayed list,
    501           * a suspended list, etc.).
    502           *
    503           * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
    504           * NORMAL APPLICATION CODE.
    505           */
    506          #if ( configUSE_TRACE_FACILITY == 1 )
    507          
    508          	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState ) PRIVILEGED_FUNCTION;
    509          
    510          #endif
    511          
    512          /*
    513           * When a task is created, the stack of the task is filled with a known value.
    514           * This function determines the 'high water mark' of the task stack by
    515           * determining how much of the stack remains at the original preset value.
    516           */
    517          #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
    518          
    519          	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
    520          
    521          #endif
    522          
    523          /*
    524           * Return the amount of time, in ticks, that will pass before the kernel will
    525           * next move a task from the Blocked state to the Running state.
    526           *
    527           * This conditional compilation should use inequality to 0, not equality to 1.
    528           * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
    529           * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
    530           * set to a value other than 1.
    531           */
    532          #if ( configUSE_TICKLESS_IDLE != 0 )
    533          
    534          	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
    535          
    536          #endif
    537          
    538          /*
    539           * Set xNextTaskUnblockTime to the time at which the next Blocked state task
    540           * will exit the Blocked state.
    541           */
    542          static void prvResetNextTaskUnblockTime( void );
    543          
    544          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
    545          
    546          	/*
    547          	 * Helper function used to pad task names with spaces when printing out
    548          	 * human readable tables of task information.
    549          	 */
    550          	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName );
    551          
    552          #endif
    553          /*-----------------------------------------------------------*/
    554          
    555          BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    556          {
    557          BaseType_t xReturn;
    558          TCB_t * pxNewTCB;
    559          StackType_t *pxTopOfStack;
    560          
    561          	configASSERT( pxTaskCode );
    562          	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
    563          
    564          	/* Allocate the memory required by the TCB and stack for the new task,
    565          	checking that the allocation was successful. */
    566          	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    567          
    568          	if( pxNewTCB != NULL )
    569          	{
    570          		#if( portUSING_MPU_WRAPPERS == 1 )
    571          			/* Should the task be created in privileged mode? */
    572          			BaseType_t xRunPrivileged;
    573          			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
    574          			{
    575          				xRunPrivileged = pdTRUE;
    576          			}
    577          			else
    578          			{
    579          				xRunPrivileged = pdFALSE;
    580          			}
    581          			uxPriority &= ~portPRIVILEGE_BIT;
    582          
    583          			if( puxStackBuffer != NULL )
    584          			{
    585          				/* The application provided its own stack.  Note this so no
    586          				attempt is made to delete the stack should that task be
    587          				deleted. */
    588          				pxNewTCB->xUsingStaticallyAllocatedStack = pdTRUE;
    589          			}
    590          			else
    591          			{
    592          				/* The stack was allocated dynamically.  Note this so it can be
    593          				deleted again if the task is deleted. */
    594          				pxNewTCB->xUsingStaticallyAllocatedStack = pdFALSE;
    595          			}
    596          		#endif /* portUSING_MPU_WRAPPERS == 1 */
    597          
    598          		/* Calculate the top of stack address.  This depends on whether the
    599          		stack grows from high memory to low (as per the 80x86) or vice versa.
    600          		portSTACK_GROWTH is used to make the result positive or negative as
    601          		required by the port. */
    602          		#if( portSTACK_GROWTH < 0 )
    603          		{
    604          			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    605          			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
    606          
    607          			/* Check the alignment of the calculated top of stack is correct. */
    608          			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
    609          		}
    610          		#else /* portSTACK_GROWTH */
    611          		{
    612          			pxTopOfStack = pxNewTCB->pxStack;
    613          
    614          			/* Check the alignment of the stack buffer is correct. */
    615          			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
    616          
    617          			/* If we want to use stack checking on architectures that use
    618          			a positive stack growth direction then we also need to store the
    619          			other extreme of the stack space. */
    620          			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    621          		}
    622          		#endif /* portSTACK_GROWTH */
    623          
    624          		/* Setup the newly allocated TCB with the initial state of the task. */
    625          		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    626          
    627          		/* Initialize the TCB stack to look as if the task was already running,
    628          		but had been interrupted by the scheduler.  The return address is set
    629          		to the start of the task function. Once the stack has been initialised
    630          		the	top of stack variable is updated. */
    631          		#if( portUSING_MPU_WRAPPERS == 1 )
    632          		{
    633          			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
    634          		}
    635          		#else /* portUSING_MPU_WRAPPERS */
    636          		{
    637          			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    638          		}
    639          		#endif /* portUSING_MPU_WRAPPERS */
    640          
    641          		if( ( void * ) pxCreatedTask != NULL )
    642          		{
    643          			/* Pass the TCB out - in an anonymous way.  The calling function/
    644          			task can use this as a handle to delete the task later if
    645          			required.*/
    646          			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    647          		}
    648          		else
    649          		{
    650          			mtCOVERAGE_TEST_MARKER();
    651          		}
    652          
    653          		/* Ensure interrupts don't access the task lists while they are being
    654          		updated. */
    655          		taskENTER_CRITICAL();
    656          		{
    657          			uxCurrentNumberOfTasks++;
    658          			if( pxCurrentTCB == NULL )
    659          			{
    660          				/* There are no other tasks, or all the other tasks are in
    661          				the suspended state - make this the current task. */
    662          				pxCurrentTCB =  pxNewTCB;
    663          
    664          				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    665          				{
    666          					/* This is the first task to be created so do the preliminary
    667          					initialisation required.  We will not recover if this call
    668          					fails, but we will report the failure. */
    669          					prvInitialiseTaskLists();
    670          				}
    671          				else
    672          				{
    673          					mtCOVERAGE_TEST_MARKER();
    674          				}
    675          			}
    676          			else
    677          			{
    678          				/* If the scheduler is not already running, make this task the
    679          				current task if it is the highest priority task to be created
    680          				so far. */
    681          				if( xSchedulerRunning == pdFALSE )
    682          				{
    683          					if( pxCurrentTCB->uxPriority <= uxPriority )
    684          					{
    685          						pxCurrentTCB = pxNewTCB;
    686          					}
    687          					else
    688          					{
    689          						mtCOVERAGE_TEST_MARKER();
    690          					}
    691          				}
    692          				else
    693          				{
    694          					mtCOVERAGE_TEST_MARKER();
    695          				}
    696          			}
    697          
    698          			uxTaskNumber++;
    699          
    700          			#if ( configUSE_TRACE_FACILITY == 1 )
    701          			{
    702          				/* Add a counter into the TCB for tracing only. */
    703          				pxNewTCB->uxTCBNumber = uxTaskNumber;
    704          			}
    705          			#endif /* configUSE_TRACE_FACILITY */
    706          			traceTASK_CREATE( pxNewTCB );
    707          
    708          			prvAddTaskToReadyList( pxNewTCB );
    709          
    710          			xReturn = pdPASS;
    711          			portSETUP_TCB( pxNewTCB );
    712          		}
    713          		taskEXIT_CRITICAL();
    714          	}
    715          	else
    716          	{
    717          		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    718          		traceTASK_CREATE_FAILED();
    719          	}
    720          
    721          	if( xReturn == pdPASS )
    722          	{
    723          		if( xSchedulerRunning != pdFALSE )
    724          		{
    725          			/* If the created task is of a higher priority than the current task
    726          			then it should run now. */
    727          			if( pxCurrentTCB->uxPriority < uxPriority )
    728          			{
    729          				taskYIELD_IF_USING_PREEMPTION();
    730          			}
    731          			else
    732          			{
    733          				mtCOVERAGE_TEST_MARKER();
    734          			}
    735          		}
    736          		else
    737          		{
    738          			mtCOVERAGE_TEST_MARKER();
    739          		}
    740          	}
    741          
    742          	return xReturn;
    743          }
    744          /*-----------------------------------------------------------*/
    745          
    746          #if ( INCLUDE_vTaskDelete == 1 )
    747          
    748          	void vTaskDelete( TaskHandle_t xTaskToDelete )
    749          	{
    750          	TCB_t *pxTCB;
    751          
    752          		taskENTER_CRITICAL();
    753          		{
    754          			/* If null is passed in here then it is the calling task that is
    755          			being deleted. */
    756          			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    757          
    758          			/* Remove task from the ready list and place in the	termination list.
    759          			This will stop the task from be scheduled.  The idle task will check
    760          			the termination list and free up any memory allocated by the
    761          			scheduler for the TCB and stack. */
    762          			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    763          			{
    764          				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
    765          			}
    766          			else
    767          			{
    768          				mtCOVERAGE_TEST_MARKER();
    769          			}
    770          
    771          			/* Is the task waiting on an event also? */
    772          			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    773          			{
    774          				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    775          			}
    776          			else
    777          			{
    778          				mtCOVERAGE_TEST_MARKER();
    779          			}
    780          
    781          			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    782          
    783          			/* Increment the ucTasksDeleted variable so the idle task knows
    784          			there is a task that has been deleted and that it should therefore
    785          			check the xTasksWaitingTermination list. */
    786          			++uxTasksDeleted;
    787          
    788          			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
    789          			can detect that the task lists need re-generating. */
    790          			uxTaskNumber++;
    791          
    792          			traceTASK_DELETE( pxTCB );
    793          		}
    794          		taskEXIT_CRITICAL();
    795          
    796          		/* Force a reschedule if it is the currently running task that has just
    797          		been deleted. */
    798          		if( xSchedulerRunning != pdFALSE )
    799          		{
    800          			if( pxTCB == pxCurrentTCB )
    801          			{
    802          				configASSERT( uxSchedulerSuspended == 0 );
    803          
    804          				/* The pre-delete hook is primarily for the Windows simulator,
    805          				in which Windows specific clean up operations are performed,
    806          				after which it is not possible to yield away from this task -
    807          				hence xYieldPending is used to latch that a context switch is
    808          				required. */
    809          				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
    810          				portYIELD_WITHIN_API();
    811          			}
    812          			else
    813          			{
    814          				/* Reset the next expected unblock time in case it referred to
    815          				the task that has just been deleted. */
    816          				taskENTER_CRITICAL();
    817          				{
    818          					prvResetNextTaskUnblockTime();
    819          				}
    820          				taskEXIT_CRITICAL();
    821          			}
    822          		}
    823          	}
    824          
    825          #endif /* INCLUDE_vTaskDelete */
    826          /*-----------------------------------------------------------*/
    827          
    828          #if ( INCLUDE_vTaskDelayUntil == 1 )
    829          
    830          	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
    831          	{
    832          	TickType_t xTimeToWake;
    833          	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    834          
    835          		configASSERT( pxPreviousWakeTime );
    836          		configASSERT( ( xTimeIncrement > 0U ) );
    837          		configASSERT( uxSchedulerSuspended == 0 );
    838          
    839          		vTaskSuspendAll();
    840          		{
    841          			/* Minor optimisation.  The tick count cannot change in this
    842          			block. */
    843          			const TickType_t xConstTickCount = xTickCount;
    844          
    845          			/* Generate the tick time at which the task wants to wake. */
    846          			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    847          
    848          			if( xConstTickCount < *pxPreviousWakeTime )
    849          			{
    850          				/* The tick count has overflowed since this function was
    851          				lasted called.  In this case the only time we should ever
    852          				actually delay is if the wake time has also	overflowed,
    853          				and the wake time is greater than the tick time.  When this
    854          				is the case it is as if neither time had overflowed. */
    855          				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    856          				{
    857          					xShouldDelay = pdTRUE;
    858          				}
    859          				else
    860          				{
    861          					mtCOVERAGE_TEST_MARKER();
    862          				}
    863          			}
    864          			else
    865          			{
    866          				/* The tick time has not overflowed.  In this case we will
    867          				delay if either the wake time has overflowed, and/or the
    868          				tick time is less than the wake time. */
    869          				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    870          				{
    871          					xShouldDelay = pdTRUE;
    872          				}
    873          				else
    874          				{
    875          					mtCOVERAGE_TEST_MARKER();
    876          				}
    877          			}
    878          
    879          			/* Update the wake time ready for the next call. */
    880          			*pxPreviousWakeTime = xTimeToWake;
    881          
    882          			if( xShouldDelay != pdFALSE )
    883          			{
    884          				traceTASK_DELAY_UNTIL();
    885          
    886          				/* Remove the task from the ready list before adding it to the
    887          				blocked list as the same list item is used for both lists. */
    888          				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    889          				{
    890          					/* The current task must be in a ready list, so there is
    891          					no need to check, and the port reset macro can be called
    892          					directly. */
    893          					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
    894          				}
    895          				else
    896          				{
    897          					mtCOVERAGE_TEST_MARKER();
    898          				}
    899          
    900          				prvAddCurrentTaskToDelayedList( xTimeToWake );
    901          			}
    902          			else
    903          			{
    904          				mtCOVERAGE_TEST_MARKER();
    905          			}
    906          		}
    907          		xAlreadyYielded = xTaskResumeAll();
    908          
    909          		/* Force a reschedule if xTaskResumeAll has not already done so, we may
    910          		have put ourselves to sleep. */
    911          		if( xAlreadyYielded == pdFALSE )
    912          		{
    913          			portYIELD_WITHIN_API();
    914          		}
    915          		else
    916          		{
    917          			mtCOVERAGE_TEST_MARKER();
    918          		}
    919          	}
    920          
    921          #endif /* INCLUDE_vTaskDelayUntil */
    922          /*-----------------------------------------------------------*/
    923          
    924          #if ( INCLUDE_vTaskDelay == 1 )
    925          
    926          	void vTaskDelay( const TickType_t xTicksToDelay )
    927          	{
    928          	TickType_t xTimeToWake;
    929          	BaseType_t xAlreadyYielded = pdFALSE;
    930          
    931          
    932          		/* A delay time of zero just forces a reschedule. */
    933          		if( xTicksToDelay > ( TickType_t ) 0U )
    934          		{
    935          			configASSERT( uxSchedulerSuspended == 0 );
    936          			vTaskSuspendAll();
    937          			{
    938          				traceTASK_DELAY();
    939          
    940          				/* A task that is removed from the event list while the
    941          				scheduler is suspended will not get placed in the ready
    942          				list or removed from the blocked list until the scheduler
    943          				is resumed.
    944          
    945          				This task cannot be in an event list as it is the currently
    946          				executing task. */
    947          
    948          				/* Calculate the time to wake - this may overflow but this is
    949          				not a problem. */
    950          				xTimeToWake = xTickCount + xTicksToDelay;
    951          
    952          				/* We must remove ourselves from the ready list before adding
    953          				ourselves to the blocked list as the same list item is used for
    954          				both lists. */
    955          				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    956          				{
    957          					/* The current task must be in a ready list, so there is
    958          					no need to check, and the port reset macro can be called
    959          					directly. */
    960          					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
    961          				}
    962          				else
    963          				{
    964          					mtCOVERAGE_TEST_MARKER();
    965          				}
    966          				prvAddCurrentTaskToDelayedList( xTimeToWake );
    967          			}
    968          			xAlreadyYielded = xTaskResumeAll();
    969          		}
    970          		else
    971          		{
    972          			mtCOVERAGE_TEST_MARKER();
    973          		}
    974          
    975          		/* Force a reschedule if xTaskResumeAll has not already done so, we may
    976          		have put ourselves to sleep. */
    977          		if( xAlreadyYielded == pdFALSE )
    978          		{
    979          			portYIELD_WITHIN_API();
    980          		}
    981          		else
    982          		{
    983          			mtCOVERAGE_TEST_MARKER();
    984          		}
    985          	}
    986          
    987          #endif /* INCLUDE_vTaskDelay */
    988          /*-----------------------------------------------------------*/
    989          
    990          #if ( INCLUDE_eTaskGetState == 1 )
    991          
    992          	eTaskState eTaskGetState( TaskHandle_t xTask )
    993          	{
    994          	eTaskState eReturn;
    995          	List_t *pxStateList;
    996          	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
    997          
    998          		configASSERT( pxTCB );
    999          
   1000          		if( pxTCB == pxCurrentTCB )
   1001          		{
   1002          			/* The task calling this function is querying its own state. */
   1003          			eReturn = eRunning;
   1004          		}
   1005          		else
   1006          		{
   1007          			taskENTER_CRITICAL();
   1008          			{
   1009          				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xGenericListItem ) );
   1010          			}
   1011          			taskEXIT_CRITICAL();
   1012          
   1013          			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
   1014          			{
   1015          				/* The task being queried is referenced from one of the Blocked
   1016          				lists. */
   1017          				eReturn = eBlocked;
   1018          			}
   1019          
   1020          			#if ( INCLUDE_vTaskSuspend == 1 )
   1021          				else if( pxStateList == &xSuspendedTaskList )
   1022          				{
   1023          					/* The task being queried is referenced from the suspended
   1024          					list.  Is it genuinely suspended or is it block
   1025          					indefinitely? */
   1026          					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
   1027          					{
   1028          						eReturn = eSuspended;
   1029          					}
   1030          					else
   1031          					{
   1032          						eReturn = eBlocked;
   1033          					}
   1034          				}
   1035          			#endif
   1036          
   1037          			#if ( INCLUDE_vTaskDelete == 1 )
   1038          				else if( pxStateList == &xTasksWaitingTermination )
   1039          				{
   1040          					/* The task being queried is referenced from the deleted
   1041          					tasks list. */
   1042          					eReturn = eDeleted;
   1043          				}
   1044          			#endif
   1045          
   1046          			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
   1047          			{
   1048          				/* If the task is not in any other state, it must be in the
   1049          				Ready (including pending ready) state. */
   1050          				eReturn = eReady;
   1051          			}
   1052          		}
   1053          
   1054          		return eReturn;
   1055          	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
   1056          
   1057          #endif /* INCLUDE_eTaskGetState */
   1058          /*-----------------------------------------------------------*/
   1059          
   1060          #if ( INCLUDE_uxTaskPriorityGet == 1 )
   1061          
   1062          	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
   1063          	{
   1064          	TCB_t *pxTCB;
   1065          	UBaseType_t uxReturn;
   1066          
   1067          		taskENTER_CRITICAL();
   1068          		{
   1069          			/* If null is passed in here then we are changing the
   1070          			priority of the calling function. */
   1071          			pxTCB = prvGetTCBFromHandle( xTask );
   1072          			uxReturn = pxTCB->uxPriority;
   1073          		}
   1074          		taskEXIT_CRITICAL();
   1075          
   1076          		return uxReturn;
   1077          	}
   1078          
   1079          #endif /* INCLUDE_uxTaskPriorityGet */
   1080          /*-----------------------------------------------------------*/
   1081          
   1082          #if ( INCLUDE_uxTaskPriorityGet == 1 )
   1083          
   1084          	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
   1085          	{
   1086          	TCB_t *pxTCB;
   1087          	UBaseType_t uxReturn, uxSavedInterruptState;
   1088          
   1089          		/* RTOS ports that support interrupt nesting have the concept of a
   1090          		maximum	system call (or maximum API call) interrupt priority.
   1091          		Interrupts that are	above the maximum system call priority are keep
   1092          		permanently enabled, even when the RTOS kernel is in a critical section,
   1093          		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   1094          		is defined in FreeRTOSConfig.h then
   1095          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1096          		failure if a FreeRTOS API function is called from an interrupt that has
   1097          		been assigned a priority above the configured maximum system call
   1098          		priority.  Only FreeRTOS functions that end in FromISR can be called
   1099          		from interrupts	that have been assigned a priority at or (logically)
   1100          		below the maximum system call interrupt priority.  FreeRTOS maintains a
   1101          		separate interrupt safe API to ensure interrupt entry is as fast and as
   1102          		simple as possible.  More information (albeit Cortex-M specific) is
   1103          		provided on the following link:
   1104          		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1105          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1106          
   1107          		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
   1108          		{
   1109          			/* If null is passed in here then it is the priority of the calling
   1110          			task that is being queried. */
   1111          			pxTCB = prvGetTCBFromHandle( xTask );
   1112          			uxReturn = pxTCB->uxPriority;
   1113          		}
   1114          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
   1115          
   1116          		return uxReturn;
   1117          	}
   1118          
   1119          #endif /* INCLUDE_uxTaskPriorityGet */
   1120          /*-----------------------------------------------------------*/
   1121          
   1122          #if ( INCLUDE_vTaskPrioritySet == 1 )
   1123          
   1124          	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
   1125          	{
   1126          	TCB_t *pxTCB;
   1127          	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
   1128          	BaseType_t xYieldRequired = pdFALSE;
   1129          
   1130          		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
   1131          
   1132          		/* Ensure the new priority is valid. */
   1133          		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   1134          		{
   1135          			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
   1136          		}
   1137          		else
   1138          		{
   1139          			mtCOVERAGE_TEST_MARKER();
   1140          		}
   1141          
   1142          		taskENTER_CRITICAL();
   1143          		{
   1144          			/* If null is passed in here then it is the priority of the calling
   1145          			task that is being changed. */
   1146          			pxTCB = prvGetTCBFromHandle( xTask );
   1147          
   1148          			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
   1149          
   1150          			#if ( configUSE_MUTEXES == 1 )
   1151          			{
   1152          				uxCurrentBasePriority = pxTCB->uxBasePriority;
   1153          			}
   1154          			#else
   1155          			{
   1156          				uxCurrentBasePriority = pxTCB->uxPriority;
   1157          			}
   1158          			#endif
   1159          
   1160          			if( uxCurrentBasePriority != uxNewPriority )
   1161          			{
   1162          				/* The priority change may have readied a task of higher
   1163          				priority than the calling task. */
   1164          				if( uxNewPriority > uxCurrentBasePriority )
   1165          				{
   1166          					if( pxTCB != pxCurrentTCB )
   1167          					{
   1168          						/* The priority of a task other than the currently
   1169          						running task is being raised.  Is the priority being
   1170          						raised above that of the running task? */
   1171          						if( uxNewPriority >= pxCurrentTCB->uxPriority )
   1172          						{
   1173          							xYieldRequired = pdTRUE;
   1174          						}
   1175          						else
   1176          						{
   1177          							mtCOVERAGE_TEST_MARKER();
   1178          						}
   1179          					}
   1180          					else
   1181          					{
   1182          						/* The priority of the running task is being raised,
   1183          						but the running task must already be the highest
   1184          						priority task able to run so no yield is required. */
   1185          					}
   1186          				}
   1187          				else if( pxTCB == pxCurrentTCB )
   1188          				{
   1189          					/* Setting the priority of the running task down means
   1190          					there may now be another task of higher priority that
   1191          					is ready to execute. */
   1192          					xYieldRequired = pdTRUE;
   1193          				}
   1194          				else
   1195          				{
   1196          					/* Setting the priority of any other task down does not
   1197          					require a yield as the running task must be above the
   1198          					new priority of the task being modified. */
   1199          				}
   1200          
   1201          				/* Remember the ready list the task might be referenced from
   1202          				before its uxPriority member is changed so the
   1203          				taskRESET_READY_PRIORITY() macro can function correctly. */
   1204          				uxPriorityUsedOnEntry = pxTCB->uxPriority;
   1205          
   1206          				#if ( configUSE_MUTEXES == 1 )
   1207          				{
   1208          					/* Only change the priority being used if the task is not
   1209          					currently using an inherited priority. */
   1210          					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
   1211          					{
   1212          						pxTCB->uxPriority = uxNewPriority;
   1213          					}
   1214          					else
   1215          					{
   1216          						mtCOVERAGE_TEST_MARKER();
   1217          					}
   1218          
   1219          					/* The base priority gets set whatever. */
   1220          					pxTCB->uxBasePriority = uxNewPriority;
   1221          				}
   1222          				#else
   1223          				{
   1224          					pxTCB->uxPriority = uxNewPriority;
   1225          				}
   1226          				#endif
   1227          
   1228          				/* Only reset the event list item value if the value is not
   1229          				being used for anything else. */
   1230          				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   1231          				{
   1232          					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1233          				}
   1234          				else
   1235          				{
   1236          					mtCOVERAGE_TEST_MARKER();
   1237          				}
   1238          
   1239          				/* If the task is in the blocked or suspended list we need do
   1240          				nothing more than change it's priority variable. However, if
   1241          				the task is in a ready list it needs to be removed and placed
   1242          				in the list appropriate to its new priority. */
   1243          				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
   1244          				{
   1245          					/* The task is currently in its ready list - remove before adding
   1246          					it to it's new ready list.  As we are in a critical section we
   1247          					can do this even if the scheduler is suspended. */
   1248          					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   1249          					{
   1250          						/* It is known that the task is in its ready list so
   1251          						there is no need to check again and the port level
   1252          						reset macro can be called directly. */
   1253          						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
   1254          					}
   1255          					else
   1256          					{
   1257          						mtCOVERAGE_TEST_MARKER();
   1258          					}
   1259          					prvAddTaskToReadyList( pxTCB );
   1260          				}
   1261          				else
   1262          				{
   1263          					mtCOVERAGE_TEST_MARKER();
   1264          				}
   1265          
   1266          				if( xYieldRequired == pdTRUE )
   1267          				{
   1268          					taskYIELD_IF_USING_PREEMPTION();
   1269          				}
   1270          				else
   1271          				{
   1272          					mtCOVERAGE_TEST_MARKER();
   1273          				}
   1274          
   1275          				/* Remove compiler warning about unused variables when the port
   1276          				optimised task selection is not being used. */
   1277          				( void ) uxPriorityUsedOnEntry;
   1278          			}
   1279          		}
   1280          		taskEXIT_CRITICAL();
   1281          	}
   1282          
   1283          #endif /* INCLUDE_vTaskPrioritySet */
   1284          /*-----------------------------------------------------------*/
   1285          
   1286          #if ( INCLUDE_vTaskSuspend == 1 )
   1287          
   1288          	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
   1289          	{
   1290          	TCB_t *pxTCB;
   1291          
   1292          		taskENTER_CRITICAL();
   1293          		{
   1294          			/* If null is passed in here then it is the running task that is
   1295          			being suspended. */
   1296          			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
   1297          
   1298          			traceTASK_SUSPEND( pxTCB );
   1299          
   1300          			/* Remove task from the ready/delayed list and place in the
   1301          			suspended list. */
   1302          			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   1303          			{
   1304          				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   1305          			}
   1306          			else
   1307          			{
   1308          				mtCOVERAGE_TEST_MARKER();
   1309          			}
   1310          
   1311          			/* Is the task waiting on an event also? */
   1312          			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   1313          			{
   1314          				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   1315          			}
   1316          			else
   1317          			{
   1318          				mtCOVERAGE_TEST_MARKER();
   1319          			}
   1320          
   1321          			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
   1322          		}
   1323          		taskEXIT_CRITICAL();
   1324          
   1325          		if( pxTCB == pxCurrentTCB )
   1326          		{
   1327          			if( xSchedulerRunning != pdFALSE )
   1328          			{
   1329          				/* The current task has just been suspended. */
   1330          				configASSERT( uxSchedulerSuspended == 0 );
   1331          				portYIELD_WITHIN_API();
   1332          			}
   1333          			else
   1334          			{
   1335          				/* The scheduler is not running, but the task that was pointed
   1336          				to by pxCurrentTCB has just been suspended and pxCurrentTCB
   1337          				must be adjusted to point to a different task. */
   1338          				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
   1339          				{
   1340          					/* No other tasks are ready, so set pxCurrentTCB back to
   1341          					NULL so when the next task is created pxCurrentTCB will
   1342          					be set to point to it no matter what its relative priority
   1343          					is. */
   1344          					pxCurrentTCB = NULL;
   1345          				}
   1346          				else
   1347          				{
   1348          					vTaskSwitchContext();
   1349          				}
   1350          			}
   1351          		}
   1352          		else
   1353          		{
   1354          			if( xSchedulerRunning != pdFALSE )
   1355          			{
   1356          				/* A task other than the currently running task was suspended,
   1357          				reset the next expected unblock time in case it referred to the
   1358          				task that is now in the Suspended state. */
   1359          				taskENTER_CRITICAL();
   1360          				{
   1361          					prvResetNextTaskUnblockTime();
   1362          				}
   1363          				taskEXIT_CRITICAL();
   1364          			}
   1365          			else
   1366          			{
   1367          				mtCOVERAGE_TEST_MARKER();
   1368          			}
   1369          		}
   1370          	}
   1371          
   1372          #endif /* INCLUDE_vTaskSuspend */
   1373          /*-----------------------------------------------------------*/
   1374          
   1375          #if ( INCLUDE_vTaskSuspend == 1 )
   1376          
   1377          	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
   1378          	{
   1379          	BaseType_t xReturn = pdFALSE;
   1380          	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
   1381          
   1382          		/* Accesses xPendingReadyList so must be called from a critical
   1383          		section. */
   1384          
   1385          		/* It does not make sense to check if the calling task is suspended. */
   1386          		configASSERT( xTask );
   1387          
   1388          		/* Is the task being resumed actually in the suspended list? */
   1389          		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
   1390          		{
   1391          			/* Has the task already been resumed from within an ISR? */
   1392          			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
   1393          			{
   1394          				/* Is it in the suspended list because it is in the	Suspended
   1395          				state, or because is is blocked with no timeout? */
   1396          				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
   1397          				{
   1398          					xReturn = pdTRUE;
   1399          				}
   1400          				else
   1401          				{
   1402          					mtCOVERAGE_TEST_MARKER();
   1403          				}
   1404          			}
   1405          			else
   1406          			{
   1407          				mtCOVERAGE_TEST_MARKER();
   1408          			}
   1409          		}
   1410          		else
   1411          		{
   1412          			mtCOVERAGE_TEST_MARKER();
   1413          		}
   1414          
   1415          		return xReturn;
   1416          	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
   1417          
   1418          #endif /* INCLUDE_vTaskSuspend */
   1419          /*-----------------------------------------------------------*/
   1420          
   1421          #if ( INCLUDE_vTaskSuspend == 1 )
   1422          
   1423          	void vTaskResume( TaskHandle_t xTaskToResume )
   1424          	{
   1425          	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
   1426          
   1427          		/* It does not make sense to resume the calling task. */
   1428          		configASSERT( xTaskToResume );
   1429          
   1430          		/* The parameter cannot be NULL as it is impossible to resume the
   1431          		currently executing task. */
   1432          		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
   1433          		{
   1434          			taskENTER_CRITICAL();
   1435          			{
   1436          				if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
   1437          				{
   1438          					traceTASK_RESUME( pxTCB );
   1439          
   1440          					/* As we are in a critical section we can access the ready
   1441          					lists even if the scheduler is suspended. */
   1442          					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
   1443          					prvAddTaskToReadyList( pxTCB );
   1444          
   1445          					/* We may have just resumed a higher priority task. */
   1446          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   1447          					{
   1448          						/* This yield may not cause the task just resumed to run,
   1449          						but will leave the lists in the correct state for the
   1450          						next yield. */
   1451          						taskYIELD_IF_USING_PREEMPTION();
   1452          					}
   1453          					else
   1454          					{
   1455          						mtCOVERAGE_TEST_MARKER();
   1456          					}
   1457          				}
   1458          				else
   1459          				{
   1460          					mtCOVERAGE_TEST_MARKER();
   1461          				}
   1462          			}
   1463          			taskEXIT_CRITICAL();
   1464          		}
   1465          		else
   1466          		{
   1467          			mtCOVERAGE_TEST_MARKER();
   1468          		}
   1469          	}
   1470          
   1471          #endif /* INCLUDE_vTaskSuspend */
   1472          
   1473          /*-----------------------------------------------------------*/
   1474          
   1475          #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
   1476          
   1477          	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
   1478          	{
   1479          	BaseType_t xYieldRequired = pdFALSE;
   1480          	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
   1481          	UBaseType_t uxSavedInterruptStatus;
   1482          
   1483          		configASSERT( xTaskToResume );
   1484          
   1485          		/* RTOS ports that support interrupt nesting have the concept of a
   1486          		maximum	system call (or maximum API call) interrupt priority.
   1487          		Interrupts that are	above the maximum system call priority are keep
   1488          		permanently enabled, even when the RTOS kernel is in a critical section,
   1489          		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   1490          		is defined in FreeRTOSConfig.h then
   1491          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1492          		failure if a FreeRTOS API function is called from an interrupt that has
   1493          		been assigned a priority above the configured maximum system call
   1494          		priority.  Only FreeRTOS functions that end in FromISR can be called
   1495          		from interrupts	that have been assigned a priority at or (logically)
   1496          		below the maximum system call interrupt priority.  FreeRTOS maintains a
   1497          		separate interrupt safe API to ensure interrupt entry is as fast and as
   1498          		simple as possible.  More information (albeit Cortex-M specific) is
   1499          		provided on the following link:
   1500          		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1501          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1502          
   1503          		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   1504          		{
   1505          			if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
   1506          			{
   1507          				traceTASK_RESUME_FROM_ISR( pxTCB );
   1508          
   1509          				/* Check the ready lists can be accessed. */
   1510          				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   1511          				{
   1512          					/* Ready lists can be accessed so move the task from the
   1513          					suspended list to the ready list directly. */
   1514          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   1515          					{
   1516          						xYieldRequired = pdTRUE;
   1517          					}
   1518          					else
   1519          					{
   1520          						mtCOVERAGE_TEST_MARKER();
   1521          					}
   1522          
   1523          					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
   1524          					prvAddTaskToReadyList( pxTCB );
   1525          				}
   1526          				else
   1527          				{
   1528          					/* The delayed or ready lists cannot be accessed so the task
   1529          					is held in the pending ready list until the scheduler is
   1530          					unsuspended. */
   1531          					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   1532          				}
   1533          			}
   1534          			else
   1535          			{
   1536          				mtCOVERAGE_TEST_MARKER();
   1537          			}
   1538          		}
   1539          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   1540          
   1541          		return xYieldRequired;
   1542          	}
   1543          
   1544          #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
   1545          /*-----------------------------------------------------------*/
   1546          
   1547          void vTaskStartScheduler( void )
   1548          {
   1549          BaseType_t xReturn;
   1550          
   1551          	/* Add the idle task at the lowest priority. */
   1552          	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
   1553          	{
   1554          		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
   1555          		be returned by the xTaskGetIdleTaskHandle() function. */
   1556          		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
   1557          	}
   1558          	#else
   1559          	{
   1560          		/* Create the idle task without storing its handle. */
   1561          		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
   1562          	}
   1563          	#endif /* INCLUDE_xTaskGetIdleTaskHandle */
   1564          
   1565          	#if ( configUSE_TIMERS == 1 )
   1566          	{
   1567          		if( xReturn == pdPASS )
   1568          		{
   1569          			xReturn = xTimerCreateTimerTask();
   1570          		}
   1571          		else
   1572          		{
   1573          			mtCOVERAGE_TEST_MARKER();
   1574          		}
   1575          	}
   1576          	#endif /* configUSE_TIMERS */
   1577          
   1578          	if( xReturn == pdPASS )
   1579          	{
   1580          		/* Interrupts are turned off here, to ensure a tick does not occur
   1581          		before or during the call to xPortStartScheduler().  The stacks of
   1582          		the created tasks contain a status word with interrupts switched on
   1583          		so interrupts will automatically get re-enabled when the first task
   1584          		starts to run. */
   1585          		portDISABLE_INTERRUPTS();
   1586          
   1587          		#if ( configUSE_NEWLIB_REENTRANT == 1 )
   1588          		{
   1589          			/* Switch Newlib's _impure_ptr variable to point to the _reent
   1590          			structure specific to the task that will run first. */
   1591          			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
   1592          		}
   1593          		#endif /* configUSE_NEWLIB_REENTRANT */
   1594          
   1595          		xSchedulerRunning = pdTRUE;
   1596          		xTickCount = ( TickType_t ) 0U;
   1597          
   1598          		/* If configGENERATE_RUN_TIME_STATS is defined then the following
   1599          		macro must be defined to configure the timer/counter used to generate
   1600          		the run time counter time base. */
   1601          		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
   1602          
   1603          		/* Setting up the timer tick is hardware specific and thus in the
   1604          		portable interface. */
   1605          		if( xPortStartScheduler() != pdFALSE )
   1606          		{
   1607          			/* Should not reach here as if the scheduler is running the
   1608          			function will not return. */
   1609          		}
   1610          		else
   1611          		{
   1612          			/* Should only reach here if a task calls xTaskEndScheduler(). */
   1613          		}
   1614          	}
   1615          	else
   1616          	{
   1617          		/* This line will only be reached if the kernel could not be started,
   1618          		because there was not enough FreeRTOS heap to create the idle task
   1619          		or the timer task. */
   1620          		configASSERT( xReturn );
   1621          	}
   1622          }
   1623          /*-----------------------------------------------------------*/
   1624          
   1625          void vTaskEndScheduler( void )
   1626          {
   1627          	/* Stop the scheduler interrupts and call the portable scheduler end
   1628          	routine so the original ISRs can be restored if necessary.  The port
   1629          	layer must ensure interrupts enable	bit is left in the correct state. */
   1630          	portDISABLE_INTERRUPTS();
   1631          	xSchedulerRunning = pdFALSE;
   1632          	vPortEndScheduler();
   1633          }
   1634          /*----------------------------------------------------------*/
   1635          
   1636          void vTaskSuspendAll( void )
   1637          {
   1638          	/* A critical section is not required as the variable is of type
   1639          	BaseType_t.  Please read Richard Barry's reply in the following link to a
   1640          	post in the FreeRTOS support forum before reporting this as a bug! -
   1641          	http://goo.gl/wu4acr */
   1642          	++uxSchedulerSuspended;
   1643          }
   1644          /*----------------------------------------------------------*/
   1645          
   1646          #if ( configUSE_TICKLESS_IDLE != 0 )
   1647          
   1648          	static TickType_t prvGetExpectedIdleTime( void )
   1649          	{
   1650          	TickType_t xReturn;
   1651          
   1652          		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
   1653          		{
   1654          			xReturn = 0;
   1655          		}
   1656          		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
   1657          		{
   1658          			/* There are other idle priority tasks in the ready state.  If
   1659          			time slicing is used then the very next tick interrupt must be
   1660          			processed. */
   1661          			xReturn = 0;
   1662          		}
   1663          		else
   1664          		{
   1665          			xReturn = xNextTaskUnblockTime - xTickCount;
   1666          		}
   1667          
   1668          		return xReturn;
   1669          	}
   1670          
   1671          #endif /* configUSE_TICKLESS_IDLE */
   1672          /*----------------------------------------------------------*/
   1673          
   1674          BaseType_t xTaskResumeAll( void )
   1675          {
   1676          TCB_t *pxTCB;
   1677          BaseType_t xAlreadyYielded = pdFALSE;
   1678          
   1679          	/* If uxSchedulerSuspended is zero then this function does not match a
   1680          	previous call to vTaskSuspendAll(). */
   1681          	configASSERT( uxSchedulerSuspended );
   1682          
   1683          	/* It is possible that an ISR caused a task to be removed from an event
   1684          	list while the scheduler was suspended.  If this was the case then the
   1685          	removed task will have been added to the xPendingReadyList.  Once the
   1686          	scheduler has been resumed it is safe to move all the pending ready
   1687          	tasks from this list into their appropriate ready list. */
   1688          	taskENTER_CRITICAL();
   1689          	{
   1690          		--uxSchedulerSuspended;
   1691          
   1692          		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   1693          		{
   1694          			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
   1695          			{
   1696          				/* Move any readied tasks from the pending list into the
   1697          				appropriate ready list. */
   1698          				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   1699          				{
   1700          					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
   1701          					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   1702          					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   1703          					prvAddTaskToReadyList( pxTCB );
   1704          
   1705          					/* If the moved task has a priority higher than the current
   1706          					task then a yield must be performed. */
   1707          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   1708          					{
   1709          						xYieldPending = pdTRUE;
   1710          					}
   1711          					else
   1712          					{
   1713          						mtCOVERAGE_TEST_MARKER();
   1714          					}
   1715          				}
   1716          
   1717          				/* If any ticks occurred while the scheduler was suspended then
   1718          				they should be processed now.  This ensures the tick count does
   1719          				not	slip, and that any delayed tasks are resumed at the correct
   1720          				time. */
   1721          				if( uxPendedTicks > ( UBaseType_t ) 0U )
   1722          				{
   1723          					while( uxPendedTicks > ( UBaseType_t ) 0U )
   1724          					{
   1725          						if( xTaskIncrementTick() != pdFALSE )
   1726          						{
   1727          							xYieldPending = pdTRUE;
   1728          						}
   1729          						else
   1730          						{
   1731          							mtCOVERAGE_TEST_MARKER();
   1732          						}
   1733          						--uxPendedTicks;
   1734          					}
   1735          				}
   1736          				else
   1737          				{
   1738          					mtCOVERAGE_TEST_MARKER();
   1739          				}
   1740          
   1741          				if( xYieldPending == pdTRUE )
   1742          				{
   1743          					#if( configUSE_PREEMPTION != 0 )
   1744          					{
   1745          						xAlreadyYielded = pdTRUE;
   1746          					}
   1747          					#endif
   1748          					taskYIELD_IF_USING_PREEMPTION();
   1749          				}
   1750          				else
   1751          				{
   1752          					mtCOVERAGE_TEST_MARKER();
   1753          				}
   1754          			}
   1755          		}
   1756          		else
   1757          		{
   1758          			mtCOVERAGE_TEST_MARKER();
   1759          		}
   1760          	}
   1761          	taskEXIT_CRITICAL();
   1762          
   1763          	return xAlreadyYielded;
   1764          }
   1765          /*-----------------------------------------------------------*/
   1766          
   1767          TickType_t xTaskGetTickCount( void )
   1768          {
   1769          TickType_t xTicks;
   1770          
   1771          	/* Critical section required if running on a 16 bit processor. */
   1772          	portTICK_TYPE_ENTER_CRITICAL();
   1773          	{
   1774          		xTicks = xTickCount;
   1775          	}
   1776          	portTICK_TYPE_EXIT_CRITICAL();
   1777          
   1778          	return xTicks;
   1779          }
   1780          /*-----------------------------------------------------------*/
   1781          
   1782          TickType_t xTaskGetTickCountFromISR( void )
   1783          {
   1784          TickType_t xReturn;
   1785          UBaseType_t uxSavedInterruptStatus;
   1786          
   1787          	/* RTOS ports that support interrupt nesting have the concept of a maximum
   1788          	system call (or maximum API call) interrupt priority.  Interrupts that are
   1789          	above the maximum system call priority are kept permanently enabled, even
   1790          	when the RTOS kernel is in a critical section, but cannot make any calls to
   1791          	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
   1792          	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1793          	failure if a FreeRTOS API function is called from an interrupt that has been
   1794          	assigned a priority above the configured maximum system call priority.
   1795          	Only FreeRTOS functions that end in FromISR can be called from interrupts
   1796          	that have been assigned a priority at or (logically) below the maximum
   1797          	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
   1798          	safe API to ensure interrupt entry is as fast and as simple as possible.
   1799          	More information (albeit Cortex-M specific) is provided on the following
   1800          	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1801          	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1802          
   1803          	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
   1804          	{
   1805          		xReturn = xTickCount;
   1806          	}
   1807          	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   1808          
   1809          	return xReturn;
   1810          }
   1811          /*-----------------------------------------------------------*/
   1812          
   1813          UBaseType_t uxTaskGetNumberOfTasks( void )
   1814          {
   1815          	/* A critical section is not required because the variables are of type
   1816          	BaseType_t. */
   1817          	return uxCurrentNumberOfTasks;
   1818          }
   1819          /*-----------------------------------------------------------*/
   1820          
   1821          #if ( INCLUDE_pcTaskGetTaskName == 1 )
   1822          
   1823          	char *pcTaskGetTaskName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
   1824          	{
   1825          	TCB_t *pxTCB;
   1826          
   1827          		/* If null is passed in here then the name of the calling task is being queried. */
   1828          		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
   1829          		configASSERT( pxTCB );
   1830          		return &( pxTCB->pcTaskName[ 0 ] );
   1831          	}
   1832          
   1833          #endif /* INCLUDE_pcTaskGetTaskName */
   1834          /*-----------------------------------------------------------*/
   1835          
   1836          #if ( configUSE_TRACE_FACILITY == 1 )
   1837          
   1838          	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
   1839          	{
   1840          	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
   1841          
   1842          		vTaskSuspendAll();
   1843          		{
   1844          			/* Is there a space in the array for each task in the system? */
   1845          			if( uxArraySize >= uxCurrentNumberOfTasks )
   1846          			{
   1847          				/* Fill in an TaskStatus_t structure with information on each
   1848          				task in the Ready state. */
   1849          				do
   1850          				{
   1851          					uxQueue--;
   1852          					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
   1853          
   1854          				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1855          
   1856          				/* Fill in an TaskStatus_t structure with information on each
   1857          				task in the Blocked state. */
   1858          				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
   1859          				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
   1860          
   1861          				#if( INCLUDE_vTaskDelete == 1 )
   1862          				{
   1863          					/* Fill in an TaskStatus_t structure with information on
   1864          					each task that has been deleted but not yet cleaned up. */
   1865          					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
   1866          				}
   1867          				#endif
   1868          
   1869          				#if ( INCLUDE_vTaskSuspend == 1 )
   1870          				{
   1871          					/* Fill in an TaskStatus_t structure with information on
   1872          					each task in the Suspended state. */
   1873          					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
   1874          				}
   1875          				#endif
   1876          
   1877          				#if ( configGENERATE_RUN_TIME_STATS == 1)
   1878          				{
   1879          					if( pulTotalRunTime != NULL )
   1880          					{
   1881          						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
   1882          							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
   1883          						#else
   1884          							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   1885          						#endif
   1886          					}
   1887          				}
   1888          				#else
   1889          				{
   1890          					if( pulTotalRunTime != NULL )
   1891          					{
   1892          						*pulTotalRunTime = 0;
   1893          					}
   1894          				}
   1895          				#endif
   1896          			}
   1897          			else
   1898          			{
   1899          				mtCOVERAGE_TEST_MARKER();
   1900          			}
   1901          		}
   1902          		( void ) xTaskResumeAll();
   1903          
   1904          		return uxTask;
   1905          	}
   1906          
   1907          #endif /* configUSE_TRACE_FACILITY */
   1908          /*----------------------------------------------------------*/
   1909          
   1910          #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
   1911          
   1912          	TaskHandle_t xTaskGetIdleTaskHandle( void )
   1913          	{
   1914          		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
   1915          		started, then xIdleTaskHandle will be NULL. */
   1916          		configASSERT( ( xIdleTaskHandle != NULL ) );
   1917          		return xIdleTaskHandle;
   1918          	}
   1919          
   1920          #endif /* INCLUDE_xTaskGetIdleTaskHandle */
   1921          /*----------------------------------------------------------*/
   1922          
   1923          /* This conditional compilation should use inequality to 0, not equality to 1.
   1924          This is to ensure vTaskStepTick() is available when user defined low power mode
   1925          implementations require configUSE_TICKLESS_IDLE to be set to a value other than
   1926          1. */
   1927          #if ( configUSE_TICKLESS_IDLE != 0 )
   1928          
   1929          	void vTaskStepTick( const TickType_t xTicksToJump )
   1930          	{
   1931          		/* Correct the tick count value after a period during which the tick
   1932          		was suppressed.  Note this does *not* call the tick hook function for
   1933          		each stepped tick. */
   1934          		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
   1935          		xTickCount += xTicksToJump;
   1936          		traceINCREASE_TICK_COUNT( xTicksToJump );
   1937          	}
   1938          
   1939          #endif /* configUSE_TICKLESS_IDLE */
   1940          /*----------------------------------------------------------*/
   1941          
   1942          BaseType_t xTaskIncrementTick( void )
   1943          {
   1944          TCB_t * pxTCB;
   1945          TickType_t xItemValue;
   1946          BaseType_t xSwitchRequired = pdFALSE;
   1947          
   1948          	/* Called by the portable layer each time a tick interrupt occurs.
   1949          	Increments the tick then checks to see if the new tick value will cause any
   1950          	tasks to be unblocked. */
   1951          	traceTASK_INCREMENT_TICK( xTickCount );
   1952          	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   1953          	{
   1954          		/* Increment the RTOS tick, switching the delayed and overflowed
   1955          		delayed lists if it wraps to 0. */
   1956          		++xTickCount;
   1957          
   1958          		{
   1959          			/* Minor optimisation.  The tick count cannot change in this
   1960          			block. */
   1961          			const TickType_t xConstTickCount = xTickCount;
   1962          
   1963          			if( xConstTickCount == ( TickType_t ) 0U )
   1964          			{
   1965          				taskSWITCH_DELAYED_LISTS();
   1966          			}
   1967          			else
   1968          			{
   1969          				mtCOVERAGE_TEST_MARKER();
   1970          			}
   1971          
   1972          			/* See if this tick has made a timeout expire.  Tasks are stored in
   1973          			the	queue in the order of their wake time - meaning once one task
   1974          			has been found whose block time has not expired there is no need to
   1975          			look any further down the list. */
   1976          			if( xConstTickCount >= xNextTaskUnblockTime )
   1977          			{
   1978          				for( ;; )
   1979          				{
   1980          					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   1981          					{
   1982          						/* The delayed list is empty.  Set xNextTaskUnblockTime
   1983          						to the maximum possible value so it is extremely
   1984          						unlikely that the
   1985          						if( xTickCount >= xNextTaskUnblockTime ) test will pass
   1986          						next time through. */
   1987          						xNextTaskUnblockTime = portMAX_DELAY;
   1988          						break;
   1989          					}
   1990          					else
   1991          					{
   1992          						/* The delayed list is not empty, get the value of the
   1993          						item at the head of the delayed list.  This is the time
   1994          						at which the task at the head of the delayed list must
   1995          						be removed from the Blocked state. */
   1996          						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   1997          						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
   1998          
   1999          						if( xConstTickCount < xItemValue )
   2000          						{
   2001          							/* It is not time to unblock this item yet, but the
   2002          							item value is the time at which the task at the head
   2003          							of the blocked list must be removed from the Blocked
   2004          							state -	so record the item value in
   2005          							xNextTaskUnblockTime. */
   2006          							xNextTaskUnblockTime = xItemValue;
   2007          							break;
   2008          						}
   2009          						else
   2010          						{
   2011          							mtCOVERAGE_TEST_MARKER();
   2012          						}
   2013          
   2014          						/* It is time to remove the item from the Blocked state. */
   2015          						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   2016          
   2017          						/* Is the task waiting on an event also?  If so remove
   2018          						it from the event list. */
   2019          						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   2020          						{
   2021          							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   2022          						}
   2023          						else
   2024          						{
   2025          							mtCOVERAGE_TEST_MARKER();
   2026          						}
   2027          
   2028          						/* Place the unblocked task into the appropriate ready
   2029          						list. */
   2030          						prvAddTaskToReadyList( pxTCB );
   2031          
   2032          						/* A task being unblocked cannot cause an immediate
   2033          						context switch if preemption is turned off. */
   2034          						#if (  configUSE_PREEMPTION == 1 )
   2035          						{
   2036          							/* Preemption is on, but a context switch should
   2037          							only be performed if the unblocked task has a
   2038          							priority that is equal to or higher than the
   2039          							currently executing task. */
   2040          							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   2041          							{
   2042          								xSwitchRequired = pdTRUE;
   2043          							}
   2044          							else
   2045          							{
   2046          								mtCOVERAGE_TEST_MARKER();
   2047          							}
   2048          						}
   2049          						#endif /* configUSE_PREEMPTION */
   2050          					}
   2051          				}
   2052          			}
   2053          		}
   2054          
   2055          		/* Tasks of equal priority to the currently running task will share
   2056          		processing time (time slice) if preemption is on, and the application
   2057          		writer has not explicitly turned time slicing off. */
   2058          		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
   2059          		{
   2060          			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
   2061          			{
   2062          				xSwitchRequired = pdTRUE;
   2063          			}
   2064          			else
   2065          			{
   2066          				mtCOVERAGE_TEST_MARKER();
   2067          			}
   2068          		}
   2069          		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
   2070          
   2071          		#if ( configUSE_TICK_HOOK == 1 )
   2072          		{
   2073          			/* Guard against the tick hook being called when the pended tick
   2074          			count is being unwound (when the scheduler is being unlocked). */
   2075          			if( uxPendedTicks == ( UBaseType_t ) 0U )
   2076          			{
   2077                vApplicationTickHook();
   2078          			}
   2079          			else
   2080          			{
   2081          				mtCOVERAGE_TEST_MARKER();
   2082          			}
   2083          		}
   2084          		#endif /* configUSE_TICK_HOOK */
   2085          	}
   2086          	else
   2087          	{
   2088          		++uxPendedTicks;
   2089          
   2090          		/* The tick hook gets called at regular intervals, even if the
   2091          		scheduler is locked. */
   2092          		#if ( configUSE_TICK_HOOK == 1 )
   2093          		{
   2094                extern void vApplicationTickHook(void);
   2095                vApplicationTickHook();
   2096          		}
   2097          		#endif
   2098          	}
   2099          
   2100          	#if ( configUSE_PREEMPTION == 1 )
   2101          	{
   2102          		if( xYieldPending != pdFALSE )
   2103          		{
   2104          			xSwitchRequired = pdTRUE;
   2105          		}
   2106          		else
   2107          		{
   2108          			mtCOVERAGE_TEST_MARKER();
   2109          		}
   2110          	}
   2111          	#endif /* configUSE_PREEMPTION */
   2112          
   2113          	return xSwitchRequired;
   2114          }
   2115          /*-----------------------------------------------------------*/
   2116          
   2117          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2118          
   2119          	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
   2120          	{
   2121          	TCB_t *xTCB;
   2122          
   2123          		/* If xTask is NULL then it is the task hook of the calling task that is
   2124          		getting set. */
   2125          		if( xTask == NULL )
   2126          		{
   2127          			xTCB = ( TCB_t * ) pxCurrentTCB;
   2128          		}
   2129          		else
   2130          		{
   2131          			xTCB = ( TCB_t * ) xTask;
   2132          		}
   2133          
   2134          		/* Save the hook function in the TCB.  A critical section is required as
   2135          		the value can be accessed from an interrupt. */
   2136          		taskENTER_CRITICAL();
   2137          			xTCB->pxTaskTag = pxHookFunction;
   2138          		taskEXIT_CRITICAL();
   2139          	}
   2140          
   2141          #endif /* configUSE_APPLICATION_TASK_TAG */
   2142          /*-----------------------------------------------------------*/
   2143          
   2144          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2145          
   2146          	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
   2147          	{
   2148          	TCB_t *xTCB;
   2149          	TaskHookFunction_t xReturn;
   2150          
   2151          		/* If xTask is NULL then we are setting our own task hook. */
   2152          		if( xTask == NULL )
   2153          		{
   2154          			xTCB = ( TCB_t * ) pxCurrentTCB;
   2155          		}
   2156          		else
   2157          		{
   2158          			xTCB = ( TCB_t * ) xTask;
   2159          		}
   2160          
   2161          		/* Save the hook function in the TCB.  A critical section is required as
   2162          		the value can be accessed from an interrupt. */
   2163          		taskENTER_CRITICAL();
   2164          		{
   2165          			xReturn = xTCB->pxTaskTag;
   2166          		}
   2167          		taskEXIT_CRITICAL();
   2168          
   2169          		return xReturn;
   2170          	}
   2171          
   2172          #endif /* configUSE_APPLICATION_TASK_TAG */
   2173          /*-----------------------------------------------------------*/
   2174          
   2175          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2176          
   2177          	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
   2178          	{
   2179          	TCB_t *xTCB;
   2180          	BaseType_t xReturn;
   2181          
   2182          		/* If xTask is NULL then we are calling our own task hook. */
   2183          		if( xTask == NULL )
   2184          		{
   2185          			xTCB = ( TCB_t * ) pxCurrentTCB;
   2186          		}
   2187          		else
   2188          		{
   2189          			xTCB = ( TCB_t * ) xTask;
   2190          		}
   2191          
   2192          		if( xTCB->pxTaskTag != NULL )
   2193          		{
   2194          			xReturn = xTCB->pxTaskTag( pvParameter );
   2195          		}
   2196          		else
   2197          		{
   2198          			xReturn = pdFAIL;
   2199          		}
   2200          
   2201          		return xReturn;
   2202          	}
   2203          
   2204          #endif /* configUSE_APPLICATION_TASK_TAG */
   2205          /*-----------------------------------------------------------*/
   2206          
   2207          void vTaskSwitchContext( void )
   2208          {
   2209          	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
   2210          	{
   2211          		/* The scheduler is currently suspended - do not allow a context
   2212          		switch. */
   2213          		xYieldPending = pdTRUE;
   2214          	}
   2215          	else
   2216          	{
   2217          		xYieldPending = pdFALSE;
   2218          		traceTASK_SWITCHED_OUT();
   2219          
   2220          		#if ( configGENERATE_RUN_TIME_STATS == 1 )
   2221          		{
   2222          				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
   2223          					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
   2224          				#else
   2225          					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   2226          				#endif
   2227          
   2228          				/* Add the amount of time the task has been running to the
   2229          				accumulated	time so far.  The time the task started running was
   2230          				stored in ulTaskSwitchedInTime.  Note that there is no overflow
   2231          				protection here	so count values are only valid until the timer
   2232          				overflows.  The guard against negative values is to protect
   2233          				against suspect run time stat counter implementations - which
   2234          				are provided by the application, not the kernel. */
   2235          				if( ulTotalRunTime > ulTaskSwitchedInTime )
   2236          				{
   2237          					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
   2238          				}
   2239          				else
   2240          				{
   2241          					mtCOVERAGE_TEST_MARKER();
   2242          				}
   2243          				ulTaskSwitchedInTime = ulTotalRunTime;
   2244          		}
   2245          		#endif /* configGENERATE_RUN_TIME_STATS */
   2246          
   2247          		/* Check for stack overflow, if configured. */
   2248          		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
   2249          		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
   2250          
   2251          		/* Select a new task to run using either the generic C or port
   2252          		optimised asm code. */
   2253          		taskSELECT_HIGHEST_PRIORITY_TASK();
   2254          		traceTASK_SWITCHED_IN();
   2255          
   2256          		#if ( configUSE_NEWLIB_REENTRANT == 1 )
   2257          		{
   2258          			/* Switch Newlib's _impure_ptr variable to point to the _reent
   2259          			structure specific to this task. */
   2260          			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
   2261          		}
   2262          		#endif /* configUSE_NEWLIB_REENTRANT */
   2263          	}
   2264          }
   2265          /*-----------------------------------------------------------*/
   2266          
   2267          void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
   2268          {
   2269          TickType_t xTimeToWake;
   2270          
   2271          	configASSERT( pxEventList );
   2272          
   2273          	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
   2274          	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
   2275          
   2276          	/* Place the event list item of the TCB in the appropriate event list.
   2277          	This is placed in the list in priority order so the highest priority task
   2278          	is the first to be woken by the event.  The queue that contains the event
   2279          	list is locked, preventing simultaneous access from interrupts. */
   2280          	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   2281          
   2282          	/* The task must be removed from from the ready list before it is added to
   2283          	the blocked list as the same list item is used for both lists.  Exclusive
   2284          	access to the ready lists guaranteed because the scheduler is locked. */
   2285          	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   2286          	{
   2287          		/* The current task must be in a ready list, so there is no need to
   2288          		check, and the port reset macro can be called directly. */
   2289          		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   2290          	}
   2291          	else
   2292          	{
   2293          		mtCOVERAGE_TEST_MARKER();
   2294          	}
   2295          
   2296          	#if ( INCLUDE_vTaskSuspend == 1 )
   2297          	{
   2298          		if( xTicksToWait == portMAX_DELAY )
   2299          		{
   2300          			/* Add the task to the suspended task list instead of a delayed task
   2301          			list to ensure the task is not woken by a timing event.  It will
   2302          			block indefinitely. */
   2303          			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   2304          		}
   2305          		else
   2306          		{
   2307          			/* Calculate the time at which the task should be woken if the event
   2308          			does not occur.  This may overflow but this doesn't matter, the
   2309          			scheduler will handle it. */
   2310          			xTimeToWake = xTickCount + xTicksToWait;
   2311          			prvAddCurrentTaskToDelayedList( xTimeToWake );
   2312          		}
   2313          	}
   2314          	#else /* INCLUDE_vTaskSuspend */
   2315          	{
   2316          			/* Calculate the time at which the task should be woken if the event does
   2317          			not occur.  This may overflow but this doesn't matter, the scheduler
   2318          			will handle it. */
   2319          			xTimeToWake = xTickCount + xTicksToWait;
   2320          			prvAddCurrentTaskToDelayedList( xTimeToWake );
   2321          	}
   2322          	#endif /* INCLUDE_vTaskSuspend */
   2323          }
   2324          /*-----------------------------------------------------------*/
   2325          
   2326          void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
   2327          {
   2328          TickType_t xTimeToWake;
   2329          
   2330          	configASSERT( pxEventList );
   2331          
   2332          	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
   2333          	the event groups implementation. */
   2334          	configASSERT( uxSchedulerSuspended != 0 );
   2335          
   2336          	/* Store the item value in the event list item.  It is safe to access the
   2337          	event list item here as interrupts won't access the event list item of a
   2338          	task that is not in the Blocked state. */
   2339          	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
   2340          
   2341          	/* Place the event list item of the TCB at the end of the appropriate event
   2342          	list.  It is safe to access the event list here because it is part of an
   2343          	event group implementation - and interrupts don't access event groups
   2344          	directly (instead they access them indirectly by pending function calls to
   2345          	the task level). */
   2346          	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   2347          
   2348          	/* The task must be removed from the ready list before it is added to the
   2349          	blocked list.  Exclusive access can be assured to the ready list as the
   2350          	scheduler is locked. */
   2351          	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   2352          	{
   2353          		/* The current task must be in a ready list, so there is no need to
   2354          		check, and the port reset macro can be called directly. */
   2355          		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   2356          	}
   2357          	else
   2358          	{
   2359          		mtCOVERAGE_TEST_MARKER();
   2360          	}
   2361          
   2362          	#if ( INCLUDE_vTaskSuspend == 1 )
   2363          	{
   2364          		if( xTicksToWait == portMAX_DELAY )
   2365          		{
   2366          			/* Add the task to the suspended task list instead of a delayed task
   2367          			list to ensure it is not woken by a timing event.  It will block
   2368          			indefinitely. */
   2369          			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   2370          		}
   2371          		else
   2372          		{
   2373          			/* Calculate the time at which the task should be woken if the event
   2374          			does not occur.  This may overflow but this doesn't matter, the
   2375          			kernel will manage it correctly. */
   2376          			xTimeToWake = xTickCount + xTicksToWait;
   2377          			prvAddCurrentTaskToDelayedList( xTimeToWake );
   2378          		}
   2379          	}
   2380          	#else /* INCLUDE_vTaskSuspend */
   2381          	{
   2382          			/* Calculate the time at which the task should be woken if the event does
   2383          			not occur.  This may overflow but this doesn't matter, the kernel
   2384          			will manage it correctly. */
   2385          			xTimeToWake = xTickCount + xTicksToWait;
   2386          			prvAddCurrentTaskToDelayedList( xTimeToWake );
   2387          	}
   2388          	#endif /* INCLUDE_vTaskSuspend */
   2389          }
   2390          /*-----------------------------------------------------------*/
   2391          
   2392          #if configUSE_TIMERS == 1
   2393          
   2394          	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait )
   2395          	{
   2396          	TickType_t xTimeToWake;
   2397          
   2398          		configASSERT( pxEventList );
   2399          
   2400          		/* This function should not be called by application code hence the
   2401          		'Restricted' in its name.  It is not part of the public API.  It is
   2402          		designed for use by kernel code, and has special calling requirements -
   2403          		it should be called from a critical section. */
   2404          
   2405          
   2406          		/* Place the event list item of the TCB in the appropriate event list.
   2407          		In this case it is assume that this is the only task that is going to
   2408          		be waiting on this event list, so the faster vListInsertEnd() function
   2409          		can be used in place of vListInsert. */
   2410          		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   2411          
   2412          		/* We must remove this task from the ready list before adding it to the
   2413          		blocked list as the same list item is used for both lists.  This
   2414          		function is called form a critical section. */
   2415          		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   2416          		{
   2417          			/* The current task must be in a ready list, so there is no need to
   2418          			check, and the port reset macro can be called directly. */
   2419          			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   2420          		}
   2421          		else
   2422          		{
   2423          			mtCOVERAGE_TEST_MARKER();
   2424          		}
   2425          
   2426          		/* Calculate the time at which the task should be woken if the event does
   2427          		not occur.  This may overflow but this doesn't matter. */
   2428          		xTimeToWake = xTickCount + xTicksToWait;
   2429          
   2430          		traceTASK_DELAY_UNTIL();
   2431          		prvAddCurrentTaskToDelayedList( xTimeToWake );
   2432          	}
   2433          
   2434          #endif /* configUSE_TIMERS */
   2435          /*-----------------------------------------------------------*/
   2436          
   2437          BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
   2438          {
   2439          TCB_t *pxUnblockedTCB;
   2440          BaseType_t xReturn;
   2441          
   2442          	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
   2443          	called from a critical section within an ISR. */
   2444          
   2445          	/* The event list is sorted in priority order, so the first in the list can
   2446          	be removed as it is known to be the highest priority.  Remove the TCB from
   2447          	the delayed list, and add it to the ready list.
   2448          
   2449          	If an event is for a queue that is locked then this function will never
   2450          	get called - the lock count on the queue will get modified instead.  This
   2451          	means exclusive access to the event list is guaranteed here.
   2452          
   2453          	This function assumes that a check has already been made to ensure that
   2454          	pxEventList is not empty. */
   2455          	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
   2456          	configASSERT( pxUnblockedTCB );
   2457          	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
   2458          
   2459          	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   2460          	{
   2461          		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
   2462          		prvAddTaskToReadyList( pxUnblockedTCB );
   2463          	}
   2464          	else
   2465          	{
   2466          		/* The delayed and ready lists cannot be accessed, so hold this task
   2467          		pending until the scheduler is resumed. */
   2468          		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   2469          	}
   2470          
   2471          	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   2472          	{
   2473          		/* Return true if the task removed from the event list has a higher
   2474          		priority than the calling task.  This allows the calling task to know if
   2475          		it should force a context switch now. */
   2476          		xReturn = pdTRUE;
   2477          
   2478          		/* Mark that a yield is pending in case the user is not using the
   2479          		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
   2480          		xYieldPending = pdTRUE;
   2481          	}
   2482          	else
   2483          	{
   2484          		xReturn = pdFALSE;
   2485          	}
   2486          
   2487          	#if( configUSE_TICKLESS_IDLE == 1 )
   2488          	{
   2489          		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
   2490          		might be set to the blocked task's time out time.  If the task is
   2491          		unblocked for a reason other than a timeout xNextTaskUnblockTime is
   2492          		normally left unchanged, because it is automatically get reset to a new
   2493          		value when the tick count equals xNextTaskUnblockTime.  However if
   2494          		tickless idling is used it might be more important to enter sleep mode
   2495          		at the earliest possible time - so reset xNextTaskUnblockTime here to
   2496          		ensure it is updated at the earliest possible time. */
   2497          		prvResetNextTaskUnblockTime();
   2498          	}
   2499          	#endif
   2500          
   2501          	return xReturn;
   2502          }
   2503          /*-----------------------------------------------------------*/
   2504          
   2505          BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
   2506          {
   2507          TCB_t *pxUnblockedTCB;
   2508          BaseType_t xReturn;
   2509          
   2510          	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
   2511          	the event flags implementation. */
   2512          	configASSERT( uxSchedulerSuspended != pdFALSE );
   2513          
   2514          	/* Store the new item value in the event list. */
   2515          	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
   2516          
   2517          	/* Remove the event list form the event flag.  Interrupts do not access
   2518          	event flags. */
   2519          	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
   2520          	configASSERT( pxUnblockedTCB );
   2521          	( void ) uxListRemove( pxEventListItem );
   2522          
   2523          	/* Remove the task from the delayed list and add it to the ready list.  The
   2524          	scheduler is suspended so interrupts will not be accessing the ready
   2525          	lists. */
   2526          	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
   2527          	prvAddTaskToReadyList( pxUnblockedTCB );
   2528          
   2529          	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   2530          	{
   2531          		/* Return true if the task removed from the event list has
   2532          		a higher priority than the calling task.  This allows
   2533          		the calling task to know if it should force a context
   2534          		switch now. */
   2535          		xReturn = pdTRUE;
   2536          
   2537          		/* Mark that a yield is pending in case the user is not using the
   2538          		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
   2539          		xYieldPending = pdTRUE;
   2540          	}
   2541          	else
   2542          	{
   2543          		xReturn = pdFALSE;
   2544          	}
   2545          
   2546          	return xReturn;
   2547          }
   2548          /*-----------------------------------------------------------*/
   2549          
   2550          void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
   2551          {
   2552          	configASSERT( pxTimeOut );
   2553          	pxTimeOut->xOverflowCount = xNumOfOverflows;
   2554          	pxTimeOut->xTimeOnEntering = xTickCount;
   2555          }
   2556          /*-----------------------------------------------------------*/
   2557          
   2558          BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
   2559          {
   2560          BaseType_t xReturn;
   2561          
   2562          	configASSERT( pxTimeOut );
   2563          	configASSERT( pxTicksToWait );
   2564          
   2565          	taskENTER_CRITICAL();
   2566          	{
   2567          		/* Minor optimisation.  The tick count cannot change in this block. */
   2568          		const TickType_t xConstTickCount = xTickCount;
   2569          
   2570          		#if ( INCLUDE_vTaskSuspend == 1 )
   2571          			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
   2572          			the maximum block time then the task should block indefinitely, and
   2573          			therefore never time out. */
   2574          			if( *pxTicksToWait == portMAX_DELAY )
   2575          			{
   2576          				xReturn = pdFALSE;
   2577          			}
   2578          			else /* We are not blocking indefinitely, perform the checks below. */
   2579          		#endif
   2580          
   2581          		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
   2582          		{
   2583          			/* The tick count is greater than the time at which vTaskSetTimeout()
   2584          			was called, but has also overflowed since vTaskSetTimeOut() was called.
   2585          			It must have wrapped all the way around and gone past us again. This
   2586          			passed since vTaskSetTimeout() was called. */
   2587          			xReturn = pdTRUE;
   2588          		}
   2589          		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
   2590          		{
   2591          			/* Not a genuine timeout. Adjust parameters for time remaining. */
   2592          			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
   2593          			vTaskSetTimeOutState( pxTimeOut );
   2594          			xReturn = pdFALSE;
   2595          		}
   2596          		else
   2597          		{
   2598          			xReturn = pdTRUE;
   2599          		}
   2600          	}
   2601          	taskEXIT_CRITICAL();
   2602          
   2603          	return xReturn;
   2604          }
   2605          /*-----------------------------------------------------------*/
   2606          
   2607          void vTaskMissedYield( void )
   2608          {
   2609          	xYieldPending = pdTRUE;
   2610          }
   2611          /*-----------------------------------------------------------*/
   2612          
   2613          #if ( configUSE_TRACE_FACILITY == 1 )
   2614          
   2615          	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
   2616          	{
   2617          	UBaseType_t uxReturn;
   2618          	TCB_t *pxTCB;
   2619          
   2620          		if( xTask != NULL )
   2621          		{
   2622          			pxTCB = ( TCB_t * ) xTask;
   2623          			uxReturn = pxTCB->uxTaskNumber;
   2624          		}
   2625          		else
   2626          		{
   2627          			uxReturn = 0U;
   2628          		}
   2629          
   2630          		return uxReturn;
   2631          	}
   2632          
   2633          #endif /* configUSE_TRACE_FACILITY */
   2634          /*-----------------------------------------------------------*/
   2635          
   2636          #if ( configUSE_TRACE_FACILITY == 1 )
   2637          
   2638          	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
   2639          	{
   2640          	TCB_t *pxTCB;
   2641          
   2642          		if( xTask != NULL )
   2643          		{
   2644          			pxTCB = ( TCB_t * ) xTask;
   2645          			pxTCB->uxTaskNumber = uxHandle;
   2646          		}
   2647          	}
   2648          
   2649          #endif /* configUSE_TRACE_FACILITY */
   2650          
   2651          /*
   2652           * -----------------------------------------------------------
   2653           * The Idle task.
   2654           * ----------------------------------------------------------
   2655           *
   2656           * The portTASK_FUNCTION() macro is used to allow port/compiler specific
   2657           * language extensions.  The equivalent prototype for this function is:
   2658           *
   2659           * void prvIdleTask( void *pvParameters );
   2660           *
   2661           */
   2662          static portTASK_FUNCTION( prvIdleTask, pvParameters )
   2663          {
   2664          	/* Stop warnings. */
   2665          	( void ) pvParameters;
   2666          
   2667          	for( ;; )
   2668          	{
   2669          		/* See if any tasks have been deleted. */
   2670          		prvCheckTasksWaitingTermination();
   2671          
   2672          		#if ( configUSE_PREEMPTION == 0 )
   2673          		{
   2674          			/* If we are not using preemption we keep forcing a task switch to
   2675          			see if any other task has become available.  If we are using
   2676          			preemption we don't need to do this as any task becoming available
   2677          			will automatically get the processor anyway. */
   2678          			taskYIELD();
   2679          		}
   2680          		#endif /* configUSE_PREEMPTION */
   2681          
   2682          		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
   2683          		{
   2684          			/* When using preemption tasks of equal priority will be
   2685          			timesliced.  If a task that is sharing the idle priority is ready
   2686          			to run then the idle task should yield before the end of the
   2687          			timeslice.
   2688          
   2689          			A critical region is not required here as we are just reading from
   2690          			the list, and an occasional incorrect value will not matter.  If
   2691          			the ready list at the idle priority contains more than one task
   2692          			then a task other than the idle task is ready to execute. */
   2693          			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
   2694          			{
   2695          				taskYIELD();
   2696          			}
   2697          			else
   2698          			{
   2699          				mtCOVERAGE_TEST_MARKER();
   2700          			}
   2701          		}
   2702          		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
   2703          
   2704          		#if ( configUSE_IDLE_HOOK == 1 )
   2705          		{
   2706          		  extern void vApplicationIdleHook( void );
   2707          
   2708          			/* Call the user defined function from within the idle task.  This
   2709          			allows the application designer to add background functionality
   2710          			without the overhead of a separate task.
   2711          			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
   2712          			CALL A FUNCTION THAT MIGHT BLOCK. */
   2713          		  vApplicationIdleHook();
   2714          		}
   2715          		#endif /* configUSE_IDLE_HOOK */
   2716          
   2717          		/* This conditional compilation should use inequality to 0, not equality
   2718          		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
   2719          		user defined low power mode	implementations require
   2720          		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
   2721          		#if ( configUSE_TICKLESS_IDLE != 0 )
   2722          		{
   2723          		TickType_t xExpectedIdleTime;
   2724          
   2725          			/* It is not desirable to suspend then resume the scheduler on
   2726          			each iteration of the idle task.  Therefore, a preliminary
   2727          			test of the expected idle time is performed without the
   2728          			scheduler suspended.  The result here is not necessarily
   2729          			valid. */
   2730          			xExpectedIdleTime = prvGetExpectedIdleTime();
   2731          
   2732          			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
   2733          			{
   2734          				vTaskSuspendAll();
   2735          				{
   2736          					/* Now the scheduler is suspended, the expected idle
   2737          					time can be sampled again, and this time its value can
   2738          					be used. */
   2739          					configASSERT( xNextTaskUnblockTime >= xTickCount );
   2740          					xExpectedIdleTime = prvGetExpectedIdleTime();
   2741          
   2742          					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
   2743          					{
   2744          						traceLOW_POWER_IDLE_BEGIN();
   2745          						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
   2746          						traceLOW_POWER_IDLE_END();
   2747          					}
   2748          					else
   2749          					{
   2750          						mtCOVERAGE_TEST_MARKER();
   2751          					}
   2752          				}
   2753          				( void ) xTaskResumeAll();
   2754          			}
   2755          			else
   2756          			{
   2757          				mtCOVERAGE_TEST_MARKER();
   2758          			}
   2759          		}
   2760          		#endif /* configUSE_TICKLESS_IDLE */
   2761          	}
   2762          }
   2763          /*-----------------------------------------------------------*/
   2764          
   2765          #if configUSE_TICKLESS_IDLE != 0
   2766          
   2767          	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
   2768          	{
   2769          	eSleepModeStatus eReturn = eStandardSleep;
   2770          
   2771          		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
   2772          		{
   2773          			/* A task was made ready while the scheduler was suspended. */
   2774          			eReturn = eAbortSleep;
   2775          		}
   2776          		else if( xYieldPending != pdFALSE )
   2777          		{
   2778          			/* A yield was pended while the scheduler was suspended. */
   2779          			eReturn = eAbortSleep;
   2780          		}
   2781          		else
   2782          		{
   2783          			#if configUSE_TIMERS == 0
   2784          			{
   2785          				/* The idle task exists in addition to the application tasks. */
   2786          				const UBaseType_t uxNonApplicationTasks = 1;
   2787          
   2788          				/* If timers are not being used and all the tasks are in the
   2789          				suspended list (which might mean they have an infinite block
   2790          				time rather than actually being suspended) then it is safe to
   2791          				turn all clocks off and just wait for external interrupts. */
   2792          				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
   2793          				{
   2794          					eReturn = eNoTasksWaitingTimeout;
   2795          				}
   2796          				else
   2797          				{
   2798          					mtCOVERAGE_TEST_MARKER();
   2799          				}
   2800          			}
   2801          			#endif /* configUSE_TIMERS */
   2802          		}
   2803          
   2804          		return eReturn;
   2805          	}
   2806          #endif /* configUSE_TICKLESS_IDLE */
   2807          /*-----------------------------------------------------------*/
   2808          
   2809          static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
   2810          {
   2811          UBaseType_t x;
   2812          
   2813          	/* Store the task name in the TCB. */
   2814          	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   2815          	{
   2816          		pxTCB->pcTaskName[ x ] = pcName[ x ];
   2817          
   2818          		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
   2819          		configMAX_TASK_NAME_LEN characters just in case the memory after the
   2820          		string is not accessible (extremely unlikely). */
   2821          		if( pcName[ x ] == 0x00 )
   2822          		{
   2823          			break;
   2824          		}
   2825          		else
   2826          		{
   2827          			mtCOVERAGE_TEST_MARKER();
   2828          		}
   2829          	}
   2830          
   2831          	/* Ensure the name string is terminated in the case that the string length
   2832          	was greater or equal to configMAX_TASK_NAME_LEN. */
   2833          	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
   2834          
   2835          	/* This is used as an array index so must ensure it's not too large.  First
   2836          	remove the privilege bit if one is present. */
   2837          	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   2838          	{
   2839          		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
   2840          	}
   2841          	else
   2842          	{
   2843          		mtCOVERAGE_TEST_MARKER();
   2844          	}
   2845          
   2846          	pxTCB->uxPriority = uxPriority;
   2847          	#if ( configUSE_MUTEXES == 1 )
   2848          	{
   2849          		pxTCB->uxBasePriority = uxPriority;
   2850          		pxTCB->uxMutexesHeld = 0;
   2851          	}
   2852          	#endif /* configUSE_MUTEXES */
   2853          
   2854          	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
   2855          	vListInitialiseItem( &( pxTCB->xEventListItem ) );
   2856          
   2857          	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
   2858          	back to	the containing TCB from a generic item in a list. */
   2859          	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
   2860          
   2861          	/* Event lists are always in priority order. */
   2862          	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   2863          	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
   2864          
   2865          	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
   2866          	{
   2867          		pxTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
   2868          	}
   2869          	#endif /* portCRITICAL_NESTING_IN_TCB */
   2870          
   2871          	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2872          	{
   2873          		pxTCB->pxTaskTag = NULL;
   2874          	}
   2875          	#endif /* configUSE_APPLICATION_TASK_TAG */
   2876          
   2877          	#if ( configGENERATE_RUN_TIME_STATS == 1 )
   2878          	{
   2879          		pxTCB->ulRunTimeCounter = 0UL;
   2880          	}
   2881          	#endif /* configGENERATE_RUN_TIME_STATS */
   2882          
   2883          	#if ( portUSING_MPU_WRAPPERS == 1 )
   2884          	{
   2885          		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
   2886          	}
   2887          	#else /* portUSING_MPU_WRAPPERS */
   2888          	{
   2889          		( void ) xRegions;
   2890          		( void ) usStackDepth;
   2891          	}
   2892          	#endif /* portUSING_MPU_WRAPPERS */
   2893          
   2894          	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
   2895          	{
   2896          		pxTCB->ulNotifiedValue = 0;
   2897          		pxTCB->eNotifyState = eNotWaitingNotification;
   2898          	}
   2899          	#endif
   2900          
   2901          	#if ( configUSE_NEWLIB_REENTRANT == 1 )
   2902          	{
   2903          		/* Initialise this task's Newlib reent structure. */
   2904          		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
   2905          	}
   2906          	#endif /* configUSE_NEWLIB_REENTRANT */
   2907          }
   2908          /*-----------------------------------------------------------*/
   2909          
   2910          #if ( portUSING_MPU_WRAPPERS == 1 )
   2911          
   2912          	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
   2913          	{
   2914          	TCB_t *pxTCB;
   2915          
   2916          		/* If null is passed in here then we are deleting ourselves. */
   2917          		pxTCB = prvGetTCBFromHandle( xTaskToModify );
   2918          
   2919                  vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
   2920          	}
   2921          
   2922          #endif /* portUSING_MPU_WRAPPERS */
   2923          /*-----------------------------------------------------------*/
   2924          
   2925          static void prvInitialiseTaskLists( void )
   2926          {
   2927          UBaseType_t uxPriority;
   2928          
   2929          	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   2930          	{
   2931          		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
   2932          	}
   2933          
   2934          	vListInitialise( &xDelayedTaskList1 );
   2935          	vListInitialise( &xDelayedTaskList2 );
   2936          	vListInitialise( &xPendingReadyList );
   2937          
   2938          	#if ( INCLUDE_vTaskDelete == 1 )
   2939          	{
   2940          		vListInitialise( &xTasksWaitingTermination );
   2941          	}
   2942          	#endif /* INCLUDE_vTaskDelete */
   2943          
   2944          	#if ( INCLUDE_vTaskSuspend == 1 )
   2945          	{
   2946          		vListInitialise( &xSuspendedTaskList );
   2947          	}
   2948          	#endif /* INCLUDE_vTaskSuspend */
   2949          
   2950          	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
   2951          	using list2. */
   2952          	pxDelayedTaskList = &xDelayedTaskList1;
   2953          	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   2954          }
   2955          /*-----------------------------------------------------------*/
   2956          
   2957          static void prvCheckTasksWaitingTermination( void )
   2958          {
   2959          	#if ( INCLUDE_vTaskDelete == 1 )
   2960          	{
   2961          		BaseType_t xListIsEmpty;
   2962          
   2963          		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
   2964          		too often in the idle task. */
   2965          		while( uxTasksDeleted > ( UBaseType_t ) 0U )
   2966          		{
   2967          			vTaskSuspendAll();
   2968          			{
   2969          				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
   2970          			}
   2971          			( void ) xTaskResumeAll();
   2972          
   2973          			if( xListIsEmpty == pdFALSE )
   2974          			{
   2975          				TCB_t *pxTCB;
   2976          
   2977          				taskENTER_CRITICAL();
   2978          				{
   2979          					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
   2980          					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   2981          					--uxCurrentNumberOfTasks;
   2982          					--uxTasksDeleted;
   2983          				}
   2984          				taskEXIT_CRITICAL();
   2985          
   2986          				prvDeleteTCB( pxTCB );
   2987          			}
   2988          			else
   2989          			{
   2990          				mtCOVERAGE_TEST_MARKER();
   2991          			}
   2992          		}
   2993          	}
   2994          	#endif /* vTaskDelete */
   2995          }
   2996          /*-----------------------------------------------------------*/
   2997          
   2998          static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
   2999          {
   3000          	/* The list item will be inserted in wake time order. */
   3001          	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
   3002          
   3003          	if( xTimeToWake < xTickCount )
   3004          	{
   3005          		/* Wake time has overflowed.  Place this item in the overflow list. */
   3006          		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   3007          	}
   3008          	else
   3009          	{
   3010          		/* The wake time has not overflowed, so the current block list is used. */
   3011          		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   3012          
   3013          		/* If the task entering the blocked state was placed at the head of the
   3014          		list of blocked tasks then xNextTaskUnblockTime needs to be updated
   3015          		too. */
   3016          		if( xTimeToWake < xNextTaskUnblockTime )
   3017          		{
   3018          			xNextTaskUnblockTime = xTimeToWake;
   3019          		}
   3020          		else
   3021          		{
   3022          			mtCOVERAGE_TEST_MARKER();
   3023          		}
   3024          	}
   3025          }
   3026          /*-----------------------------------------------------------*/
   3027          
   3028          static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
   3029          {
   3030          TCB_t *pxNewTCB;
   3031          
   3032          	/* If the stack grows down then allocate the stack then the TCB so the stack
   3033          	does not grow into the TCB.  Likewise if the stack grows up then allocate
   3034          	the TCB then the stack. */
   3035          	#if( portSTACK_GROWTH > 0 )
   3036          	{
   3037          		/* Allocate space for the TCB.  Where the memory comes from depends on
   3038          		the implementation of the port malloc function. */
   3039          		pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
   3040          
   3041          		if( pxNewTCB != NULL )
   3042          		{
   3043          			/* Allocate space for the stack used by the task being created.
   3044          			The base of the stack memory stored in the TCB so the task can
   3045          			be deleted later if required. */
   3046          			pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   3047          
   3048          			if( pxNewTCB->pxStack == NULL )
   3049          			{
   3050          				/* Could not allocate the stack.  Delete the allocated TCB. */
   3051          				vPortFree( pxNewTCB );
   3052          				pxNewTCB = NULL;
   3053          			}
   3054          		}
   3055          	}
   3056          	#else /* portSTACK_GROWTH */
   3057          	{
   3058          	StackType_t *pxStack;
   3059          
   3060          		/* Allocate space for the stack used by the task being created. */
   3061          		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   3062          
   3063          		if( pxStack != NULL )
   3064          		{
   3065          			/* Allocate space for the TCB.  Where the memory comes from depends
   3066          			on the implementation of the port malloc function. */
   3067          			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
   3068          
   3069          			if( pxNewTCB != NULL )
   3070          			{
   3071          				/* Store the stack location in the TCB. */
   3072          				pxNewTCB->pxStack = pxStack;
   3073          			}
   3074          			else
   3075          			{
   3076          				/* The stack cannot be used as the TCB was not created.  Free it
   3077          				again. */
   3078          				vPortFree( pxStack );
   3079          			}
   3080          		}
   3081          		else
   3082          		{
   3083          			pxNewTCB = NULL;
   3084          		}
   3085          	}
   3086          	#endif /* portSTACK_GROWTH */
   3087          
   3088          	if( pxNewTCB != NULL )
   3089          	{
   3090          		/* Avoid dependency on memset() if it is not required. */
   3091          		#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
   3092          		{
   3093          			/* Just to help debugging. */
   3094          			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
   3095          		}
   3096          		#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
   3097          	}
   3098          
   3099          	return pxNewTCB;
   3100          }
   3101          /*-----------------------------------------------------------*/
   3102          
   3103          #if ( configUSE_TRACE_FACILITY == 1 )
   3104          
   3105          	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
   3106          	{
   3107          	volatile TCB_t *pxNextTCB, *pxFirstTCB;
   3108          	UBaseType_t uxTask = 0;
   3109          
   3110          		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
   3111          		{
   3112          			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
   3113          
   3114          			/* Populate an TaskStatus_t structure within the
   3115          			pxTaskStatusArray array for each task that is referenced from
   3116          			pxList.  See the definition of TaskStatus_t in task.h for the
   3117          			meaning of each TaskStatus_t structure member. */
   3118          			do
   3119          			{
   3120          				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
   3121          
   3122          				pxTaskStatusArray[ uxTask ].xHandle = ( TaskHandle_t ) pxNextTCB;
   3123          				pxTaskStatusArray[ uxTask ].pcTaskName = ( const char * ) &( pxNextTCB->pcTaskName [ 0 ] );
   3124          				pxTaskStatusArray[ uxTask ].xTaskNumber = pxNextTCB->uxTCBNumber;
   3125          				pxTaskStatusArray[ uxTask ].eCurrentState = eState;
   3126          				pxTaskStatusArray[ uxTask ].uxCurrentPriority = pxNextTCB->uxPriority;
   3127          
   3128          				#if ( INCLUDE_vTaskSuspend == 1 )
   3129          				{
   3130          					/* If the task is in the suspended list then there is a chance
   3131          					it is actually just blocked indefinitely - so really it should
   3132          					be reported as being in the Blocked state. */
   3133          					if( eState == eSuspended )
   3134          					{
   3135          						if( listLIST_ITEM_CONTAINER( &( pxNextTCB->xEventListItem ) ) != NULL )
   3136          						{
   3137          							pxTaskStatusArray[ uxTask ].eCurrentState = eBlocked;
   3138          						}
   3139          					}
   3140          				}
   3141          				#endif /* INCLUDE_vTaskSuspend */
   3142          
   3143          				#if ( configUSE_MUTEXES == 1 )
   3144          				{
   3145          					pxTaskStatusArray[ uxTask ].uxBasePriority = pxNextTCB->uxBasePriority;
   3146          				}
   3147          				#else
   3148          				{
   3149          					pxTaskStatusArray[ uxTask ].uxBasePriority = 0;
   3150          				}
   3151          				#endif
   3152          
   3153          				#if ( configGENERATE_RUN_TIME_STATS == 1 )
   3154          				{
   3155          					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = pxNextTCB->ulRunTimeCounter;
   3156          				}
   3157          				#else
   3158          				{
   3159          					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = 0;
   3160          				}
   3161          				#endif
   3162          
   3163          				#if ( portSTACK_GROWTH > 0 )
   3164          				{
   3165          					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxNextTCB->pxEndOfStack );
   3166          				}
   3167          				#else
   3168          				{
   3169          					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxNextTCB->pxStack );
   3170          				}
   3171          				#endif
   3172          
   3173          				uxTask++;
   3174          
   3175          			} while( pxNextTCB != pxFirstTCB );
   3176          		}
   3177          		else
   3178          		{
   3179          			mtCOVERAGE_TEST_MARKER();
   3180          		}
   3181          
   3182          		return uxTask;
   3183          	}
   3184          
   3185          #endif /* configUSE_TRACE_FACILITY */
   3186          /*-----------------------------------------------------------*/
   3187          
   3188          #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
   3189          
   3190          	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
   3191          	{
   3192          	uint32_t ulCount = 0U;
   3193          
   3194          		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
   3195          		{
   3196          			pucStackByte -= portSTACK_GROWTH;
   3197          			ulCount++;
   3198          		}
   3199          
   3200          		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
   3201          
   3202          		return ( uint16_t ) ulCount;
   3203          	}
   3204          
   3205          #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
   3206          /*-----------------------------------------------------------*/
   3207          
   3208          #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
   3209          
   3210          	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
   3211          	{
   3212          	TCB_t *pxTCB;
   3213          	uint8_t *pucEndOfStack;
   3214          	UBaseType_t uxReturn;
   3215          
   3216          		pxTCB = prvGetTCBFromHandle( xTask );
   3217          
   3218          		#if portSTACK_GROWTH < 0
   3219          		{
   3220          			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
   3221          		}
   3222          		#else
   3223          		{
   3224          			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
   3225          		}
   3226          		#endif
   3227          
   3228          		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
   3229          
   3230          		return uxReturn;
   3231          	}
   3232          
   3233          #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
   3234          /*-----------------------------------------------------------*/
   3235          
   3236          #if ( INCLUDE_vTaskDelete == 1 )
   3237          
   3238          	static void prvDeleteTCB( TCB_t *pxTCB )
   3239          	{
   3240          		/* This call is required specifically for the TriCore port.  It must be
   3241          		above the vPortFree() calls.  The call is also used by ports/demos that
   3242          		want to allocate and clean RAM statically. */
   3243          		portCLEAN_UP_TCB( pxTCB );
   3244          
   3245          		/* Free up the memory allocated by the scheduler for the task.  It is up
   3246          		to the task to free any memory allocated at the application level. */
   3247          		#if ( configUSE_NEWLIB_REENTRANT == 1 )
   3248          		{
   3249          			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
   3250          		}
   3251          		#endif /* configUSE_NEWLIB_REENTRANT */
   3252          
   3253          		#if( portUSING_MPU_WRAPPERS == 1 )
   3254          		{
   3255          			/* Only free the stack if it was allocated dynamically in the first
   3256          			place. */
   3257          			if( pxTCB->xUsingStaticallyAllocatedStack == pdFALSE )
   3258          			{
   3259          				vPortFreeAligned( pxTCB->pxStack );
   3260          			}
   3261          		}
   3262          		#else
   3263          		{
   3264          			vPortFreeAligned( pxTCB->pxStack );
   3265          		}
   3266          		#endif
   3267          
   3268          		vPortFree( pxTCB );
   3269          	}
   3270          
   3271          #endif /* INCLUDE_vTaskDelete */
   3272          /*-----------------------------------------------------------*/
   3273          
   3274          static void prvResetNextTaskUnblockTime( void )
   3275          {
   3276          TCB_t *pxTCB;
   3277          
   3278          	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   3279          	{
   3280          		/* The new current delayed list is empty.  Set
   3281          		xNextTaskUnblockTime to the maximum possible value so it is
   3282          		extremely unlikely that the
   3283          		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
   3284          		there is an item in the delayed list. */
   3285          		xNextTaskUnblockTime = portMAX_DELAY;
   3286          	}
   3287          	else
   3288          	{
   3289          		/* The new current delayed list is not empty, get the value of
   3290          		the item at the head of the delayed list.  This is the time at
   3291          		which the task at the head of the delayed list should be removed
   3292          		from the Blocked state. */
   3293          		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   3294          		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
   3295          	}
   3296          }
   3297          /*-----------------------------------------------------------*/
   3298          
   3299          #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
   3300          
   3301          	TaskHandle_t xTaskGetCurrentTaskHandle( void )
   3302          	{
   3303          	TaskHandle_t xReturn;
   3304          
   3305          		/* A critical section is not required as this is not called from
   3306          		an interrupt and the current TCB will always be the same for any
   3307          		individual execution thread. */
   3308          		xReturn = pxCurrentTCB;
   3309          
   3310          		return xReturn;
   3311          	}
   3312          
   3313          #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
   3314          /*-----------------------------------------------------------*/
   3315          
   3316          #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
   3317          
   3318          	BaseType_t xTaskGetSchedulerState( void )
   3319          	{
   3320          	BaseType_t xReturn;
   3321          
   3322          		if( xSchedulerRunning == pdFALSE )
   3323          		{
   3324          			xReturn = taskSCHEDULER_NOT_STARTED;
   3325          		}
   3326          		else
   3327          		{
   3328          			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   3329          			{
   3330          				xReturn = taskSCHEDULER_RUNNING;
   3331          			}
   3332          			else
   3333          			{
   3334          				xReturn = taskSCHEDULER_SUSPENDED;
   3335          			}
   3336          		}
   3337          
   3338          		return xReturn;
   3339          	}
   3340          
   3341          #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
   3342          /*-----------------------------------------------------------*/
   3343          
   3344          #if ( configUSE_MUTEXES == 1 )
   3345          
   3346          	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
   3347          	{
   3348          	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
   3349          
   3350          		/* If the mutex was given back by an interrupt while the queue was
   3351          		locked then the mutex holder might now be NULL. */
   3352          		if( pxMutexHolder != NULL )
   3353          		{
   3354          			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
   3355          			{
   3356          				/* Adjust the mutex holder state to account for its new
   3357          				priority.  Only reset the event list item value if the value is
   3358          				not	being used for anything else. */
   3359          				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   3360          				{
   3361          					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   3362          				}
   3363          				else
   3364          				{
   3365          					mtCOVERAGE_TEST_MARKER();
   3366          				}
   3367          
   3368          				/* If the task being modified is in the ready state it will need to
   3369          				be moved into a new list. */
   3370          				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
   3371          				{
   3372          					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   3373          					{
   3374          						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   3375          					}
   3376          					else
   3377          					{
   3378          						mtCOVERAGE_TEST_MARKER();
   3379          					}
   3380          
   3381          					/* Inherit the priority before being moved into the new list. */
   3382          					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   3383          					prvAddTaskToReadyList( pxTCB );
   3384          				}
   3385          				else
   3386          				{
   3387          					/* Just inherit the priority. */
   3388          					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   3389          				}
   3390          
   3391          				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
   3392          			}
   3393          			else
   3394          			{
   3395          				mtCOVERAGE_TEST_MARKER();
   3396          			}
   3397          		}
   3398          		else
   3399          		{
   3400          			mtCOVERAGE_TEST_MARKER();
   3401          		}
   3402          	}
   3403          
   3404          #endif /* configUSE_MUTEXES */
   3405          /*-----------------------------------------------------------*/
   3406          
   3407          #if ( configUSE_MUTEXES == 1 )
   3408          
   3409          	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
   3410          	{
   3411          	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
   3412          	BaseType_t xReturn = pdFALSE;
   3413          
   3414          		if( pxMutexHolder != NULL )
   3415          		{
   3416          			configASSERT( pxTCB->uxMutexesHeld );
   3417          			( pxTCB->uxMutexesHeld )--;
   3418          
   3419          			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   3420          			{
   3421          				/* Only disinherit if no other mutexes are held. */
   3422          				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
   3423          				{
   3424          					/* A task can only have an inhertied priority if it holds
   3425          					the mutex.  If the mutex is held by a task then it cannot be
   3426          					given from an interrupt, and if a mutex is given by the
   3427          					holding	task then it must be the running state task.  Remove
   3428          					the	holding task from the ready	list. */
   3429          					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   3430          					{
   3431          						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   3432          					}
   3433          					else
   3434          					{
   3435          						mtCOVERAGE_TEST_MARKER();
   3436          					}
   3437          
   3438          					/* Disinherit the priority before adding the task into the
   3439          					new	ready list. */
   3440          					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
   3441          					pxTCB->uxPriority = pxTCB->uxBasePriority;
   3442          
   3443          					/* Reset the event list item value.  It cannot be in use for
   3444          					any other purpose if this task is running, and it must be
   3445          					running to give back the mutex. */
   3446          					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   3447          					prvAddTaskToReadyList( pxTCB );
   3448          
   3449          					/* Return true to indicate that a context switch is required.
   3450          					This is only actually required in the corner case whereby
   3451          					multiple mutexes were held and the mutexes were given back
   3452          					in an order different to that in which they were taken.
   3453          					If a context switch did not occur when the first mutex was
   3454          					returned, even if a task was waiting on it, then a context
   3455          					switch should occur when the last mutex is returned whether
   3456          					a task is waiting on it or not. */
   3457          					xReturn = pdTRUE;
   3458          				}
   3459          				else
   3460          				{
   3461          					mtCOVERAGE_TEST_MARKER();
   3462          				}
   3463          			}
   3464          			else
   3465          			{
   3466          				mtCOVERAGE_TEST_MARKER();
   3467          			}
   3468          		}
   3469          		else
   3470          		{
   3471          			mtCOVERAGE_TEST_MARKER();
   3472          		}
   3473          
   3474          		return xReturn;
   3475          	}
   3476          
   3477          #endif /* configUSE_MUTEXES */
   3478          /*-----------------------------------------------------------*/
   3479          
   3480          #if ( portCRITICAL_NESTING_IN_TCB == 1 )
   3481          
   3482          	void vTaskEnterCritical( void )
   3483          	{
   3484          		portDISABLE_INTERRUPTS();
   3485          
   3486          		if( xSchedulerRunning != pdFALSE )
   3487          		{
   3488          			( pxCurrentTCB->uxCriticalNesting )++;
   3489          
   3490          			/* This is not the interrupt safe version of the enter critical
   3491          			function so	assert() if it is being called from an interrupt
   3492          			context.  Only API functions that end in "FromISR" can be used in an
   3493          			interrupt.  Only assert if the critical nesting count is 1 to
   3494          			protect against recursive calls if the assert function also uses a
   3495          			critical section. */
   3496          			if( pxCurrentTCB->uxCriticalNesting == 1 )
   3497          			{
   3498          				portASSERT_IF_IN_ISR();
   3499          			}
   3500          
   3501          		}
   3502          		else
   3503          		{
   3504          			mtCOVERAGE_TEST_MARKER();
   3505          		}
   3506          	}
   3507          
   3508          #endif /* portCRITICAL_NESTING_IN_TCB */
   3509          /*-----------------------------------------------------------*/
   3510          
   3511          #if ( portCRITICAL_NESTING_IN_TCB == 1 )
   3512          
   3513          	void vTaskExitCritical( void )
   3514          	{
   3515          		if( xSchedulerRunning != pdFALSE )
   3516          		{
   3517          			if( pxCurrentTCB->uxCriticalNesting > 0U )
   3518          			{
   3519          				( pxCurrentTCB->uxCriticalNesting )--;
   3520          
   3521          				if( pxCurrentTCB->uxCriticalNesting == 0U )
   3522          				{
   3523          					portENABLE_INTERRUPTS();
   3524          				}
   3525          				else
   3526          				{
   3527          					mtCOVERAGE_TEST_MARKER();
   3528          				}
   3529          			}
   3530          			else
   3531          			{
   3532          				mtCOVERAGE_TEST_MARKER();
   3533          			}
   3534          		}
   3535          		else
   3536          		{
   3537          			mtCOVERAGE_TEST_MARKER();
   3538          		}
   3539          	}
   3540          
   3541          #endif /* portCRITICAL_NESTING_IN_TCB */
   3542          /*-----------------------------------------------------------*/
   3543          
   3544          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
   3545          
   3546          	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
   3547          	{
   3548          	BaseType_t x;
   3549          
   3550          		/* Start by copying the entire string. */
   3551          		strcpy( pcBuffer, pcTaskName );
   3552          
   3553          		/* Pad the end of the string with spaces to ensure columns line up when
   3554          		printed out. */
   3555          		for( x = strlen( pcBuffer ); x < ( configMAX_TASK_NAME_LEN - 1 ); x++ )
   3556          		{
   3557          			pcBuffer[ x ] = ' ';
   3558          		}
   3559          
   3560          		/* Terminate. */
   3561          		pcBuffer[ x ] = 0x00;
   3562          
   3563          		/* Return the new end of string. */
   3564          		return &( pcBuffer[ x ] );
   3565          	}
   3566          
   3567          #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
   3568          /*-----------------------------------------------------------*/
   3569          
   3570          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
   3571          
   3572          	void vTaskList( char * pcWriteBuffer, size_t bufSize)
   3573          	{
   3574          	TaskStatus_t *pxTaskStatusArray;
   3575          	volatile UBaseType_t uxArraySize, x;
   3576          	char cStatus;
   3577          
   3578          		/*
   3579          		 * PLEASE NOTE:
   3580          		 *
   3581          		 * This function is provided for convenience only, and is used by many
   3582          		 * of the demo applications.  Do not consider it to be part of the
   3583          		 * scheduler.
   3584          		 *
   3585          		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
   3586          		 * uxTaskGetSystemState() output into a human readable table that
   3587          		 * displays task names, states and stack usage.
   3588          		 *
   3589          		 * vTaskList() has a dependency on the sprintf() C library function that
   3590          		 * might bloat the code size, use a lot of stack, and provide different
   3591          		 * results on different platforms.  An alternative, tiny, third party,
   3592          		 * and limited functionality implementation of sprintf() is provided in
   3593          		 * many of the FreeRTOS/Demo sub-directories in a file called
   3594          		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
   3595          		 * snprintf() implementation!).
   3596          		 *
   3597          		 * It is recommended that production systems call uxTaskGetSystemState()
   3598          		 * directly to get access to raw stats data, rather than indirectly
   3599          		 * through a call to vTaskList().
   3600          		 */
   3601          
   3602          
   3603          		/* Make sure the write buffer does not contain a string. */
   3604          		*pcWriteBuffer = 0x00;
   3605          
   3606          		/* Take a snapshot of the number of tasks in case it changes while this
   3607          		function is executing. */
   3608          		uxArraySize = uxCurrentNumberOfTasks;
   3609          
   3610          		/* Allocate an array index for each task. */
   3611          		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
   3612          
   3613          		if( pxTaskStatusArray != NULL )
   3614          		{
   3615          			/* Generate the (binary) data. */
   3616          			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
   3617          
   3618          			/* Create a human readable table from the binary data. */
   3619          			for( x = 0; x < uxArraySize; x++ )
   3620          			{
   3621          				switch( pxTaskStatusArray[ x ].eCurrentState )
   3622          				{
   3623          					case eReady:		cStatus = tskREADY_CHAR;
   3624          										break;
   3625          
   3626          					case eBlocked:		cStatus = tskBLOCKED_CHAR;
   3627          										break;
   3628          
   3629          					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
   3630          										break;
   3631          
   3632          					case eDeleted:		cStatus = tskDELETED_CHAR;
   3633          										break;
   3634          
   3635          					default:			/* Should not get here, but it is included
   3636          										to prevent static checking errors. */
   3637          										cStatus = 0x00;
   3638          										break;
   3639          				}
   3640          
   3641          				/* Write the task name to the string, padding with spaces so it
   3642          				can be printed in tabular form more easily. */
   3643          				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
   3644          
   3645          				/* Write the rest of the string. */
   3646          #if 0
   3647          				sprintf( ( char * ) pcWriteBuffer, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxTaskStatusArray[ x ].pcTaskName, cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
   3648          #else /* << EST */
   3649          	      Utility_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)pxTaskStatusArray[ x ].pcTaskName);
   3650          	      Utility_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)"\t\t");
   3651          	      Utility_chcat((uint8_t*)pcWriteBuffer, bufSize, (unsigned char)cStatus);
   3652          	      Utility_chcat((uint8_t*)pcWriteBuffer, bufSize, (unsigned char)'\t');
   3653          	      Utility_strcatNum32u((uint8_t*)pcWriteBuffer, bufSize, pxTaskStatusArray[ x ].uxCurrentPriority);
   3654          	      Utility_chcat((uint8_t*)pcWriteBuffer, bufSize, (unsigned char)'\t');
   3655          	      Utility_strcatNum32u((uint8_t*)pcWriteBuffer, bufSize, pxTaskStatusArray[ x ].usStackHighWaterMark);
   3656          	      Utility_chcat((uint8_t*)pcWriteBuffer, bufSize, (unsigned char)'\t');
   3657          	      Utility_strcatNum32u((uint8_t*)pcWriteBuffer, bufSize, pxTaskStatusArray[ x ].xTaskNumber);
   3658          	      Utility_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)"\r\n");
   3659          #endif
   3660          				pcWriteBuffer += strlen( pcWriteBuffer );
   3661          			}
   3662          
   3663          			/* Free the array again. */
   3664          			vPortFree( pxTaskStatusArray );
   3665          		}
   3666          		else
   3667          		{
   3668          			mtCOVERAGE_TEST_MARKER();
   3669          		}
   3670          	}
   3671          
   3672          #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
   3673          /*----------------------------------------------------------*/
   3674          
   3675          #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
   3676          
   3677          	void vTaskGetRunTimeStats( char *pcWriteBuffer, size_t bufSize)
   3678          	{
   3679          	TaskStatus_t *pxTaskStatusArray;
   3680          	volatile UBaseType_t uxArraySize, x;
   3681          	uint32_t ulTotalTime, ulStatsAsPercentage;
   3682          
   3683          		#if( configUSE_TRACE_FACILITY != 1 )
   3684          		{
   3685          			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTimeStats().
   3686          		}
   3687          		#endif
   3688          
   3689          		/*
   3690          		 * PLEASE NOTE:
   3691          		 *
   3692          		 * This function is provided for convenience only, and is used by many
   3693          		 * of the demo applications.  Do not consider it to be part of the
   3694          		 * scheduler.
   3695          		 *
   3696          		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
   3697          		 * of the uxTaskGetSystemState() output into a human readable table that
   3698          		 * displays the amount of time each task has spent in the Running state
   3699          		 * in both absolute and percentage terms.
   3700          		 *
   3701          		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
   3702          		 * function that might bloat the code size, use a lot of stack, and
   3703          		 * provide different results on different platforms.  An alternative,
   3704          		 * tiny, third party, and limited functionality implementation of
   3705          		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
   3706          		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
   3707          		 * a full snprintf() implementation!).
   3708          		 *
   3709          		 * It is recommended that production systems call uxTaskGetSystemState()
   3710          		 * directly to get access to raw stats data, rather than indirectly
   3711          		 * through a call to vTaskGetRunTimeStats().
   3712          		 */
   3713          
   3714          		/* Make sure the write buffer does not contain a string. */
   3715          		*pcWriteBuffer = 0x00;
   3716          
   3717          		/* Take a snapshot of the number of tasks in case it changes while this
   3718          		function is executing. */
   3719          		uxArraySize = uxCurrentNumberOfTasks;
   3720          
   3721          		/* Allocate an array index for each task. */
   3722          		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
   3723          
   3724          		if( pxTaskStatusArray != NULL )
   3725          		{
   3726          			/* Generate the (binary) data. */
   3727          			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
   3728          
   3729          			/* For percentage calculations. */
   3730          			ulTotalTime /= 100UL;
   3731          
   3732          			/* Avoid divide by zero errors. */
   3733          			if( ulTotalTime > 0 )
   3734          			{
   3735          				/* Create a human readable table from the binary data. */
   3736          				for( x = 0; x < uxArraySize; x++ )
   3737          				{
   3738          					/* What percentage of the total run time has the task used?
   3739          					This will always be rounded down to the nearest integer.
   3740          					ulTotalRunTimeDiv100 has already been divided by 100. */
   3741          					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
   3742          
   3743          					/* Write the task name to the string, padding with
   3744          					spaces so it can be printed in tabular form more
   3745          					easily. */
   3746          					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
   3747          
   3748          					if( ulStatsAsPercentage > 0UL )
   3749          					{
   3750          						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
   3751          						{
   3752          						  sprintf( ( char * ) pcWriteBuffer, ( char * ) "%s\t\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
   3753          						}
   3754          						#else
   3755          						{
   3756          							/* sizeof( int ) == sizeof( long ) so a smaller
   3757          							printf() library can be used. */
   3758          #if 0
   3759          							sprintf( ( char * ) pcWriteBuffer, ( char * ) "%s\t\t%u\t\t%u%%\r\n", pxTaskStatusArray[ x ].pcTaskName, ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
   3760          #else /* << EST */
   3761                        Utility_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)pxTaskStatusArray[ x ].pcTaskName);
   3762                        Utility_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)"\t\t");
   3763                        Utility_strcatNum32u((uint8_t*)pcWriteBuffer, bufSize, pxTaskStatusArray[ x ].ulRunTimeCounter);
   3764                        Utility_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)"\t\t");
   3765                        Utility_strcatNum32u((uint8_t*)pcWriteBuffer, bufSize, ulStatsAsPercentage);
   3766                        Utility_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)"%\r\n");
   3767          #endif
   3768          						}
   3769          						#endif
   3770          					}
   3771          					else
   3772          					{
   3773          						/* If the percentage is zero here then the task has
   3774          						consumed less than 1% of the total run time. */
   3775          						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
   3776          						{
   3777          							sprintf( ( char * ) pcWriteBuffer, ( char * ) "%s\t\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );
   3778          						}
   3779          						#else
   3780          						{
   3781          							/* sizeof( int ) == sizeof( long ) so a smaller
   3782          							printf() library can be used. */
   3783          #if 0
   3784                        sprintf( ( char * ) pcWriteBuffer, ( char * ) "%s\t\t%u\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter );
   3785          #else /* << EST */
   3786                        Utility_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)pxTaskStatusArray[ x ].pcTaskName);
   3787                        Utility_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)"\t\t");
   3788                        Utility_strcatNum32u((uint8_t*)pcWriteBuffer, bufSize, pxTaskStatusArray[ x ].ulRunTimeCounter);
   3789                        Utility_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)"\t\t<1%\r\n");
   3790          #endif
   3791          						}
   3792          						#endif
   3793          					}
   3794          
   3795          					pcWriteBuffer += strlen( pcWriteBuffer );
   3796          				}
   3797          			}
   3798          			else
   3799          			{
   3800          				mtCOVERAGE_TEST_MARKER();
   3801          			}
   3802          
   3803          			/* Free the array again. */
   3804          			vPortFree( pxTaskStatusArray );
   3805          		}
   3806          		else
   3807          		{
   3808          			mtCOVERAGE_TEST_MARKER();
   3809          		}
   3810          	}
   3811          
   3812          #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
   3813          /*-----------------------------------------------------------*/
   3814          
   3815          TickType_t uxTaskResetEventItemValue( void )
   3816          {
   3817          TickType_t uxReturn;
   3818          
   3819          	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
   3820          
   3821          	/* Reset the event list item to its normal value - so it can be used with
   3822          	queues and semaphores. */
   3823          	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   3824          
   3825          	return uxReturn;
   3826          }
   3827          /*-----------------------------------------------------------*/
   3828          
   3829          #if ( configUSE_MUTEXES == 1 )
   3830          
   3831          	void *pvTaskIncrementMutexHeldCount( void )
   3832          	{
   3833          		/* If xSemaphoreCreateMutex() is called before any tasks have been created
   3834          		then pxCurrentTCB will be NULL. */
   3835          		if( pxCurrentTCB != NULL )
   3836          		{
   3837          			( pxCurrentTCB->uxMutexesHeld )++;
   3838          		}
   3839          
   3840          		return pxCurrentTCB;
   3841          	}
   3842          
   3843          #endif /* configUSE_MUTEXES */
   3844          /*-----------------------------------------------------------*/
   3845          
   3846          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   3847          
   3848          	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
   3849          	{
   3850          	TickType_t xTimeToWake;
   3851          	uint32_t ulReturn;
   3852          
   3853          		taskENTER_CRITICAL();
   3854          		{
   3855          			/* Only block if the notification count is not already non-zero. */
   3856          			if( pxCurrentTCB->ulNotifiedValue == 0UL )
   3857          			{
   3858          				/* Mark this task as waiting for a notification. */
   3859          				pxCurrentTCB->eNotifyState = eWaitingNotification;
   3860          
   3861          				if( xTicksToWait > ( TickType_t ) 0 )
   3862          				{
   3863          					/* The task is going to block.  First it must be removed
   3864          					from the ready list. */
   3865          					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   3866          					{
   3867          						/* The current task must be in a ready list, so there is
   3868          						no need to check, and the port reset macro can be called
   3869          						directly. */
   3870          						portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   3871          					}
   3872          					else
   3873          					{
   3874          						mtCOVERAGE_TEST_MARKER();
   3875          					}
   3876          
   3877          					#if ( INCLUDE_vTaskSuspend == 1 )
   3878          					{
   3879          						if( xTicksToWait == portMAX_DELAY )
   3880          						{
   3881          							/* Add the task to the suspended task list instead
   3882          							of a delayed task list to ensure the task is not
   3883          							woken by a timing event.  It will block
   3884          							indefinitely. */
   3885          							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   3886          						}
   3887          						else
   3888          						{
   3889          							/* Calculate the time at which the task should be
   3890          							woken if no notification events occur.  This may
   3891          							overflow but this doesn't matter, the scheduler will
   3892          							handle it. */
   3893          							xTimeToWake = xTickCount + xTicksToWait;
   3894          							prvAddCurrentTaskToDelayedList( xTimeToWake );
   3895          						}
   3896          					}
   3897          					#else /* INCLUDE_vTaskSuspend */
   3898          					{
   3899          							/* Calculate the time at which the task should be
   3900          							woken if the event does not occur.  This may
   3901          							overflow but this doesn't matter, the scheduler will
   3902          							handle it. */
   3903          							xTimeToWake = xTickCount + xTicksToWait;
   3904          							prvAddCurrentTaskToDelayedList( xTimeToWake );
   3905          					}
   3906          					#endif /* INCLUDE_vTaskSuspend */
   3907          
   3908          					/* All ports are written to allow a yield in a critical
   3909          					section (some will yield immediately, others wait until the
   3910          					critical section exits) - but it is not something that
   3911          					application code should ever do. */
   3912          					portYIELD_WITHIN_API();
   3913          				}
   3914          				else
   3915          				{
   3916          					mtCOVERAGE_TEST_MARKER();
   3917          				}
   3918          			}
   3919          			else
   3920          			{
   3921          				mtCOVERAGE_TEST_MARKER();
   3922          			}
   3923          		}
   3924          		taskEXIT_CRITICAL();
   3925          
   3926          		taskENTER_CRITICAL();
   3927          		{
   3928          			ulReturn = pxCurrentTCB->ulNotifiedValue;
   3929          
   3930          			if( ulReturn != 0UL )
   3931          			{
   3932          				if( xClearCountOnExit != pdFALSE )
   3933          				{
   3934          					pxCurrentTCB->ulNotifiedValue = 0UL;
   3935          				}
   3936          				else
   3937          				{
   3938          					( pxCurrentTCB->ulNotifiedValue )--;
   3939          				}
   3940          			}
   3941          			else
   3942          			{
   3943          				mtCOVERAGE_TEST_MARKER();
   3944          			}
   3945          
   3946          			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
   3947          		}
   3948          		taskEXIT_CRITICAL();
   3949          
   3950          		return ulReturn;
   3951          	}
   3952          
   3953          #endif /* configUSE_TASK_NOTIFICATIONS */
   3954          /*-----------------------------------------------------------*/
   3955          
   3956          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   3957          
   3958          	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
   3959          	{
   3960          	TickType_t xTimeToWake;
   3961          	BaseType_t xReturn;
   3962          
   3963          		taskENTER_CRITICAL();
   3964          		{
   3965          			/* Only block if a notification is not already pending. */
   3966          			if( pxCurrentTCB->eNotifyState != eNotified )
   3967          			{
   3968          				/* Clear bits in the task's notification value as bits may get
   3969          				set	by the notifying task or interrupt.  This can be used to
   3970          				clear the value to zero. */
   3971          				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
   3972          
   3973          				/* Mark this task as waiting for a notification. */
   3974          				pxCurrentTCB->eNotifyState = eWaitingNotification;
   3975          
   3976          				if( xTicksToWait > ( TickType_t ) 0 )
   3977          				{
   3978          					/* The task is going to block.  First it must be removed
   3979          					from the	ready list. */
   3980          					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   3981          					{
   3982          						/* The current task must be in a ready list, so there is
   3983          						no need to check, and the port reset macro can be called
   3984          						directly. */
   3985          						portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   3986          					}
   3987          					else
   3988          					{
   3989          						mtCOVERAGE_TEST_MARKER();
   3990          					}
   3991          
   3992          					#if ( INCLUDE_vTaskSuspend == 1 )
   3993          					{
   3994          						if( xTicksToWait == portMAX_DELAY )
   3995          						{
   3996          							/* Add the task to the suspended task list instead
   3997          							of a delayed task list to ensure the task is not
   3998          							woken by a timing event.  It will block
   3999          							indefinitely. */
   4000          							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   4001          						}
   4002          						else
   4003          						{
   4004          							/* Calculate the time at which the task should be
   4005          							woken if no notification events occur.  This may
   4006          							overflow but this doesn't matter, the scheduler will
   4007          							handle it. */
   4008          							xTimeToWake = xTickCount + xTicksToWait;
   4009          							prvAddCurrentTaskToDelayedList( xTimeToWake );
   4010          						}
   4011          					}
   4012          					#else /* INCLUDE_vTaskSuspend */
   4013          					{
   4014          							/* Calculate the time at which the task should be
   4015          							woken if the event does not occur.  This may
   4016          							overflow but this doesn't matter, the scheduler will
   4017          							handle it. */
   4018          							xTimeToWake = xTickCount + xTicksToWait;
   4019          							prvAddCurrentTaskToDelayedList( xTimeToWake );
   4020          					}
   4021          					#endif /* INCLUDE_vTaskSuspend */
   4022          
   4023          					/* All ports are written to allow a yield in a critical
   4024          					section (some will yield immediately, others wait until the
   4025          					critical section exits) - but it is not something that
   4026          					application code should ever do. */
   4027          					portYIELD_WITHIN_API();
   4028          				}
   4029          				else
   4030          				{
   4031          					mtCOVERAGE_TEST_MARKER();
   4032          				}
   4033          			}
   4034          			else
   4035          			{
   4036          				mtCOVERAGE_TEST_MARKER();
   4037          			}
   4038          		}
   4039          		taskEXIT_CRITICAL();
   4040          
   4041          		taskENTER_CRITICAL();
   4042          		{
   4043          			if( pulNotificationValue != NULL )
   4044          			{
   4045          				/* Output the current notification value, which may or may not
   4046          				have changed. */
   4047          				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
   4048          			}
   4049          
   4050          			/* If eNotifyValue is set then either the task never entered the
   4051          			blocked state (because a notification was already pending) or the
   4052          			task unblocked because of a notification.  Otherwise the task
   4053          			unblocked because of a timeout. */
   4054          			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
   4055          			{
   4056          				/* A notification was not received. */
   4057          				xReturn = pdFALSE;
   4058          			}
   4059          			else
   4060          			{
   4061          				/* A notification was already pending or a notification was
   4062          				received while the task was waiting. */
   4063          				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
   4064          				xReturn = pdTRUE;
   4065          			}
   4066          
   4067          			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
   4068          		}
   4069          		taskEXIT_CRITICAL();
   4070          
   4071          		return xReturn;
   4072          	}
   4073          
   4074          #endif /* configUSE_TASK_NOTIFICATIONS */
   4075          /*-----------------------------------------------------------*/
   4076          
   4077          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4078          
   4079          	BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction )
   4080          	{
   4081          	TCB_t * pxTCB;
   4082          	eNotifyValue eOriginalNotifyState;
   4083          	BaseType_t xReturn = pdPASS;
   4084          
   4085          		configASSERT( xTaskToNotify );
   4086          		pxTCB = ( TCB_t * ) xTaskToNotify;
   4087          
   4088          		taskENTER_CRITICAL();
   4089          		{
   4090          			eOriginalNotifyState = pxTCB->eNotifyState;
   4091          
   4092          			pxTCB->eNotifyState = eNotified;
   4093          
   4094          			switch( eAction )
   4095          			{
   4096          				case eSetBits	:
   4097          					pxTCB->ulNotifiedValue |= ulValue;
   4098          					break;
   4099          
   4100          				case eIncrement	:
   4101          					( pxTCB->ulNotifiedValue )++;
   4102          					break;
   4103          
   4104          				case eSetValueWithOverwrite	:
   4105          					pxTCB->ulNotifiedValue = ulValue;
   4106          					break;
   4107          
   4108          				case eSetValueWithoutOverwrite :
   4109          					if( eOriginalNotifyState != eNotified )
   4110          					{
   4111          						pxTCB->ulNotifiedValue = ulValue;
   4112          					}
   4113          					else
   4114          					{
   4115          						/* The value could not be written to the task. */
   4116          						xReturn = pdFAIL;
   4117          					}
   4118          					break;
   4119          
   4120          				case eNoAction:
   4121          					/* The task is being notified without its notify value being
   4122          					updated. */
   4123          					break;
   4124          			}
   4125          
   4126          
   4127          			/* If the task is in the blocked state specifically to wait for a
   4128          			notification then unblock it now. */
   4129          			if( eOriginalNotifyState == eWaitingNotification )
   4130          			{
   4131          				( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   4132          				prvAddTaskToReadyList( pxTCB );
   4133          
   4134          				/* The task should not have been on an event list. */
   4135          				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   4136          
   4137          				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   4138          				{
   4139          					/* The notified task has a priority above the currently
   4140          					executing task so a yield is required. */
   4141          					portYIELD_WITHIN_API();
   4142          				}
   4143          				else
   4144          				{
   4145          					mtCOVERAGE_TEST_MARKER();
   4146          				}
   4147          			}
   4148          			else
   4149          			{
   4150          				mtCOVERAGE_TEST_MARKER();
   4151          			}
   4152          		}
   4153          		taskEXIT_CRITICAL();
   4154          
   4155          		return xReturn;
   4156          	}
   4157          
   4158          #endif /* configUSE_TASK_NOTIFICATIONS */
   4159          /*-----------------------------------------------------------*/
   4160          
   4161          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4162          
   4163          	BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken )
   4164          	{
   4165          	TCB_t * pxTCB;
   4166          	eNotifyValue eOriginalNotifyState;
   4167          	BaseType_t xReturn = pdPASS;
   4168          	UBaseType_t uxSavedInterruptStatus;
   4169          
   4170          		configASSERT( xTaskToNotify );
   4171          
   4172          		/* RTOS ports that support interrupt nesting have the concept of a
   4173          		maximum	system call (or maximum API call) interrupt priority.
   4174          		Interrupts that are	above the maximum system call priority are keep
   4175          		permanently enabled, even when the RTOS kernel is in a critical section,
   4176          		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   4177          		is defined in FreeRTOSConfig.h then
   4178          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   4179          		failure if a FreeRTOS API function is called from an interrupt that has
   4180          		been assigned a priority above the configured maximum system call
   4181          		priority.  Only FreeRTOS functions that end in FromISR can be called
   4182          		from interrupts	that have been assigned a priority at or (logically)
   4183          		below the maximum system call interrupt priority.  FreeRTOS maintains a
   4184          		separate interrupt safe API to ensure interrupt entry is as fast and as
   4185          		simple as possible.  More information (albeit Cortex-M specific) is
   4186          		provided on the following link:
   4187          		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   4188          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   4189          
   4190          		pxTCB = ( TCB_t * ) xTaskToNotify;
   4191          
   4192          		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   4193          		{
   4194          			eOriginalNotifyState = pxTCB->eNotifyState;
   4195          
   4196          			pxTCB->eNotifyState = eNotified;
   4197          
   4198          			switch( eAction )
   4199          			{
   4200          				case eSetBits	:
   4201          					pxTCB->ulNotifiedValue |= ulValue;
   4202          					break;
   4203          
   4204          				case eIncrement	:
   4205          					( pxTCB->ulNotifiedValue )++;
   4206          					break;
   4207          
   4208          				case eSetValueWithOverwrite	:
   4209          					pxTCB->ulNotifiedValue = ulValue;
   4210          					break;
   4211          
   4212          				case eSetValueWithoutOverwrite :
   4213          					if( eOriginalNotifyState != eNotified )
   4214          					{
   4215          						pxTCB->ulNotifiedValue = ulValue;
   4216          					}
   4217          					else
   4218          					{
   4219          						/* The value could not be written to the task. */
   4220          						xReturn = pdFAIL;
   4221          					}
   4222          					break;
   4223          
   4224          				case eNoAction :
   4225          					/* The task is being notified without its notify value being
   4226          					updated. */
   4227          					break;
   4228          			}
   4229          
   4230          
   4231          			/* If the task is in the blocked state specifically to wait for a
   4232          			notification then unblock it now. */
   4233          			if( eOriginalNotifyState == eWaitingNotification )
   4234          			{
   4235          				/* The task should not have been on an event list. */
   4236          				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   4237          
   4238          				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   4239          				{
   4240          					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   4241          					prvAddTaskToReadyList( pxTCB );
   4242          				}
   4243          				else
   4244          				{
   4245          					/* The delayed and ready lists cannot be accessed, so hold
   4246          					this task pending until the scheduler is resumed. */
   4247          					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   4248          				}
   4249          
   4250          				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   4251          				{
   4252          					/* The notified task has a priority above the currently
   4253          					executing task so a yield is required. */
   4254          					if( pxHigherPriorityTaskWoken != NULL )
   4255          					{
   4256          						*pxHigherPriorityTaskWoken = pdTRUE;
   4257          					}
   4258          				}
   4259          				else
   4260          				{
   4261          					mtCOVERAGE_TEST_MARKER();
   4262          				}
   4263          			}
   4264          		}
   4265          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   4266          
   4267          		return xReturn;
   4268          	}
   4269          
   4270          #endif /* configUSE_TASK_NOTIFICATIONS */
   4271          /*-----------------------------------------------------------*/
   4272          
   4273          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4274          
   4275          	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
   4276          	{
   4277          	TCB_t * pxTCB;
   4278          	eNotifyValue eOriginalNotifyState;
   4279          	UBaseType_t uxSavedInterruptStatus;
   4280          
   4281          		configASSERT( xTaskToNotify );
   4282          
   4283          		/* RTOS ports that support interrupt nesting have the concept of a
   4284          		maximum	system call (or maximum API call) interrupt priority.
   4285          		Interrupts that are	above the maximum system call priority are keep
   4286          		permanently enabled, even when the RTOS kernel is in a critical section,
   4287          		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   4288          		is defined in FreeRTOSConfig.h then
   4289          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   4290          		failure if a FreeRTOS API function is called from an interrupt that has
   4291          		been assigned a priority above the configured maximum system call
   4292          		priority.  Only FreeRTOS functions that end in FromISR can be called
   4293          		from interrupts	that have been assigned a priority at or (logically)
   4294          		below the maximum system call interrupt priority.  FreeRTOS maintains a
   4295          		separate interrupt safe API to ensure interrupt entry is as fast and as
   4296          		simple as possible.  More information (albeit Cortex-M specific) is
   4297          		provided on the following link:
   4298          		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   4299          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   4300          
   4301          		pxTCB = ( TCB_t * ) xTaskToNotify;
   4302          
   4303          		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   4304          		{
   4305          			eOriginalNotifyState = pxTCB->eNotifyState;
   4306          			pxTCB->eNotifyState = eNotified;
   4307          
   4308          			/* 'Giving' is equivalent to incrementing a count in a counting
   4309          			semaphore. */
   4310          			( pxTCB->ulNotifiedValue )++;
   4311          
   4312          			/* If the task is in the blocked state specifically to wait for a
   4313          			notification then unblock it now. */
   4314          			if( eOriginalNotifyState == eWaitingNotification )
   4315          			{
   4316          				/* The task should not have been on an event list. */
   4317          				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   4318          
   4319          				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   4320          				{
   4321          					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   4322          					prvAddTaskToReadyList( pxTCB );
   4323          				}
   4324          				else
   4325          				{
   4326          					/* The delayed and ready lists cannot be accessed, so hold
   4327          					this task pending until the scheduler is resumed. */
   4328          					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   4329          				}
   4330          
   4331          				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   4332          				{
   4333          					/* The notified task has a priority above the currently
   4334          					executing task so a yield is required. */
   4335          					if( pxHigherPriorityTaskWoken != NULL )
   4336          					{
   4337          						*pxHigherPriorityTaskWoken = pdTRUE;
   4338          					}
   4339          				}
   4340          				else
   4341          				{
   4342          					mtCOVERAGE_TEST_MARKER();
   4343          				}
   4344          			}
   4345          		}
   4346          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   4347          	}
   4348          
   4349          #endif /* configUSE_TASK_NOTIFICATIONS */
   4350          
   4351          /*-----------------------------------------------------------*/
   4352          
   4353          
   4354          #ifdef FREERTOS_MODULE_TEST
   4355          	#include "tasks_test_access_functions.h"
   4356          #endif
   4357          
   4358          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   prvAddCurrentTaskToDelayedList
         8   -> vListInsert
      32   prvAllocateTCBAndStack
        32   -> __aeabi_memset
        32   -> pvPortMalloc
        32   -> vPortFree
      16   prvCheckTasksWaitingTermination
        16   -> prvDeleteTCB
        16   -> uxListRemove
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vTaskSuspendAll
        16   -> xTaskResumeAll
       8   prvDeleteTCB
         8   -> vPortFree
       8   prvIdleTask
         8   -> prvCheckTasksWaitingTermination
         8   -> vPortYieldFromISR
      24   prvInitialiseTCBVariables
        24   -> vListInitialiseItem
       8   prvInitialiseTaskLists
         8   -> vListInitialise
       4   prvResetNextTaskUnblockTime
       4   prvTaskCheckFreeStackSpace
       8   prvTaskIsTaskSuspended
       4   pvTaskIncrementMutexHeldCount
      24   ulTaskNotifyTake
        24   -> prvAddCurrentTaskToDelayedList
        24   -> uxListRemove
        24   -> vListInsertEnd
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
        24   -> vPortYieldFromISR
       0   uxTaskGetNumberOfTasks
      24   uxTaskGetStackHighWaterMark
        24   -> prvTaskCheckFreeStackSpace
      16   uxTaskPriorityGet
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
      24   uxTaskPriorityGetFromISR
        24   -> uxPortSetInterruptMaskFromISR
        24   -> vPortClearInterruptMaskFromISR
       0   uxTaskResetEventItemValue
      16   vTaskDelay
        16   -> prvAddCurrentTaskToDelayedList
        16   -> uxListRemove
        16   -> vPortYieldFromISR
        16   -> vTaskSuspendAll
        16   -> xTaskResumeAll
      32   vTaskDelayUntil
        32   -> prvAddCurrentTaskToDelayedList
        32   -> uxListRemove
        32   -> vPortYieldFromISR
        32   -> vTaskSuspendAll
        32   -> xTaskResumeAll
      16   vTaskDelete
        16   -> prvResetNextTaskUnblockTime
        16   -> uxListRemove
        16   -> vListInsertEnd
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vPortYieldFromISR
       8   vTaskEndScheduler
         8   -> vPortEndScheduler
       0   vTaskMissedYield
      24   vTaskNotifyGiveFromISR
        24   -> uxListRemove
        24   -> uxPortSetInterruptMaskFromISR
        24   -> vListInsertEnd
        24   -> vPortClearInterruptMaskFromISR
      16   vTaskPlaceOnEventList
        16   -> prvAddCurrentTaskToDelayedList
        16   -> uxListRemove
        16   -> vListInsert
        16   -> vListInsertEnd
      16   vTaskPlaceOnEventListRestricted
        16   -> prvAddCurrentTaskToDelayedList
        16   -> uxListRemove
        16   -> vListInsertEnd
      24   vTaskPlaceOnUnorderedEventList
        24   -> prvAddCurrentTaskToDelayedList
        24   -> uxListRemove
        24   -> vListInsertEnd
      16   vTaskPriorityInherit
        16   -> uxListRemove
        16   -> vListInsertEnd
      32   vTaskPrioritySet
        32   -> uxListRemove
        32   -> vListInsertEnd
        32   -> vPortEnterCritical
        32   -> vPortExitCritical
        32   -> vPortYieldFromISR
      16   vTaskResume
        16   -> prvTaskIsTaskSuspended
        16   -> uxListRemove
        16   -> vListInsertEnd
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vPortYieldFromISR
       4   vTaskSetTimeOutState
      24   vTaskStartScheduler
        24   -> xPortStartScheduler
        24   -> xTaskGenericCreate
        24   -> xTimerCreateTimerTask
      16   vTaskSuspend
        16   -> prvResetNextTaskUnblockTime
        16   -> uxListRemove
        16   -> vListInsertEnd
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vPortYieldFromISR
        16   -> vTaskSwitchContext
       0   vTaskSuspendAll
       4   vTaskSwitchContext
      24   xTaskCheckForTimeOut
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
        24   -> vTaskSetTimeOutState
      40   xTaskGenericCreate
        40   -> prvAllocateTCBAndStack
        40   -> prvInitialiseTCBVariables
        40   -> prvInitialiseTaskLists
        40   -> pxPortInitialiseStack
        40   -> vListInsertEnd
        40   -> vPortEnterCritical
        40   -> vPortExitCritical
        40   -> vPortYieldFromISR
       0   xTaskGetCurrentTaskHandle
       4   xTaskGetSchedulerState
       8   xTaskGetTickCount
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
      16   xTaskGetTickCountFromISR
        16   -> uxPortSetInterruptMaskFromISR
        16   -> vPortClearInterruptMaskFromISR
      24   xTaskIncrementTick
        24   -> prvResetNextTaskUnblockTime
        24   -> uxListRemove
        24   -> vListInsertEnd
      32   xTaskNotify
        32   -> uxListRemove
        32   -> vListInsertEnd
        32   -> vPortEnterCritical
        32   -> vPortExitCritical
        32   -> vPortYieldFromISR
      40   xTaskNotifyFromISR
        40   -> uxListRemove
        40   -> uxPortSetInterruptMaskFromISR
        40   -> vListInsertEnd
        40   -> vPortClearInterruptMaskFromISR
      32   xTaskNotifyWait
        32   -> prvAddCurrentTaskToDelayedList
        32   -> uxListRemove
        32   -> vListInsertEnd
        32   -> vPortEnterCritical
        32   -> vPortExitCritical
        32   -> vPortYieldFromISR
      16   xTaskPriorityDisinherit
        16   -> uxListRemove
        16   -> vListInsertEnd
      16   xTaskRemoveFromEventList
        16   -> uxListRemove
        16   -> vListInsertEnd
      24   xTaskRemoveFromUnorderedEventList
        24   -> uxListRemove
        24   -> vListInsertEnd
      16   xTaskResumeAll
        16   -> uxListRemove
        16   -> vListInsertEnd
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vPortYieldFromISR
        16   -> xTaskIncrementTick
      24   xTaskResumeFromISR
        24   -> prvTaskIsTaskSuspended
        24   -> uxListRemove
        24   -> uxPortSetInterruptMaskFromISR
        24   -> vListInsertEnd
        24   -> vPortClearInterruptMaskFromISR


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable14
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable19
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_2
       4  ??DataTable22_3
       4  ??DataTable22_4
       4  ??DataTable22_5
       4  ??DataTable22_6
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable25
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable29
       4  ??DataTable30
       4  ??DataTable30_1
       4  ??DataTable31
       4  ??DataTable32
       4  ??DataTable33
       4  ??DataTable36
       4  ??DataTable36_1
       4  ??DataTable36_2
       4  ??DataTable36_3
       4  ??DataTable36_4
       4  ??DataTable37
       4  ??DataTable39
       4  ??DataTable39_1
       4  ??DataTable39_2
       4  ??DataTable39_3
       4  ??DataTable40
       4  ??DataTable41
       4  ??DataTable41_1
       4  ??DataTable41_2
       4  ??DataTable41_3
       4  ??DataTable43
       4  ??DataTable43_1
       4  ??DataTable43_2
       4  ??DataTable44
       4  ??DataTable44_1
       4  ??DataTable44_2
       4  ??DataTable44_3
       4  ??DataTable44_4
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable8
       4  ??DataTable8_1
       8  ?_0
      62  prvAddCurrentTaskToDelayedList
      98  prvAllocateTCBAndStack
      90  prvCheckTasksWaitingTermination
      18  prvDeleteTCB
      22  prvIdleTask
      94  prvInitialiseTCBVariables
      70  prvInitialiseTaskLists
      40  prvResetNextTaskUnblockTime
      24  prvTaskCheckFreeStackSpace
      44  prvTaskIsTaskSuspended
      26  pvTaskIncrementMutexHeldCount
       4  pxCurrentTCB
       4  pxDelayedTaskList
       4  pxOverflowDelayedTaskList
     360  pxReadyTasksLists
     146  ulTaskNotifyTake
       4  uxCurrentNumberOfTasks
       4  uxPendedTicks
       4  uxSchedulerSuspended
       6  uxTaskGetNumberOfTasks
      32  uxTaskGetStackHighWaterMark
       4  uxTaskNumber
      32  uxTaskPriorityGet
      36  uxTaskPriorityGetFromISR
      26  uxTaskResetEventItemValue
       4  uxTasksDeleted
       4  uxTopReadyPriority
      66  vTaskDelay
     130  vTaskDelayUntil
     124  vTaskDelete
      16  vTaskEndScheduler
       8  vTaskMissedYield
     150  vTaskNotifyGiveFromISR
      74  vTaskPlaceOnEventList
      52  vTaskPlaceOnEventListRestricted
     100  vTaskPlaceOnUnorderedEventList
     118  vTaskPriorityInherit
     194  vTaskPrioritySet
     104  vTaskResume
      24  vTaskSetTimeOutState
      76  vTaskStartScheduler
     138  vTaskSuspend
      12  vTaskSuspendAll
     110  vTaskSwitchContext
      20  xDelayedTaskList1
      20  xDelayedTaskList2
       4  xNextTaskUnblockTime
       4  xNumOfOverflows
      20  xPendingReadyList
       4  xSchedulerRunning
      20  xSuspendedTaskList
     112  xTaskCheckForTimeOut
     266  xTaskGenericCreate
       8  xTaskGetCurrentTaskHandle
      36  xTaskGetSchedulerState
      20  xTaskGetTickCount
      24  xTaskGetTickCountFromISR
     254  xTaskIncrementTick
     182  xTaskNotify
     216  xTaskNotifyFromISR
     174  xTaskNotifyWait
     104  xTaskPriorityDisinherit
     120  xTaskRemoveFromEventList
     118  xTaskRemoveFromUnorderedEventList
     198  xTaskResumeAll
     120  xTaskResumeFromISR
      20  xTasksWaitingTermination
       4  xTickCount
       4  xYieldPending

 
   512 bytes in section .bss
     4 bytes in section .data
     8 bytes in section .rodata
 4 582 bytes in section .text
 
 4 582 bytes of CODE  memory
     8 bytes of CONST memory
   516 bytes of DATA  memory

Errors: none
Warnings: none
