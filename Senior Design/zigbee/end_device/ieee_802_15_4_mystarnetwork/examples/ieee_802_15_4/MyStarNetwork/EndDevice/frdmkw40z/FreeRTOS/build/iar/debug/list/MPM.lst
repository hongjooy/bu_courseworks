###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       06/Apr/2016  15:58:42
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\ieee_802_15_4\Source\Phy\Source\MKW40Z\MPM.c
#    Command line =  
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\ieee_802_15_4\Source\Phy\Source\MKW40Z\MPM.c
#        -D DEBUG -D IAR -D CPU_MKW40Z160VHT4 -lcN "C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork\examples\ieee_802_15_4\MyStarNetwork\EndDevice\frdmkw40z\FreeRTOS\build\iar\debug\list"
#        --diag_suppress Pa039,Pe068,Pe069,Pa082,Pe177,Pe186,Pe550,Pa050 -o
#        "C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork\examples\ieee_802_15_4\MyStarNetwork\EndDevice\frdmkw40z\FreeRTOS\build\iar\debug\obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" --preinclude "C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork/examples/ieee_802_15_4/MyStarNetwork/EndDevice/frdmkw40z/FreeRTOS/app_preinclude.h"
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/CMSIS/Include\
#        -I "C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork/boards/frdmkw40z\"
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/devices\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/devices/MKW40Z4/include\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/devices/MKW40Z4/startup\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/system/src/clock/MKW40Z4\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/ieee_802_15_4/Source/App\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/ieee_802_15_4/Source/Mac/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/GPIOIrq\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/Keyboard/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/LED/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/SerialManager/Source/SPI_Adapter\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/Common\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/MemManager/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/Messaging/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/OSAbstraction/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/osa/inc\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/Panic/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/RNG/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/SerialManager/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/TimersManager/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/TimersManager/Source\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/FunctionLib\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/Lists\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/SecLib\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/ModuleInfo\
#        -I "C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork/examples/ieee_802_15_4/MyStarNetwork/EndDevice/common\"
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/devices\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/devices/MKW40Z4/startup\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/rtos/FreeRTOS/include\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/rtos/FreeRTOS/port/iar\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/rtos/FreeRTOS/config/KW40Z4/iar\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/ieee_802_15_4/Source/Phy/Source/MKW40Z\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/ieee_802_15_4/Source/Phy/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/XCVR/MKW40Z4\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/DCDC/Interface\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/../ConnSw/framework/Flash/Internal\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/drivers/src/flash/C90TFS/drvsrc/include\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/drivers/inc\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/system/inc\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/hal/inc\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\KSDK_1.3.0/platform/utilities/inc\
#        -On
#    List file    =  
#        C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork\examples\ieee_802_15_4\MyStarNetwork\EndDevice\frdmkw40z\FreeRTOS\build\iar\debug\list\MPM.lst
#    Object file  =  
#        C:\Users\Jooyoun
#        Hong.Julianne\Desktop\cloned_star\ieee_802_15_4_mystarnetwork\examples\ieee_802_15_4\MyStarNetwork\EndDevice\frdmkw40z\FreeRTOS\build\iar\debug\obj\MPM.o
#
###############################################################################

C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\ieee_802_15_4\Source\Phy\Source\MKW40Z\MPM.c
      1          /*!
      2          * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3          * All rights reserved.
      4          *
      5          * \file MPM.c
      6          * This is the source file for the Multiple PAN Manager.
      7          *
      8          * Redistribution and use in source and binary forms, with or without modification,
      9          * are permitted provided that the following conditions are met:
     10          *
     11          * o Redistributions of source code must retain the above copyright notice, this list
     12          *   of conditions and the following disclaimer.
     13          *
     14          * o Redistributions in binary form must reproduce the above copyright notice, this
     15          *   list of conditions and the following disclaimer in the documentation and/or
     16          *   other materials provided with the distribution.
     17          *
     18          * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     19          *   contributors may be used to endorse or promote products derived from this
     20          *   software without specific prior written permission.
     21          *
     22          * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     23          * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     24          * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     25          * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     26          * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     27          * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     28          * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     29          * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     30          * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     31          * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     32          */
     33          
     34          /*! *********************************************************************************
     35          *************************************************************************************
     36          * Include
     37          *************************************************************************************
     38          ********************************************************************************** */
     39          
     40          #include "EmbeddedTypes.h"
     41          #include "MpmInterface.h"
     42          #include "Phy.h"
     43          
     44          #include "FunctionLib.h"
     45          #include "MemManager.h"
     46          
     47          
     48          #if gMpmIncluded_d
     49          
     50          /*! *********************************************************************************
     51          *************************************************************************************
     52          * Public macros
     53          *************************************************************************************
     54          ********************************************************************************** */
     55          
     56          /*! *********************************************************************************
     57          *************************************************************************************
     58          * Public type definitions
     59          *************************************************************************************
     60          ********************************************************************************** */
     61          
     62          /*! *********************************************************************************
     63          *************************************************************************************
     64          * Private memory declarations
     65          *************************************************************************************
     66          ********************************************************************************** */
     67          uint8_t        mRegisteredPANs;
     68          bool_t         mMpmExclusiveAccess;
     69          panInfo_t      mPanInfo[gMpmMaxPANs_c];
     70          panInfo_t     *pActivePANs[gMpmPhyPanRegSets_c];
     71          
     72          
     73          /*! *********************************************************************************
     74          *************************************************************************************
     75          * Private functions prototypes
     76          *************************************************************************************
     77          ********************************************************************************** */
     78          static void MPM_SetPanSettingsInPhy( uint8_t panIndex );
     79          static uint8_t MPM_AllocateResource( bool_t force, uint8_t panIdx );
     80          
     81          /*! *********************************************************************************
     82          *************************************************************************************
     83          * Public functions
     84          *************************************************************************************
     85          ********************************************************************************** */
     86          
     87          /*! *********************************************************************************
     88          * \brief  This function determines the instance of the MAC associated with a PHY regSet
     89          *
     90          * \param[in]  regSet The PHY registry set
     91          *
     92          * \return  The instance of the MAC associated with a PHY registry set.
     93          *
     94          ********************************************************************************** */
     95          uint32_t MPM_GetMacInstanceFromRegSet(uint32_t regSet)
     96          {
     97              if( pActivePANs[regSet] )
     98                  return pActivePANs[regSet]->macInstance;
     99          
    100              return 0;
    101          }
    102          
    103          /*! *********************************************************************************
    104          * \brief  This function determines the PHY regSet for the specified panIndex
    105          *
    106          * \param[in]  panIdx The index in mPanInfo[] table
    107          *
    108          * \return  The PHY registry set.
    109          *
    110          ********************************************************************************** */
    111          uint32_t MPM_GetRegSet( uint8_t panIdx )
    112          {
    113              return mPanInfo[panIdx].phyRegSet;
    114          }
    115          
    116          /*! *********************************************************************************
    117          * \brief  This function determines the PHY regSet for the specified panIndex
    118          *
    119          * \param[in]  pibId The id of the PHY PIB
    120          * \param[in]  pValue The value of the PHY PIB
    121          * \param[in]  panIdx The index in mPanInfo[] table
    122          *
    123          * \return  The status of the operation.
    124          *
    125          ********************************************************************************** */
    126          phyStatus_t MPM_SetPIB(phyPibId_t pibId, void* pValue, uint8_t panIdx)
    127          {
    128              switch(pibId)
    129              {
    130          #if gMpmUseDifferentTxPwrLevel_c
    131              case gPhyPibTransmitPower_c:
    132                  if( (*(uint8_t*)pValue < 3) || (*(uint8_t*)pValue > 31) )
    133                  {
    134                      return gPhyInvalidParameter_c;
    135                  }
    136                  mPanInfo[panIdx].pwrLevel = *(uint8_t*)pValue;
    137                  break;
    138          #endif
    139          #if (gMpmMaxPANs_c > gMpmPhyPanRegSets_c)
    140              case gPhyPibCurrentChannel_c:
    141                  if( (*(uint8_t*)pValue < 11) || (*(uint8_t*)pValue > 26) )
    142                  {
    143                      return gPhyInvalidParameter_c;
    144                  }
    145                  mPanInfo[panIdx].channel = *(uint8_t*)pValue;
    146                  break;
    147              case gPhyPibLongAddress_c:
    148                  FLib_MemCpy(&mPanInfo[panIdx].longAddr, pValue, sizeof(mPanInfo[panIdx].longAddr));
    149                  break;
    150              case gPhyPibShortAddress_c:
    151                  FLib_MemCpy(&mPanInfo[panIdx].shortAddr, pValue, sizeof(mPanInfo[panIdx].shortAddr));
    152                  break;
    153              case gPhyPibPanId_c:
    154                  FLib_MemCpy(&mPanInfo[panIdx].panId, pValue, sizeof(mPanInfo[panIdx].panId));
    155                  break;
    156              case gPhyPibPanCoordinator_c:
    157                  if( *(bool_t*)pValue )
    158                      mPanInfo[panIdx].flags |= gMpmFlagPanCoord_c;
    159                  else
    160                      mPanInfo[panIdx].flags &= ~gMpmFlagPanCoord_c;
    161                  break;
    162          #endif
    163              case gPhyPibRxOnWhenIdle:
    164                  if( *(bool_t*)pValue )
    165                      mPanInfo[panIdx].flags |= gMpmFlagRxOnWhenIdle_c;
    166                  else
    167                      mPanInfo[panIdx].flags &= ~gMpmFlagRxOnWhenIdle_c;
    168                  break;
    169              case gPhyPibPromiscuousMode_c:
    170                  if( *(bool_t*)pValue )
    171                      mPanInfo[panIdx].flags |= gMpmFlagPromiscuous_c;
    172                  else
    173                      mPanInfo[panIdx].flags &= ~gMpmFlagPromiscuous_c;
    174                  break;
    175              default:
    176                  return gPhyUnsupportedAttribute_c;
    177              }
    178          
    179              return gPhySuccess_c;
    180          }
    181          
    182          /*! *********************************************************************************
    183          * \brief  This function determines the PHY regSet for the specified panIndex
    184          *
    185          * \param[in]  pibId  The id of the PHY PIB
    186          * \param[in]  pValue pointer to a location where to store the PIB value
    187          * \param[in]  panIdx The index in mPanInfo[] table
    188          *
    189          * \return  The status of the operation.
    190          *
    191          ********************************************************************************** */
    192          phyStatus_t MPM_GetPIB(phyPibId_t pibId, void *pValue, uint8_t panIdx)
    193          {
    194              switch(pibId)
    195              {
    196          #if gMpmUseDifferentTxPwrLevel_c
    197              case gPhyPibTransmitPower_c:
    198                  *(uint8_t*)pValue = mPanInfo[panIdx].pwrLevel;
    199                  break;
    200          #endif
    201          #if (gMpmMaxPANs_c > gMpmPhyPanRegSets_c)
    202              case gPhyPibCurrentChannel_c:
    203                  *(uint8_t*)pValue = mPanInfo[panIdx].channel;
    204                  break;
    205              case gPhyPibLongAddress_c:
    206                  FLib_MemCpy(pValue, &mPanInfo[panIdx].longAddr, sizeof(mPanInfo[panIdx].longAddr));
    207                  break;
    208              case gPhyPibShortAddress_c:
    209                  FLib_MemCpy(pValue, &mPanInfo[panIdx].shortAddr, sizeof(mPanInfo[panIdx].shortAddr));
    210                  break;
    211              case gPhyPibPanId_c:
    212                  FLib_MemCpy(pValue, &mPanInfo[panIdx].panId, sizeof(mPanInfo[panIdx].panId));
    213                  break;
    214              case gPhyPibPanCoordinator_c:
    215                  *(uint8_t*)pValue = !!(mPanInfo[panIdx].flags & gMpmFlagPanCoord_c);
    216                  break;
    217          #endif
    218              case gPhyPibRxOnWhenIdle:
    219                  *(uint8_t*)pValue = !!(mPanInfo[panIdx].flags & gMpmFlagRxOnWhenIdle_c);
    220                  break;
    221              case gPhyPibPromiscuousMode_c:
    222                  *(uint8_t*)pValue = !!(mPanInfo[panIdx].flags & gMpmFlagPromiscuous_c);
    223                  break;
    224              default:
    225                  return gPhyUnsupportedAttribute_c;
    226              }
    227          
    228              return gPhySuccess_c;
    229          }
    230          
    231          
    232          /*! *********************************************************************************
    233          * \brief  This function initializes the MPM module.
    234          *
    235          * \param[in]  None.
    236          *
    237          * \return  None
    238          *
    239          ********************************************************************************** */
    240          void MPM_Init( void )
    241          {
    242              uint32_t i;
    243          
    244              mRegisteredPANs = 0;
    245              mMpmExclusiveAccess = FALSE;
    246              FLib_MemSet( mPanInfo, 0x00, sizeof(mPanInfo) );
    247              FLib_MemSet( pActivePANs, 0x00, sizeof(pActivePANs) );
    248          
    249              for(i=0; i<gMpmMaxPANs_c; i++)
    250                mPanInfo[i].phyRegSet = gMpmInvalidRegSet_c;
    251          
    252              PhyPpSetDualPanDwell( ((mDefaultDualPanDwellPrescaller_c << mDualPanDwellPrescallerShift_c) & mDualPanDwellPrescallerMask_c) |
    253                                    ((mDefaultDualPanDwellTime_c       << mDualPanDwellTimeShift_c      ) & mDualPanDwellTimeMask_c) );
    254          }
    255          
    256          /*! *********************************************************************************
    257          * \brief  This function prepare the Radio for a TX/CCA/ED operation
    258          *
    259          * \param[in]  macInstance The instance of the MAC
    260          *
    261          * \return  The status of the Operation
    262          *
    263          ********************************************************************************** */
    264          phyStatus_t MPM_PrepareForTx( instanceId_t macInstance )
    265          {
    266              uint8_t panIdx = MPM_GetPanIndex(macInstance);
    267          
    268              if( TRUE == mMpmExclusiveAccess && mPanInfo[panIdx].locked <= 0 )
    269                  return gPhyChannelBusy_c;
    270          
    271              /* Allocate HW Resources if necessary */
    272              if( mPanInfo[panIdx].phyRegSet == gMpmInvalidRegSet_c )
    273              {
    274                  if( gMpmInvalidRegSet_c == MPM_AllocateResource( TRUE, panIdx ) )
    275                      return gPhyChannelBusy_c;
    276          
    277                  MPM_SetPanSettingsInPhy( panIdx );
    278              }
    279          
    280              /* Disable DualPan Auto Mode, and select the Active PAN */
    281              PhyPpSetDualPanAuto( FALSE );
    282              PhyPpSetDualPanActiveNwk( mPanInfo[panIdx].phyRegSet );
    283              return gPhySuccess_c;
    284          }
    285          
    286          /*! *********************************************************************************
    287          * \brief  This function checks if a PAN has the RxOnWhenIdle PIB set.
    288          *         If an Rx needs to be started, it makes the propper settings in PHY.
    289          *
    290          * \param[in]  None.
    291          *
    292          * \return  phyStatus
    293          *
    294          ********************************************************************************** */
    295          phyStatus_t MPM_PrepareForRx( instanceId_t macInstance )
    296          {
    297              uint32_t i, count = 0;
    298              uint32_t activePan;
    299          
    300              if( gInvalidInstanceId_c != macInstance ) /* Rx */
    301              {
    302                  i = MPM_GetPanIndex(macInstance);
    303          
    304                  if( !mMpmExclusiveAccess || mPanInfo[i].locked )
    305                  {
    306                      /* Allocate HW Resources if necessary */
    307                      if( mPanInfo[i].phyRegSet == gMpmInvalidRegSet_c )
    308                      {
    309                          if( gMpmInvalidRegSet_c == MPM_AllocateResource( TRUE, i ) )
    310                              return gPhyChannelBusy_c;
    311          
    312                          MPM_SetPanSettingsInPhy( i );
    313                      }
    314          
    315                      count++;
    316                      activePan = mPanInfo[i].phyRegSet;
    317                  }
    318              }
    319              else /* RxOnWhenIdle */
    320              {
    321                  for( i=0; i<gMpmPhyPanRegSets_c; i++)
    322                  {
    323                      if( (NULL != pActivePANs[i]) &&
    324                          (pActivePANs[i]->flags & gMpmFlagRxOnWhenIdle_c) &&
    325                          ( !mMpmExclusiveAccess || pActivePANs[i]->locked ) )
    326                      {
    327                          activePan = i;
    328                          count++;
    329                      }
    330                  }
    331              }
    332          
    333              if( !count )
    334                  return gPhyChannelBusy_c;
    335          
    336              /* Set the Active PAN and DualPan Auto mode if needed*/
    337              PhyPpSetDualPanActiveNwk( activePan );
    338              PhyPpSetDualPanAuto( count > 1 );
    339              return gPhySuccess_c;
    340          }
    341          
    342          /*! *********************************************************************************
    343          * \brief  This function returns the PAN index for a MAC instance
    344          *
    345          * \param[in]  macInstance The instance of the MAC
    346          *
    347          * \return  The PAN index or -1 if it was not found
    348          *
    349          ********************************************************************************** */
    350          int32_t  MPM_GetPanIndex( instanceId_t macInstance )
    351          {
    352              uint32_t i;
    353          
    354              /* Get PAN Index for the macInstance */
    355              for( i=0; i<mRegisteredPANs; i++ )
    356              {
    357                  if( mPanInfo[i].macInstance == macInstance )
    358                      return i;
    359              }
    360          
    361              /* The instance of the MAC is not registered!
    362               * Register the current MAC instance if there is enough space.
    363               */
    364              if( mRegisteredPANs < gMpmMaxPANs_c )
    365              {
    366                  mPanInfo[mRegisteredPANs].macInstance = macInstance;
    367          
    368                  /* Try to allocate HW resource */
    369                  mPanInfo[mRegisteredPANs].phyRegSet = MPM_AllocateResource( FALSE, i );
    370                  mRegisteredPANs++;
    371              }
    372              else
    373              {
    374                  i = -1;
    375              }
    376          
    377              return i;
    378          }
    379          
    380          
    381          /*! *********************************************************************************
    382          * \brief  This function configures the MPM module
    383          *
    384          * \param[in]  pCfg pointer to a configuration structure
    385          *
    386          * \remarks
    387          * The Dual PAN dwell time prescaller values: 0-3
    388          * The Dual PAN dwell time values 0-63.
    389          * The (dwellTime+1) represents multiples of the prescaller time base.
    390          *
    391          ********************************************************************************** */
    392          void MPM_SetConfig( mpmConfig_t *pCfg )
    393          {
    394              PhyPpSetDualPanAuto ( FALSE );
    395              PhyPpSetDualPanDwell( pCfg->dwellTime );
    396              MPM_AllocateResource( TRUE, MPM_GetPanIndex(pCfg->activeMAC) );
    397              PhyPpSetDualPanAuto ( pCfg->autoMode );
    398              if( PhyIsIdleRx(0) )
    399              {
    400                  PhyPlmeForceTrxOffRequest();
    401                  Radio_Phy_TimeRxTimeoutIndication(0);
    402              }
    403          }
    404          
    405          /*! *********************************************************************************
    406          * \brief  This function returns the MPM configuration
    407          *
    408          * \param[in]  pCfg pointer to a configuration structure
    409          *
    410          * \return  None.
    411          *
    412          ********************************************************************************** */
    413          void MPM_GetConfig( mpmConfig_t *pCfg )
    414          {
    415              pCfg->dwellTime  = PhyPpGetDualPanDwell();
    416              pCfg->activeMAC  = MPM_GetMacInstanceFromRegSet( PhyPpGetDualPanActiveNwk() );
    417              pCfg->autoMode   = PhyPpGetDualPanAuto();
    418          }
    419          #endif /* #if gMpmIncluded_d */
    420          
    421          /*! *********************************************************************************
    422          * \brief  This function Acquires a PAN for exclusive access.
    423          *
    424          * \param[in]  macInstance The instance of the MAC
    425          *
    426          * \return  The status of the operation
    427          *
    428          ********************************************************************************** */
    429          phyStatus_t MPM_AcquirePAN( instanceId_t macInstance )
    430          {
    431          #if gMpmIncluded_d
    432              int32_t panIndex = MPM_GetPanIndex(macInstance);
    433          
    434              /* Check if another PAN is acquired */
    435              if( TRUE == mMpmExclusiveAccess &&
    436                  mPanInfo[panIndex].locked <= 0 )
    437              {
    438                  return gPhyBusy_c;
    439              }
    440          
    441              if( mPanInfo[panIndex].locked == 0 )
    442              {
    443                  mMpmExclusiveAccess = TRUE;
    444                  if( PhyIsIdleRx(0) )
    445                  {
    446                      PhyPlmeForceTrxOffRequest();
    447                      Radio_Phy_TimeRxTimeoutIndication(0);
    448                  }
    449              }
    450          
    451              mPanInfo[panIndex].locked++;
    452          #endif
    453              return gPhySuccess_c;
    454          }
    455          
    456          /*! *********************************************************************************
    457          * \brief  This function Releases a PAN that was Acquired
    458          *
    459          * \param[in]  macInstance The instance of the MAC
    460          *
    461          * \return  The status of the operation
    462          *
    463          ********************************************************************************** */
    464          phyStatus_t MPM_ReleasePAN( instanceId_t macInstance )
    465          {
    466          #if gMpmIncluded_d
    467              uint8_t panIndex = MPM_GetPanIndex(macInstance);
    468          
    469              mPanInfo[panIndex].locked--;
    470              if( mPanInfo[panIndex].locked == 0 )
    471              {
    472                  mMpmExclusiveAccess = FALSE;
    473                  if( PhyIsIdleRx(0) )
    474                  {
    475                      PhyPlmeForceTrxOffRequest();
    476                      Radio_Phy_TimeRxTimeoutIndication(0);
    477                  }
    478              }
    479          #endif
    480              return gPhySuccess_c;
    481          }
    482          
    483          /************************************************************************************
    484          *************************************************************************************
    485          * Private functions
    486          *************************************************************************************
    487          ************************************************************************************/
    488          #if gMpmIncluded_d
    489          /*! *********************************************************************************
    490          * \brief  This function alocates a registry set to a PAN.
    491          *
    492          * \param[in]  force If this parameter is TRUE, then another PAN can be preempted.
    493          * \param[in]  panIdx The index into the MPM database
    494          *
    495          * \return  The register set allocated for the specified PAN.
    496          *
    497          ********************************************************************************** */
    498          static uint8_t MPM_AllocateResource( bool_t force, uint8_t panIdx )
    499          {
    500              uint32_t i, regSet = gMpmInvalidRegSet_c;
    501          
    502              if( mPanInfo[panIdx].phyRegSet != gMpmInvalidRegSet_c )
    503                return mPanInfo[panIdx].phyRegSet;
    504          
    505              for( i=0; i<gMpmPhyPanRegSets_c; i++ )
    506              {
    507                  if( NULL == pActivePANs[i] )
    508                  {
    509                      regSet = i;
    510                      break;
    511                  }
    512                  else if( (force) &&
    513                           (pActivePANs[i]->flags == 0) &&
    514                           (pActivePANs[i]->locked <= 0) )
    515                  {
    516                      regSet = i;
    517                  }
    518              }
    519          
    520              if( regSet != gMpmInvalidRegSet_c )
    521              {
    522                  if( NULL != pActivePANs[regSet] )
    523                  {
    524                      pActivePANs[regSet]->phyRegSet = gMpmInvalidRegSet_c;
    525                  }
    526          
    527                  pActivePANs[regSet] = &mPanInfo[panIdx];
    528                  pActivePANs[regSet]->phyRegSet = regSet;
    529              }
    530          
    531              return regSet;
    532          }
    533          
    534          /*! *********************************************************************************
    535          * \brief  This function will store PAN settings in PHY.
    536          *
    537          * \param[in]  panIdx The index into the MPM database
    538          *
    539          * \return  None.
    540          *
    541          * \remarks Function assumes that the PAN is active!
    542          *
    543          ********************************************************************************** */
    544          static void MPM_SetPanSettingsInPhy( uint8_t panIndex )
    545          {
    546              panInfo_t *pPAN = &mPanInfo[panIndex];
    547          
    548          #if gMpmUseDifferentTxPwrLevel_c
    549              PhyPlmeSetPIBRequest(gPhyPibTransmitPower_c,   pPAN->pwrLevel,            pPAN->phyRegSet, 0 );
    550          #endif
    551          
    552          #if (gMpmMaxPANs_c > gMpmPhyPanRegSets_c)
    553              PhyPlmeSetPIBRequest(gPhyPibPromiscuousMode_c, !!(pPAN->flags & gMpmFlagPromiscuous_c),  pPAN->phyRegSet, 0 );
    554              PhyPlmeSetPIBRequest(gPhyPibRxOnWhenIdle,      !!(pPAN->flags & gMpmFlagRxOnWhenIdle_c), pPAN->phyRegSet, 0 );
    555              PhyPlmeSetPIBRequest(gPhyPibPanCoordinator_c,  !!(pPAN->flags & gMpmFlagPanCoord_c),     pPAN->phyRegSet, 0 );
    556              PhyPlmeSetPIBRequest(gPhyPibPanId_c,           pPAN->panId,     pPAN->phyRegSet, 0 );
    557              PhyPlmeSetPIBRequest(gPhyPibShortAddress_c,    pPAN->shortAddr, pPAN->phyRegSet, 0 );
    558              PhyPlmeSetPIBRequest(gPhyPibLongAddress_c,     pPAN->longAddr,  pPAN->phyRegSet, 0 );
    559              PhyPlmeSetPIBRequest(gPhyPibCurrentChannel_c,  pPAN->channel,   pPAN->phyRegSet, 0 );
    560          #else
    561              (void)pPAN;
    562          #endif
    563          }
    564          #endif /* gMpmIncluded_d */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   MPM_AcquirePAN
       0   MPM_ReleasePAN


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       6  MPM_AcquirePAN
       6  MPM_ReleasePAN

 
 12 bytes in section .text
 
 12 bytes of CODE memory

Errors: none
Warnings: none
